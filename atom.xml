<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SanHuo</title>
  
  <subtitle>纤凝翠薇巅，扶光入沧渊，扶摇惊砂起，山弄望舒远</subtitle>
  <link href="http://cencuansen.github.com/atom.xml" rel="self"/>
  
  <link href="http://cencuansen.github.com/"/>
  <updated>2023-02-16T11:26:27.668Z</updated>
  <id>http://cencuansen.github.com/</id>
  
  <author>
    <name>SanHuo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL 慢查询排查</title>
    <link href="http://cencuansen.github.com/database/MySQL-slow-query-troubleshooting"/>
    <id>http://cencuansen.github.com/database/MySQL-slow-query-troubleshooting</id>
    <published>2023-02-16T09:04:39.000Z</published>
    <updated>2023-02-16T11:26:27.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h1><ol><li>查看“慢查询日志”找慢 SQL</li><li>explain“执行计划”查询</li><li>profile 执行耗时分析</li><li>Optimizer Trace</li></ol><h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><p>该功能默认是关闭的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看慢查询日志功能是否开启，默认 OFF</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询超时多久的查询才被记录日志</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;long_query_time&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看日志输出模式 FILE、TABLE</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">LIKE</span> <span class="string">&#x27;%log_output%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>用配置开启慢查询日志，持久性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line"># 开启慢查询日志</span><br><span class="line">slow_query_log = ON</span><br><span class="line"></span><br><span class="line"># 慢查询日志文件位置</span><br><span class="line">slow_query_log_file = dir\filename</span><br><span class="line"></span><br><span class="line"># 大于 3 秒就记录日志</span><br><span class="line">long_query_time = 3</span><br><span class="line"></span><br><span class="line"># 将未使用索引的查询记录日志</span><br><span class="line">log_queries_not_using_indexes = ON</span><br></pre></td></tr></table></figure><p>用命令开启慢查询日志，临时性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL slow_query_log=ON;</span><br><span class="line">SET GLOBAL long_query_time=3;</span><br><span class="line">SET GLOBAL slow_query_log_file=<span class="built_in">dir</span>\filename;</span><br></pre></td></tr></table></figure><p>查看记录的慢查询日志</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mysql.slow_log;</span><br></pre></td></tr></table></figure><h1 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h1><p>执行计划是模拟执行 SQL 查询，来查看执行策略。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;stu&#x27;</span> <span class="keyword">where</span> gender<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1 id="执行耗时分析"><a href="#执行耗时分析" class="headerlink" title="执行耗时分析"></a>执行耗时分析</h1><p>profile 根据最近执行的 SQL，显示执行耗时情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;stu&#x27;</span> <span class="keyword">where</span> gender<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;stu&#x27;</span> <span class="keyword">where</span> gender<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br></pre></td></tr></table></figure><h1 id="Optimizer-Trace"><a href="#Optimizer-Trace" class="headerlink" title="Optimizer Trace"></a>Optimizer Trace</h1><p>optimizer trace 跟踪 SQL 语句解析优化执行过程。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;stu&#x27;</span> <span class="keyword">where</span> gender<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;排查思路&quot;&gt;&lt;a href=&quot;#排查思路&quot; class=&quot;headerlink&quot; title=&quot;排查思路&quot;&gt;&lt;/a&gt;排查思路&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;查看“慢查询日志”找慢 SQL&lt;/li&gt;
&lt;li&gt;explain“执行计划”查询&lt;/li&gt;
&lt;li&gt;profil</summary>
      
    
    
    
    <category term="MySQL" scheme="http://cencuansen.github.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://cencuansen.github.com/tags/MySQL/"/>
    
    <category term="Slow Query" scheme="http://cencuansen.github.com/tags/Slow-Query/"/>
    
  </entry>
  
  <entry>
    <title>MySQL MVCC</title>
    <link href="http://cencuansen.github.com/database/MySQL-MVCC"/>
    <id>http://cencuansen.github.com/database/MySQL-MVCC</id>
    <published>2023-02-16T09:02:31.000Z</published>
    <updated>2023-02-16T11:26:27.666Z</updated>
    
    <content type="html"><![CDATA[<p>多版本并发控制(Multiversion Concurrency Control)，通过保存数据在某时刻的快照来实现并发控制，不管事务执行多长时间，事务内部看到的数据不受其它事务影响。InnoDB 用 Undo Log 保存数据的多个版本。</p><p>普通锁，只能串行执行；<br>读写锁，可以实现读读并发；<br>多版本并发控制，可以实现读写并发。</p><p>隔离级别要求：已提交读和可重复读。未提交读总是读取最新的数据行，串行化会对读取的行加锁。</p><p>事务 ID：每开启一个事务，我们都会从数据库中获得一个事务 ID（事务版本号），这个事务 ID 是自增长的。</p><h1 id="隐藏列"><a href="#隐藏列" class="headerlink" title="隐藏列"></a>隐藏列</h1><ol><li>DB_ROW_ID，隐藏的行 ID，用来生成默认聚簇索引；</li><li>DB_TRX_ID，事务 ID；</li><li>DB_ROLL_PTR，回滚指针，指向行数据的 Undo Log；</li></ol><h1 id="SELECT："><a href="#SELECT：" class="headerlink" title="SELECT："></a>SELECT：</h1><ol><li>事务 ID 早于当前事务 ID 的数据，确保数据已经存在或当前事务自身插入或者修改的；</li><li>删除版本未定义或大于当前事务 ID，确保在事务开始之前未被删除。<br>INSERT：数据的事务 ID 列保存当前事务 ID。<br>DELETE：数据的删除标识更新为当前事务 ID，删除被视为更新，行中的一个特殊位用来标记。<br>UPDATE：插入新记录，数据的事务 ID 列保存当前事务 ID，原数据的删除标识更新为当前事务 ID。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;多版本并发控制(Multiversion Concurrency Control)，通过保存数据在某时刻的快照来实现并发控制，不管事务执行多长时间，事务内部看到的数据不受其它事务影响。InnoDB 用 Undo Log 保存数据的多个版本。&lt;/p&gt;
&lt;p&gt;普通锁，只能串行执</summary>
      
    
    
    
    <category term="MySQL" scheme="http://cencuansen.github.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://cencuansen.github.com/tags/MySQL/"/>
    
    <category term="MVCC" scheme="http://cencuansen.github.com/tags/MVCC/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 存储过程</title>
    <link href="http://cencuansen.github.com/database/MySQL-procedure"/>
    <id>http://cencuansen.github.com/database/MySQL-procedure</id>
    <published>2023-02-16T08:56:23.000Z</published>
    <updated>2023-02-16T11:26:27.668Z</updated>
    
    <content type="html"><![CDATA[<p>存储过程：SQL 语句集合。</p><h1 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h1><ol><li>在创建时进行编译，执行不再重新编译；一般 SQL 执行一次编译一次。</li><li>将此复杂操作用存储过程封装起来。</li><li>存储过程可以重复使用。</li></ol><h1 id="坏处："><a href="#坏处：" class="headerlink" title="坏处："></a>坏处：</h1><ol><li>不易调试。</li><li>可移植性差。</li></ol><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span> delete_data;</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> delete_data(<span class="keyword">IN</span> idX <span class="type">INTEGER</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `source` <span class="keyword">WHERE</span> id <span class="operator">=</span> idX;</span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h1 id="其他说法一"><a href="#其他说法一" class="headerlink" title="其他说法一"></a>其他说法一</h1><p>存储过程没有版本控制，版本迭代的时候要更新很麻烦。<br>存储过程如果和外部程序结合起来用，更新的时候很难无感升级，可能需要停服。<br>存储过程不利于将来分库分表。<br>存储过程的功能不一定够强大，业务扩展之后可能会发现无法继续用存储过程实现了。<br>存储过程可能无法和许多中间件、ORM 库一起使用。<br>某些特殊的兼容 MySQL 的实现可能根本就不支持存储过程，那就更不用说了。<br>这也不绝对，在微软的时候就有项目是反过来的，所有业务都需要用存储过程写在 SQLServer 里面，查询全写成视图，业务代码只允许使用视图和存储过程，只要 SELECT 和 EXECUTE 权限就够了；修改业务只需要登服务器改存储过程。这属于思路不同。</p><h1 id="其他说法二"><a href="#其他说法二" class="headerlink" title="其他说法二"></a>其他说法二</h1><p>任何技术都要分使用场景，阿里这种互联网高并发的场景，很多数据都是分库分表的，而且要求高度可扩展，原则是对 db 的保护做到最大化，能减少 db 压力的就减少 db 压力，尽量把运算逻辑拉到代码里面。存储过程的优点在于封装性好，直接让 db 进行运算，但是缺点在于难以维护，而且大大增大 db 压力。所以开发过程中禁止使用存储过程也是阿里多年经验积累出来的。</p><h1 id="存储过程几个优点"><a href="#存储过程几个优点" class="headerlink" title="存储过程几个优点"></a>存储过程几个优点</h1><p>存储过程消除不必要的网络 IO，所有事务型请求时延控制在 1ms 内，极大地提高了系统性能。<br>存储过程在在数据库和后端应用之间提供了一个额外的接口层，当底层数据库发生模式变更时，可以对上层应用保持透明;提供了巨大的灵活性，并降低了系统复杂性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;存储过程：SQL 语句集合。&lt;/p&gt;
&lt;h1 id=&quot;好处：&quot;&gt;&lt;a href=&quot;#好处：&quot; class=&quot;headerlink&quot; title=&quot;好处：&quot;&gt;&lt;/a&gt;好处：&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;在创建时进行编译，执行不再重新编译；一般 SQL 执行一次编译一次。&lt;/li</summary>
      
    
    
    
    <category term="MySQL" scheme="http://cencuansen.github.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://cencuansen.github.com/tags/MySQL/"/>
    
    <category term="Procedure" scheme="http://cencuansen.github.com/tags/Procedure/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 执行计划</title>
    <link href="http://cencuansen.github.com/database/MySQL-explain"/>
    <id>http://cencuansen.github.com/database/MySQL-explain</id>
    <published>2023-02-16T08:45:55.000Z</published>
    <updated>2023-02-16T11:26:27.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>explain &lt;sql 语句&gt;，模拟 MySQL 优化器执行 SQL，用来分析 SELECT 语句执行效率。</p><h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | extra</span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ul><li><p>id：从大到小顺序执行，相等值的从上到下顺序执行，null 值的最后执行。</p></li><li><p>select_type：</p><ul><li>simple：表示不需要 union 操作或者不包含子查询的简单 select 查询。有连接查询时，外层的查询为 simple，且只有一个。</li><li>primary：一个需要 union 操作或者含有子查询的 select，位于最外层的单位查询的 select_type 即为 primary。且只有一个。</li><li>union：union 连接的两个 select 查询，第一个查询是 dervied 派生表，除了第一个表外，第二个以后的表 select_type 都是 union。</li><li>dependent union：与 union 一样，出现在 union 或 union all 语句中，但是这个查询要受到外部查询的影响。</li><li>union result：包含 union 的结果集，在 union 和 union all 语句中，因为它不需要参与查询，所以 id 字段为 null。</li><li>subquery：除了 from 字句中包含的子查询外，其他地方出现的子查询都可能是 subquery。</li><li>dependent subquery：与 dependent union 类似，表示这个 subquery 的查询要受到外部表查询的影响。</li><li>derived：from 字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套 select。</li></ul></li><li><p>type：null &gt; system &gt; const &gt; eq_ref &gt; ref &gt; ref_or_null &gt; index_merge &gt; range &gt; index &gt; all，一般来说，得保证查询至少达到 range 级别，最好能达到 ref。</p><ul><li>null MySQL 在优化阶段分解查询语句，在执行阶段不再需要访问表或索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="built_in">min</span>(id) <span class="keyword">from</span> <span class="operator">&lt;</span><span class="keyword">table</span> name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><ul><li>system 表中只有一行记录（等于系统表），const 类型的特例。</li><li>const 通过索引一次命中，匹配一行数据，常见于主键索引或唯一索引。比如：where id&#x3D;1</li><li>eq_ref 唯一索引扫描，对于每个索引键，表中只有一条记录匹配，常见于主键索引或唯一索引。</li><li>ref 非唯一索引扫描，返回匹配的所有结果。</li><li>range 检索给定范围的行。</li><li>index 遍历索引树。</li><li>all 全表扫描。</li></ul></li><li><p>extra：using filesort，using index，using temporary，using where</p><ul><li>using filesort，mysql 对结果集合进行外部排序，说明没有通过索引顺序达到排序效果，需要优化。</li><li>using index，覆盖索引，说明索引树中就能找到所需要的数据，避免了回表，性能不错。</li><li>using temporary，使用了临时表，一般出现于排序，分组，多表 join 的情况下，需要优化。</li><li>using where，使用了 where 过滤，性能较高。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h1&gt;&lt;p&gt;explain &amp;lt;sql 语句&amp;gt;，模拟 MySQL 优化器执行 SQL，用来分析 SELECT 语句执行效率。&lt;/p&gt;
&lt;h1 </summary>
      
    
    
    
    <category term="MySQL" scheme="http://cencuansen.github.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://cencuansen.github.com/tags/MySQL/"/>
    
    <category term="Explain" scheme="http://cencuansen.github.com/tags/Explain/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 隔离级别</title>
    <link href="http://cencuansen.github.com/database/MySQL-isolation-level"/>
    <id>http://cencuansen.github.com/database/MySQL-isolation-level</id>
    <published>2023-02-16T08:40:42.000Z</published>
    <updated>2023-02-16T11:26:27.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><p>读未提交、读已提交、可重复读、串行化。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>脏读：A 事务读取到 B 事务正在修改还未提交的数据。</li><li>不可重复读：A 事务查询两次数据结果不一致，是因为 B 事务在 A 第一次查询后对数据做了修改。</li><li>幻读：A 事务条件匹配到若干行，B 事务进行了插入或删除，事务 A 再查询的结果与上次不一致。</li></ol><table><thead><tr><th align="right"></th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="right">读未提交</td><td align="center">存在</td><td align="center">存在</td><td align="center">存在</td></tr><tr><td align="right">读已提交</td><td align="center">无</td><td align="center">存在</td><td align="center">存在</td></tr><tr><td align="right">可重复读</td><td align="center">无</td><td align="center">无</td><td align="center">存在</td></tr><tr><td align="right">串行化</td><td align="center">无</td><td align="center">无</td><td align="center">无</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;隔离级别&quot;&gt;&lt;a href=&quot;#隔离级别&quot; class=&quot;headerlink&quot; title=&quot;隔离级别&quot;&gt;&lt;/a&gt;隔离级别&lt;/h1&gt;&lt;p&gt;读未提交、读已提交、可重复读、串行化。&lt;/p&gt;
&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="MySQL" scheme="http://cencuansen.github.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://cencuansen.github.com/tags/MySQL/"/>
    
    <category term="Isolation Level" scheme="http://cencuansen.github.com/tags/Isolation-Level/"/>
    
  </entry>
  
  <entry>
    <title>MySQL binlog</title>
    <link href="http://cencuansen.github.com/database/MySQL-binlog"/>
    <id>http://cencuansen.github.com/database/MySQL-binlog</id>
    <published>2023-02-16T08:36:09.000Z</published>
    <updated>2023-02-16T11:26:27.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>binlog 是 MySQLSever 层维护的一种二进制日志，与 InnoDB 引擎中的 redo log&#x2F;undo log 是完全不同的日志；<br>其主要是用来记录对 MySQL 数据更新或潜在发生更新的 SQL 语句，并以事件的形式保存在磁盘中；</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol><li>MySQL 主从复制：MySQL Replication 在 Master 端开启 binlog，Master 把它的二进制日志传递给 Slaves 来达到 Master-Slave 数据一致的目的；</li><li>数据恢复：通过使用 mysqlbinlog 工具来使恢复数据；</li></ol><h1 id="配置和查看"><a href="#配置和查看" class="headerlink" title="配置和查看"></a>配置和查看</h1><p>查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看 binlog 文件列表</span></span><br><span class="line"><span class="keyword">show</span> <span class="type">binary</span> logs;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看 binlog 的状态</span></span><br><span class="line"><span class="keyword">show</span> master status;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清空 binlog 日志文件</span></span><br><span class="line">reset master</span><br></pre></td></tr></table></figure><p>my.cnf 配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line"># 开启二进制日志，设置 binlog 文件路径</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"></span><br><span class="line"># 设置server-id</span><br><span class="line">server-id=1</span><br><span class="line"></span><br><span class="line"># 1073741824 Bytes == 1 GB</span><br><span class="line">max_binlog_size=1073741824</span><br></pre></td></tr></table></figure><p>当 binlog 日志写满，或者数据库重启才会产生新文件，也可人为切换生成新文件：flush logs；<br>一个事务不能跨两个文件，因此也可能在 binlog 文件未满的情况下刷新文件；</p><h1 id="日志文件格式"><a href="#日志文件格式" class="headerlink" title="日志文件格式"></a>日志文件格式</h1><p>三种格式：ROW，STATEMENT，MIXED。</p><p>修改格式方式</p><ol><li>修改 my.cnf 配置文件；</li><li>set global binlog_format &#x3D; ‘ROW&#x2F;STATEMENT&#x2F;MIXED’；</li></ol><p>查看 binglog 格式：show variables like ‘binlog_format’;</p><h2 id="ROW"><a href="#ROW" class="headerlink" title="ROW"></a>ROW</h2><p>记录的是行数据变化<code>细节</code>，<code>多</code>。<br>保存记录被修改细节，不记录 sql 语句上下文相关信息。5.1.5 版本的 MySQL 才开始支持。<br>优点： 能非常清晰的记录下每行数据的修改细节，不需要记录上下文相关信息，因此不会发生某些特定情况下的 procedure、function、trigger 的调用触发无法被正确复制的问题，任何情况都可以被复制，且能加快从库重放日志的效率，保证从库数据的一致性；<br>缺点：由于所有的执行的语句在日志中都将以每行记录的修改细节来记录，因此，可能会产生大量的日志内容，干扰内容也较多。比如一条 update 语句，如修改多条记录，则 binlog 中每一条修改都会有记录，这样造成 binlog 日志量会很大，特别是当执行 alter table 之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中，实际等于重建了表。</p><h2 id="STATEMENT"><a href="#STATEMENT" class="headerlink" title="STATEMENT"></a>STATEMENT</h2><p>记录的是会改变数据的 sql 语句，<code>少</code>。<br>修改数据的 sql 都会记录在 binlog 中。<br>优点：不需要记录每一行的变化，减少了 binlog 日志量，节约了 IO，提高了性能。<br>缺点：由于记录的只是执行语句，为了这些语句能在 slave 上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在 slave 得到和在 master 端执行的时候相同的结果。另外 mysql 的复制，像一些特定函数的功能，slave 与 master 要保持一致会有很多相关问题。</p><h2 id="MIXED"><a href="#MIXED" class="headerlink" title="MIXED"></a>MIXED</h2><p>ROW 和 STATEMENT 的结合。</p><h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><p>复制是 MySQL 最重要的功能之一，MySQL 集群的高可用、负载均衡和读写分离都是基于复制来实现，<br>MySQL 5.6 开始，复制有两种实现方式：binlog、GTID（全局事务标示符）。</p><h1 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>binlog 主从、GTID 主从</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;binlog 是 MySQLSever 层维护的一种二进制日志，与 InnoDB 引擎中的 redo log&amp;#x2F;undo log 是</summary>
      
    
    
    
    <category term="MySQL" scheme="http://cencuansen.github.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://cencuansen.github.com/tags/MySQL/"/>
    
    <category term="binlog" scheme="http://cencuansen.github.com/tags/binlog/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 事务</title>
    <link href="http://cencuansen.github.com/database/MySQL-transaction"/>
    <id>http://cencuansen.github.com/database/MySQL-transaction</id>
    <published>2023-02-16T08:34:07.000Z</published>
    <updated>2023-02-16T11:26:27.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><ol><li>原子性：事务中包含的各操作要么都做，要么都不做。数据库通过 undo log 和 redo log 实现原子性：事务提交，redo log 写入到数据库，事务回滚，undo log 恢复到先前状态。</li><li>一致性：从一个一致性状态变到另一个一致性状态。</li><li>隔离性：一个事务的执行不受其它事务干扰。</li><li>持久性：一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。</li></ol><h1 id="redo-log-amp-binlog"><a href="#redo-log-amp-binlog" class="headerlink" title="redo log &amp; binlog"></a>redo log &amp; binlog</h1><p>redo log 属于 innoDB 层面，binlog 属于 MySQL Server 层面；<br>redo log 是物理日志，记录该数据页更新的内容；binlog 是逻辑日志，记录的是更新语句的原始逻辑；<br>redo log 是循环写，日志空间大小固定；binlog 是追加写，写到一定大小会写下一个文件，不覆盖；<br>redo log 作为异常宕机、介质故障后的数据恢复使用；binlog 主从架构恢复数据；</p><h1 id="Innodb-事务过程"><a href="#Innodb-事务过程" class="headerlink" title="Innodb 事务过程"></a>Innodb 事务过程</h1><ol><li>innodb 收到 update 语句后，根据条件去找到数据所在页，将该页缓存到 buffer pool；</li><li>执行 update，修改 buffer pool 中数据，也就是内存中数据；</li><li>生成 undo log，用于事务回滚；</li><li>生成 redo log，存入 log buffer；</li><li>如果事务提交，则将 redo log 持久化，后续会有其他机制将 buffer pool 中修改的数据持久化到磁盘；</li><li>如果事务回滚，利用 undo log 日志进行回滚；</li></ol><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>假设有 X、Y 两个数据，值分别为 1，2：</p><ol><li>事务开始</li><li>记录 X&#x3D;1 到 undo log</li><li>修改 X&#x3D;3</li><li>记录 X&#x3D;3 到 redo log</li><li>记录 Y&#x3D;2 到 undo log</li><li>修改 Y&#x3D;4</li><li>记录 Y&#x3D;4 到 redo log</li><li>将 redo log 写入磁盘</li><li>事务提交</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ACID&quot;&gt;&lt;a href=&quot;#ACID&quot; class=&quot;headerlink&quot; title=&quot;ACID&quot;&gt;&lt;/a&gt;ACID&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;原子性：事务中包含的各操作要么都做，要么都不做。数据库通过 undo log 和 redo log 实现原子性：</summary>
      
    
    
    
    <category term="MySQL" scheme="http://cencuansen.github.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://cencuansen.github.com/tags/MySQL/"/>
    
    <category term="Transaction" scheme="http://cencuansen.github.com/tags/Transaction/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 索引</title>
    <link href="http://cencuansen.github.com/database/MySQL-Index"/>
    <id>http://cencuansen.github.com/database/MySQL-Index</id>
    <published>2023-02-16T08:28:02.000Z</published>
    <updated>2023-02-16T11:26:27.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="B-树-amp-B-树"><a href="#B-树-amp-B-树" class="headerlink" title="B 树 &amp; B+树"></a>B 树 &amp; B+树</h1><p>B 树：平衡的多叉查找树，每个节点都包含数据，在任意节点匹配上就返回数据，找不到就返回空指针。</p><p>B+树：</p><ol><li>关键字全部存储在叶子节点上，且叶子节点本身根据关键字自小而大顺序连接。</li><li>非叶子节点可以看成索引部分，节点中仅含有其子树（根节点）中的最大（或最小）关键字。</li><li>有 n 棵子树的节点含有 n 个关键字（也有认为是 n-1 个关键字）。<br>B+树的查找过程，在非叶子节点上的关键字等于给定值，并不终止，而是继续沿着指针直到叶子节点位置。因此在 B+树，不管查找成功与否，每次查找都是走了一条从根到叶子节点的路径。</li></ol><h1 id="B-树效率"><a href="#B-树效率" class="headerlink" title="B+树效率"></a>B+树效率</h1><p>InnoDB 引擎存储数据的时候以页为单位，一页就是一节点。<br>每个节点的默认大小是 16KB，一个指针的大小是 6 个字节，主键占用 8 个字节，<br>一个节点大概有 (16<em>1024)&#x2F;(6+8)&#x3D;1170 个指针，<br>当表中一条记录 1KB，单个叶子节点可以存储 16 条数据，<br>即树高度为 2 时能关联 1170</em>16&#x3D;18720 条数据，当高度为 3，能关联 1170<em>1170</em>16&#x3D;21902400 条数据。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是有结构的数据，这些数据结构以某种方式引用（指向）数据，MySQL 的索引使用 B+树的数据结构。</p><h1 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h1><p>InnoDB 叶子节点存行数据；MyISAM 叶子节点是数据的地址指针。</p><h1 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h1><p>InnoDB 叶子节点存主键值；MyISAM 叶子节点是数据的地址指针。普通索引查询到叶子节点主键值，用主键去主键索引查数据，这就是回表查询。</p><h1 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h1><p>索引顺序和数据的顺序一致，如果索引相邻，对应数据也相邻存放。InnoDB 主键索引就是聚集索引，聚集索引将数据与索引放一起，索引结构的叶子结点保存了行数据，聚集索引有且仅有一个。</p><ol><li>有主键，主键索引就是聚集索引；</li><li>无主键，第一个唯一索引（UNIQUE）为聚集索引；</li><li>无主键、唯一键，InnoDB 会生成一个隐式主键（rowid）作为聚集索引列。<br>索引查询过程：<br>where id &#x3D; 14：主键索引树中找到对应叶子节点，获得行数据；<br>where Name &#x3D; ‘xx’：</li><li>辅助索引树中检索 Name，到达其叶子节点获取对应的主键。</li><li>再用主键在主键索引树找到对应叶子节点，获得行数据。</li></ol><h1 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h1><p>索引逻辑顺序和磁盘中数据的物理顺序不一致。</p><h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>查数据时，select 的列刚好是复合索引中涉及的字段，这样能直接返回数据，避免回表，extra 中 Using Index 说明使用了覆盖索引。</p><h1 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h1><p>覆盖索引要求查询字段的顺序与复合索引从左到右的顺序一致才行。</p><h1 id="索引条件下推"><a href="#索引条件下推" class="headerlink" title="索引条件下推"></a>索引条件下推</h1><p>当存在索引列条件判断时，将条件判断从 MySQL 服务器向下传递给存储引擎，减少 IO 次数，extra 中 Using index condition 说明使用了索引条件下推。</p><h1 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h1><p>普通索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将 user 表 user_name 列设为索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_name <span class="keyword">on</span> <span class="keyword">user</span>(user_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建email列的索引，索引可以截取length长度，只使用这一列的前几个字符</span></span><br><span class="line"><span class="keyword">create</span> index idx_email <span class="keyword">on</span> <span class="keyword">user</span>(email(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 该表方式创建索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">add</span> index idx_user_name(user_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表时创建索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span> (</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    user_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    gender <span class="type">varchar</span>(<span class="number">1</span>),</span><br><span class="line">    index idx_user_name (name)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">drop</span> index idx_user_name <span class="keyword">on</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>唯一索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index idx_user_name <span class="keyword">on</span> <span class="keyword">user</span>(user_name);</span><br></pre></td></tr></table></figure><p>复合索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_user_composite_index <span class="keyword">on</span> <span class="keyword">user</span>(user_name, email(<span class="number">7</span>));</span><br></pre></td></tr></table></figure><h1 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h1><ol><li>用 or 查询；</li><li>违背最左匹配原则；</li><li>like 以%开头；</li><li>发生类型转换；</li><li>where 中索引列有运算；</li><li>where 中索引列使用了函数；</li><li>如果 mysql 觉得全表扫描更快时（数据少）;</li></ol><h1 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h1><ol><li>如果条件中有 or，只要其中一个条件没有索引，其他字段有索引也不会使用。</li><li>如果条件中的字段都有索引，但是 OR 多个字段都需要全表扫描，因此还是会 走全表扫描 或者 全索引扫描；也就是说如果其他字段不符最左前缀原则，但是都是覆盖索引的值，因此走一次全索引扫描</li></ol><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><ol><li>where c1&#x3D;1 or c2&#x3D;2 改成 where c1&#x3D;1 UNION ALL where c2&#x3D;2</li><li>where id&#x3D;1 or id&#x3D;2 改成 where id in (1,2)</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;B-树-amp-B-树&quot;&gt;&lt;a href=&quot;#B-树-amp-B-树&quot; class=&quot;headerlink&quot; title=&quot;B 树 &amp;amp; B+树&quot;&gt;&lt;/a&gt;B 树 &amp;amp; B+树&lt;/h1&gt;&lt;p&gt;B 树：平衡的多叉查找树，每个节点都包含数据，在任意节点匹配</summary>
      
    
    
    
    <category term="MySQL" scheme="http://cencuansen.github.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://cencuansen.github.com/tags/MySQL/"/>
    
    <category term="Database Index" scheme="http://cencuansen.github.com/tags/Database-Index/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 数据库引擎</title>
    <link href="http://cencuansen.github.com/database/MySQL-database-engine"/>
    <id>http://cencuansen.github.com/database/MySQL-database-engine</id>
    <published>2023-02-16T08:25:21.000Z</published>
    <updated>2023-02-16T11:26:27.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><ul><li>MyISAM</li><li>InnoDB</li><li>Memory</li><li>Archive</li><li>Federated</li></ul><p>查使用的引擎类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;default_storage_engine&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>MySQL 默认使用 innodb。<br>innodb：支持<code>事务</code>，支持<code>外键</code>，<code>聚集索引</code>，锁最小<code>行锁</code>；<br>myisam：不支持事务，不支持外键，非聚集索引，锁最小表锁；<br>myisam 使用的场景：个人博客等文本内容为主的系统；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;MyISAM&lt;/li&gt;
&lt;li&gt;InnoDB&lt;/li&gt;
&lt;li&gt;Memory&lt;/li&gt;
&lt;li&gt;Archive&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="MySQL" scheme="http://cencuansen.github.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://cencuansen.github.com/tags/MySQL/"/>
    
    <category term="Database Engine" scheme="http://cencuansen.github.com/tags/Database-Engine/"/>
    
  </entry>
  
  <entry>
    <title>EntityFramework ADO.NET</title>
    <link href="http://cencuansen.github.com/csharp/EntityFramework-ado-net-basic-concepts"/>
    <id>http://cencuansen.github.com/csharp/EntityFramework-ado-net-basic-concepts</id>
    <published>2023-02-16T08:12:29.000Z</published>
    <updated>2023-02-16T11:26:27.662Z</updated>
    
    <content type="html"><![CDATA[<p>用于进行数据库访问的技术。</p><p>五个对象：</p><ul><li>Connection</li><li>Command</li><li>DataAdapter</li><li>DataSet</li><li>DataReader</li></ul><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Data.SqlClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> connectionString = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增删改</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">update</span>(<span class="params"><span class="built_in">string</span> sql</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> SqlConnection connection = <span class="keyword">new</span> SqlConnection(connectionString);</span><br><span class="line">  connection.Open();</span><br><span class="line">  <span class="keyword">using</span> SqlCommand cmd = <span class="keyword">new</span> SqlCommand(sql, connection);</span><br><span class="line">  <span class="comment">// ExecuteNonQuery 用于执行增删改语句</span></span><br><span class="line">  <span class="built_in">int</span> result = cmd.ExecuteNonQuery();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询单条数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">query</span>(<span class="params"><span class="built_in">string</span> sql</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> SqlConnection connection = <span class="keyword">new</span> SqlConnection(connectionString);</span><br><span class="line">  connection.Open();</span><br><span class="line">  SqlCommand cmd = <span class="keyword">new</span> SqlCommand(sql, connection);</span><br><span class="line">  <span class="comment">// ExecuteScalar 用于查询返回结果中的首行首列数据</span></span><br><span class="line">  <span class="built_in">int</span> result = cmd.ExecuteScalar();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">query</span>(<span class="params"><span class="built_in">string</span> sql</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> SqlConnection connection = <span class="keyword">new</span> SqlConnection(connectionString);</span><br><span class="line">  connection.Open();</span><br><span class="line">  SqlCommand cmd = <span class="keyword">new</span> SqlCommand(sql, connection);</span><br><span class="line">  <span class="comment">// ExecuteReader 读取的数据是行流，会跟数据库保存连接去读取数据，适合数据量小的情况</span></span><br><span class="line">  <span class="keyword">using</span> SqlDataReader dataReader = cmd.ExecuteReader();</span><br><span class="line">  <span class="keyword">while</span> (dataReader.Read())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 一次while循环读一行数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得第0列数据</span></span><br><span class="line">    <span class="keyword">var</span> col0 = dataReader.GetString(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获得第1列数据</span></span><br><span class="line">    <span class="keyword">var</span> col1 = Convert.ToInt32(dataReader[<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">    <span class="comment">// 获得第2列数据</span></span><br><span class="line">    <span class="keyword">var</span> col2 = dataReader.GetString(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataTable <span class="title">query</span>(<span class="params"><span class="built_in">string</span> sql</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> SqlConnection connection = <span class="keyword">new</span> SqlConnection(connectionString);</span><br><span class="line">  SqlDataAdapter adapter = <span class="keyword">new</span> SqlDataAdapter(sql, connection);</span><br><span class="line">  <span class="comment">// DataSet 中含可以有多个 DataTable</span></span><br><span class="line">  <span class="comment">// DataSet dataSet = new DataSet();</span></span><br><span class="line">  DataTable dtable = <span class="keyword">new</span> DataTable();</span><br><span class="line">  adapter.Fill(dtable);</span><br><span class="line">  <span class="keyword">return</span> dtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参数化查询防-SQL-注入"><a href="#参数化查询防-SQL-注入" class="headerlink" title="参数化查询防 SQL 注入"></a>参数化查询防 SQL 注入</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SqlConnection connection = <span class="keyword">new</span> SqlConnection(connectionString);</span><br><span class="line">connection.Open();</span><br><span class="line"><span class="comment">// @符号是必须的</span></span><br><span class="line"><span class="built_in">string</span> querySql = <span class="string">&quot;select * from students where name=@name and age=@age and class=@class;&quot;</span>;</span><br><span class="line">SqlCommand command = <span class="keyword">new</span> SqlCommand(querySql, connection);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单条参数处理</span></span><br><span class="line">SqlParameter sqlParameter1 = <span class="keyword">new</span> ();</span><br><span class="line">sqlParameter.ParameterName = <span class="string">&quot;name&quot;</span>;</span><br><span class="line">sqlParameter.Size = <span class="number">64</span>;</span><br><span class="line">sqlParameter.SqlDbType = SqlDbType.VarChar;</span><br><span class="line">sqlParameter.Value = <span class="string">&quot;李明&quot;</span>;</span><br><span class="line">command.Parameters.Add(sqlParameter1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量参数处理</span></span><br><span class="line">SqlParameter[] parameters =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">new</span> SqlParameter(<span class="string">&quot;age&quot;</span>, SqlDbType.Int),</span><br><span class="line">  <span class="keyword">new</span> SqlParameter(<span class="string">&quot;class&quot;</span>, SqlDbType.VarChar),</span><br><span class="line">&#125;</span><br><span class="line">parameters[<span class="number">0</span>].Value = <span class="number">18</span>;</span><br><span class="line">parameters[<span class="number">1</span>].Value = <span class="string">&quot;精英班&quot;</span>;</span><br><span class="line">command.Parameters.AddRange(parameters);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> result = Convert.ToInt32(command.ExecuteScalar());</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用于进行数据库访问的技术。&lt;/p&gt;
&lt;p&gt;五个对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Connection&lt;/li&gt;
&lt;li&gt;Command&lt;/li&gt;
&lt;li&gt;DataAdapter&lt;/li&gt;
&lt;li&gt;DataSet&lt;/li&gt;
&lt;li&gt;DataReader&lt;/li&gt;
&lt;/ul&gt;
</summary>
      
    
    
    
    <category term="EntityFramework" scheme="http://cencuansen.github.com/categories/EntityFramework/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term="EntityFramework" scheme="http://cencuansen.github.com/tags/EntityFramework/"/>
    
    <category term="ADO.NET" scheme="http://cencuansen.github.com/tags/ADO-NET/"/>
    
  </entry>
  
  <entry>
    <title>EntityFramework 拦截器</title>
    <link href="http://cencuansen.github.com/csharp/EntityFramework-interceptor"/>
    <id>http://cencuansen.github.com/csharp/EntityFramework-interceptor</id>
    <published>2023-02-16T08:03:41.000Z</published>
    <updated>2023-02-16T11:26:27.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>改 SQL，缓存结果，审计日志，自动事务提交等。</p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><ol><li>IDbCommandInterceptor：创建、执行、失败、释放</li><li>IDbConnectionInterceptor：打开和关闭连接、连接失败</li><li>IDbTransactionInterceptor：创建事务、使用事务、提交事务、回滚事务、创建和使用保存点、事务失败</li><li>ISaveChangesInterceptor：提交变更</li></ol><p>基类 DbCommandInterceptor、 DbConnectionInterceptor、DbTransactionInterceptor、SaveChangesInterceptor 包含对应接口中每个方法的无操作实现，以避免实现不需要的方法。</p><h1 id="DbCommandInterceptor"><a href="#DbCommandInterceptor" class="headerlink" title="DbCommandInterceptor"></a>DbCommandInterceptor</h1><p>在 SQL 发送到数据库之前，对 SQL 进行修改，通常结合 EF Core 查询标记来标记每个需要修改的查询。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blogs1 = context.Blogs.TagWith(<span class="string">&quot;Use hint: robust plan&quot;</span>).ToList();</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TaggedQueryCommandInterceptor</span> : <span class="title">DbCommandInterceptor</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">override</span> ValueTask&lt;InterceptionResult&lt;DbDataReader&gt;&gt; ReaderExecutingAsync(DbCommand command, CommandEventData eventData, InterceptionResult&lt;DbDataReader&gt; result, CancellationToken cancellationToken = <span class="literal">default</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ManipulateCommand(command);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ValueTask&lt;InterceptionResult&lt;DbDataReader&gt;&gt;(result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ManipulateCommand</span>(<span class="params">DbCommand command</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (command.CommandText.StartsWith(<span class="string">&quot;-- Use hint: robust plan&quot;</span>, StringComparison.Ordinal))</span><br><span class="line">    &#123;</span><br><span class="line">      command.CommandText += <span class="string">&quot; OPTION (ROBUST PLAN)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Use hint: robust plan</span></span><br><span class="line"><span class="keyword">SELECT</span> [b].[Id], [b].[Name] <span class="keyword">FROM</span> [Blogs] <span class="keyword">AS</span> [b] OPTION (ROBUST PLAN)</span><br></pre></td></tr></table></figure><h1 id="SaveChangesInterceptor"><a href="#SaveChangesInterceptor" class="headerlink" title="SaveChangesInterceptor"></a>SaveChangesInterceptor</h1><ol><li>用于审计</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> ValueTask&lt;InterceptionResult&lt;<span class="built_in">int</span>&gt;&gt; SavingChangesAsync(DbContextEventData eventData, InterceptionResult&lt;<span class="built_in">int</span>&gt; result, CancellationToken cancellationToken = <span class="literal">default</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _audit = CreateAudit(eventData.Context);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">var</span> auditContext = <span class="keyword">new</span> AuditContext(_connectionString);</span><br><span class="line">  auditContext.Add(_audit);</span><br><span class="line">  <span class="keyword">await</span> auditContext.SaveChangesAsync();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> InterceptionResult&lt;<span class="built_in">int</span>&gt; <span class="title">SavingChanges</span>(<span class="params">DbContextEventData eventData, InterceptionResult&lt;<span class="built_in">int</span>&gt; result</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  _audit = CreateAudit(eventData.Context);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">var</span> auditContext = <span class="keyword">new</span> AuditContext(_connectionString);</span><br><span class="line">  auditContext.Add(_audit);</span><br><span class="line">  auditContext.SaveChanges();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时重写同步和异步方法可确保在无论是否调用 SaveChanges 或 SaveChangesAsync 的情况下进行审计。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SaveChangesAudit <span class="title">CreateAudit</span>(<span class="params">DbContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  context.ChangeTracker.DetectChanges();</span><br><span class="line">  <span class="keyword">var</span> audit = <span class="keyword">new</span> SaveChangesAudit &#123; AuditId = Guid.NewGuid(), StartTime = DateTime.UtcNow &#125;;</span><br><span class="line">  <span class="keyword">foreach</span> (<span class="keyword">var</span> entry <span class="keyword">in</span> context.ChangeTracker.Entries())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> auditMessage = entry.State <span class="keyword">switch</span></span><br><span class="line">    &#123;</span><br><span class="line">        EntityState.Deleted =&gt; CreateDeletedMessage(entry),</span><br><span class="line">        EntityState.Modified =&gt; CreateModifiedMessage(entry),</span><br><span class="line">        EntityState.Added =&gt; CreateAddedMessage(entry),</span><br><span class="line">        _ =&gt; <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (auditMessage != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        audit.Entities.Add(<span class="keyword">new</span> EntityAudit &#123; State = entry.State, AuditMessage = auditMessage &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> audit;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">CreateAddedMessage</span>(<span class="params">EntityEntry entry</span>)</span></span><br><span class="line">      =&gt; entry.Properties.Aggregate(</span><br><span class="line">          <span class="string">$&quot;Inserting <span class="subst">&#123;entry.Metadata.DisplayName()&#125;</span> with &quot;</span>,</span><br><span class="line">          (auditString, property) =&gt; auditString + <span class="string">$&quot;<span class="subst">&#123;property.Metadata.Name&#125;</span>: &#x27;<span class="subst">&#123;property.CurrentValue&#125;</span>&#x27; &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">CreateModifiedMessage</span>(<span class="params">EntityEntry entry</span>)</span></span><br><span class="line">      =&gt; entry.Properties.Where(property =&gt; property.IsModified || property.Metadata.IsPrimaryKey()).Aggregate(</span><br><span class="line">          <span class="string">$&quot;Updating <span class="subst">&#123;entry.Metadata.DisplayName()&#125;</span> with &quot;</span>,</span><br><span class="line">          (auditString, property) =&gt; auditString + <span class="string">$&quot;<span class="subst">&#123;property.Metadata.Name&#125;</span>: &#x27;<span class="subst">&#123;property.CurrentValue&#125;</span>&#x27; &quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">CreateDeletedMessage</span>(<span class="params">EntityEntry entry</span>)</span></span><br><span class="line">      =&gt; entry.Properties.Where(property =&gt; property.Metadata.IsPrimaryKey()).Aggregate(</span><br><span class="line">          <span class="string">$&quot;Deleting <span class="subst">&#123;entry.Metadata.DisplayName()&#125;</span> with &quot;</span>,</span><br><span class="line">          (auditString, property) =&gt; auditString + <span class="string">$&quot;<span class="subst">&#123;property.Metadata.Name&#125;</span>: &#x27;<span class="subst">&#123;property.CurrentValue&#125;</span>&#x27; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>自动设置实体值，如 CreatedBy，CreatedDT 等</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MySaveChangesInterceptor</span> : <span class="title">SaveChangesInterceptor</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> IAppUser _appUser;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MySaveChangesInterceptor</span> (<span class="params">IAppUser appUser</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    _appUser = appUser;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">async</span> ValueTask&lt;InterceptionResult&lt;<span class="built_in">int</span>&gt;&gt; SavingChangesAsync(DbContextEventData eventData, InterceptionResult&lt;<span class="built_in">int</span>&gt; result, CancellationToken cancellationToken = <span class="literal">default</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> entry <span class="keyword">in</span> eventData.Context.ChangeTracker.Entries())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> (entry.State)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> EntityState.Added:</span><br><span class="line">          InterceptAddedOperation(entry);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EntityState.Modified:</span><br><span class="line">          InterceptModifiedOperation(entry);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EntityState.Deleted:</span><br><span class="line">          InterceptDeletedOperation(entry);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> 拦截添加操作</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InterceptAddedOperation</span>(<span class="params">EntityEntry entry</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.Entity <span class="keyword">is</span> IAuditedCreationEntity)</span><br><span class="line">    &#123;</span><br><span class="line">      (entry.Entity <span class="keyword">as</span> IAuditedCreationEntity).CreatedBy = _appUser?.UserId ?? <span class="built_in">string</span>.Empty;</span><br><span class="line">      (entry.Entity <span class="keyword">as</span> IAuditedCreationEntity).CreatedDT = DateTime.Now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> 拦截修改操作</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InterceptModifiedOperation</span>(<span class="params">EntityEntry entry</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.Entity <span class="keyword">is</span> IAuditedUpdateEntity)</span><br><span class="line">    &#123;</span><br><span class="line">      (entry.Entity <span class="keyword">as</span> IAuditedUpdateEntity).ModifiedBy = _appUser?.UserId ?? <span class="built_in">string</span>.Empty;</span><br><span class="line">      (entry.Entity <span class="keyword">as</span> IAuditedUpdateEntity).ModifiedDT = DateTime.Now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> 拦截删除操作</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InterceptDeletedOperation</span>(<span class="params">EntityEntry entry</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h1><p>配置 DbContext 实例，在 DbContext.OnConfiguring 中完成注册。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleContext</span> : <span class="title">BlogsContext</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">    =&gt; optionsBuilder.AddInterceptors(<span class="keyword">new</span> TaggedQueryCommandInterceptor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;用途&quot;&gt;&lt;a href=&quot;#用途&quot; class=&quot;headerlink&quot; title=&quot;用途&quot;&gt;&lt;/a&gt;用途&lt;/h1&gt;&lt;p&gt;改 SQL，缓存结果，审计日志，自动事务提交等。&lt;/p&gt;
&lt;h1 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="EntityFramework" scheme="http://cencuansen.github.com/categories/EntityFramework/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term="EntityFramework" scheme="http://cencuansen.github.com/tags/EntityFramework/"/>
    
    <category term="Interceptor" scheme="http://cencuansen.github.com/tags/Interceptor/"/>
    
  </entry>
  
  <entry>
    <title>EntityFramework 原生 SQL</title>
    <link href="http://cencuansen.github.com/csharp/EntityFramework-raw-sql"/>
    <id>http://cencuansen.github.com/csharp/EntityFramework-raw-sql</id>
    <published>2023-02-16T07:55:13.000Z</published>
    <updated>2023-02-16T11:26:27.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FromSql"><a href="#FromSql" class="headerlink" title="FromSql"></a>FromSql</h1><p>FromSql 只能直接在 DbSet 上使用。 不能在任意 LINQ 查询的基础上组合使用它。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blogs = context.Blogs.FromSql(<span class="string">$&quot;SELECT * FROM dbo.Blogs&quot;</span>).ToList();</span><br></pre></td></tr></table></figure><p>FromSql 和 FromSqlInterpolated 方法可以防止 SQL 注入，FromSqlRaw 方法可能易受 SQL 注入攻击。</p><h2 id="动态-SQL-和参数"><a href="#动态-SQL-和参数" class="headerlink" title="动态 SQL 和参数"></a>动态 SQL 和参数</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="string">&quot;johndoe&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> sqlString = <span class="string">$&quot;SELECT * FROM dbo.Blogs WHERE Name = <span class="subst">&#123;user&#125;</span>&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> blogs = context.Blogs.FromSql(sqlString).ToList();</span><br></pre></td></tr></table></figure><h1 id="SqlQuery"><a href="#SqlQuery" class="headerlink" title="SqlQuery"></a>SqlQuery</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ids = context.Database.SqlQuery&lt;<span class="built_in">int</span>&gt;(<span class="string">$&quot;SELECT [BlogId] FROM [Blogs]&quot;</span>).ToList();</span><br></pre></td></tr></table></figure><h1 id="Non-Query-SQL"><a href="#Non-Query-SQL" class="headerlink" title="Non-Query SQL"></a>Non-Query SQL</h1><p>非查询 SQL 通常指用于修改数据库中的数据或调用不返回任何结果集的存储过程。</p><h2 id="ExecuteSql"><a href="#ExecuteSql" class="headerlink" title="ExecuteSql"></a>ExecuteSql</h2><p>EF Core 7.0 之前批量变更，比在查询所有匹配行后使用 SaveChanges 来修改它们要高效得多。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rowsModified = context.Database.ExecuteSql(<span class="string">$&quot;UPDATE [Blogs] SET [Url] = NULL&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="ExecuteDeleteAsync"><a href="#ExecuteDeleteAsync" class="headerlink" title="ExecuteDeleteAsync"></a>ExecuteDeleteAsync</h2><p>EF Core 7.0 新特性，借助 LINQ 更方便高效。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> context.Tags.Where(t =&gt; t.Text.Contains(<span class="string">&quot;.NET&quot;</span>)).ExecuteDeleteAsync();</span><br></pre></td></tr></table></figure><h2 id="ExecuteUpdateAsync"><a href="#ExecuteUpdateAsync" class="headerlink" title="ExecuteUpdateAsync"></a>ExecuteUpdateAsync</h2><p>EF Core 7.0 新特性，借助 LINQ 更方便高效。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> context.Blogs.ExecuteUpdateAsync(s =&gt;</span><br><span class="line">    s.SetProperty(b =&gt; b.Name, b =&gt; <span class="string">$&quot;<span class="subst">&#123;b.Name&#125;</span>_new&quot;</span>))</span><br><span class="line">    s.SetProperty(b =&gt; b.Author, b =&gt; <span class="string">$&quot;<span class="subst">&#123;b.Author&#125;</span>_new&quot;</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FromSql&quot;&gt;&lt;a href=&quot;#FromSql&quot; class=&quot;headerlink&quot; title=&quot;FromSql&quot;&gt;&lt;/a&gt;FromSql&lt;/h1&gt;&lt;p&gt;FromSql 只能直接在 DbSet 上使用。 不能在任意 LINQ 查询的基础上组合使用它。&lt;/</summary>
      
    
    
    
    <category term="EntityFramework" scheme="http://cencuansen.github.com/categories/EntityFramework/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term="EntityFramework" scheme="http://cencuansen.github.com/tags/EntityFramework/"/>
    
    <category term="SQL" scheme="http://cencuansen.github.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>EntityFramework 流式配置接口</title>
    <link href="http://cencuansen.github.com/csharp/EntityFramework-fluent-api"/>
    <id>http://cencuansen.github.com/csharp/EntityFramework-fluent-api</id>
    <published>2023-02-16T07:51:25.000Z</published>
    <updated>2023-02-16T11:26:27.663Z</updated>
    
    <content type="html"><![CDATA[<p>fluent api 使得 ef 能<code>链式</code>配置。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SchoolDBContext</span>: <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Student</span>&gt; Students</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Course</span>&gt; Courses</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">StudentCourse</span>&gt; StudentCourses</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">StudentAddress</span>&gt; StudentAddress</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder builder</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder builder</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 字段</span></span><br><span class="line">    builder.Entity&lt;Student&gt;().Property(s =&gt; s.Id).HasColumnName(<span class="string">&quot;Id&quot;</span>).HasDefaultValue(<span class="number">0</span>).IsRequired();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引</span></span><br><span class="line">    builder.Entity&lt;Student&gt;().HasIndex(x =&gt; x.Name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始数据（data-seeding）</span></span><br><span class="line">    builder.Entity&lt;Student&gt;().HasData(<span class="keyword">new</span> Student</span><br><span class="line">    &#123;</span><br><span class="line">      Id = <span class="string">&quot;0&quot;</span>,</span><br><span class="line">        Name = <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Student n : 1 Grade</span></span><br><span class="line">    builder.Entity&lt;Student&gt;().HasOne&lt;Grade&gt;(s =&gt; s.Grade).WithMany(g =&gt; g.Students).HasForeignKey(s =&gt; s.GradeId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Student 1 : 1 StudentAddress</span></span><br><span class="line">    builder.Entity&lt;Student&gt;().HasOne&lt;StudentAddress&gt;(s =&gt; s.Address).WithOne(ad =&gt; ad.Student).HasForeignKey&lt;StudentAddress&gt;(ad =&gt; ad.StudentId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n : n</span></span><br><span class="line">    <span class="comment">// Student 1 : n StudentCourse</span></span><br><span class="line">    builder.Entity&lt;StudentCourse&gt;().HasOne&lt;Student&gt;(sc =&gt; sc.Student).WithMany(s =&gt; s.StudentCourses).HasForeignKey(sc =&gt; sc.StudentId);</span><br><span class="line">    <span class="comment">// Course 1 : n StudentCourse</span></span><br><span class="line">    builder.Entity&lt;StudentCourse&gt;().HasOne&lt;Course&gt;(sc =&gt; sc.Course).WithMany(s =&gt; s.StudentCourses).HasForeignKey(sc =&gt; sc.CourseId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;fluent api 使得 ef 能&lt;code&gt;链式&lt;/code&gt;配置。&lt;/p&gt;
&lt;figure class=&quot;highlight c#&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    <category term="EntityFramework" scheme="http://cencuansen.github.com/categories/EntityFramework/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term="EntityFramework" scheme="http://cencuansen.github.com/tags/EntityFramework/"/>
    
    <category term="Fluent API" scheme="http://cencuansen.github.com/tags/Fluent-API/"/>
    
  </entry>
  
  <entry>
    <title>EntityFramework 复杂查询</title>
    <link href="http://cencuansen.github.com/csharp/EntityFramework-complex-query"/>
    <id>http://cencuansen.github.com/csharp/EntityFramework-complex-query</id>
    <published>2023-02-16T07:48:44.000Z</published>
    <updated>2023-02-16T11:26:27.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LINQ-Join"><a href="#LINQ-Join" class="headerlink" title="LINQ Join"></a>LINQ Join</h1><p>LINQ Join 对应关系数据库中的 INNER JOIN。</p><h1 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> c <span class="keyword">in</span> table0</span><br><span class="line"><span class="keyword">join</span> o <span class="keyword">in</span> table1 <span class="keyword">on</span> c.sno <span class="keyword">equals</span> o.sno <span class="keyword">into</span> ps</span><br><span class="line"><span class="keyword">from</span> o <span class="keyword">in</span> ps.DefaultIfEmpty()</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">new</span> &#123; c.name, o.number&#125;</span><br></pre></td></tr></table></figure><p>生成的 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [t0].[name], [t1].[number] <span class="keyword">AS</span> [number] <span class="keyword">FROM</span> [table0] <span class="keyword">AS</span> [t0]</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> [table1] <span class="keyword">AS</span> [t1]</span><br><span class="line"><span class="keyword">ON</span> ([t0].[sno]) <span class="operator">=</span> [t1].[sno]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LINQ-Join&quot;&gt;&lt;a href=&quot;#LINQ-Join&quot; class=&quot;headerlink&quot; title=&quot;LINQ Join&quot;&gt;&lt;/a&gt;LINQ Join&lt;/h1&gt;&lt;p&gt;LINQ Join 对应关系数据库中的 INNER JOIN。&lt;/p&gt;
&lt;h1 id</summary>
      
    
    
    
    <category term="EntityFramework" scheme="http://cencuansen.github.com/categories/EntityFramework/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term="EntityFramework" scheme="http://cencuansen.github.com/tags/EntityFramework/"/>
    
  </entry>
  
  <entry>
    <title>EntityFramework 实体状态</title>
    <link href="http://cencuansen.github.com/csharp/EntityFramework-entity-state"/>
    <id>http://cencuansen.github.com/csharp/EntityFramework-entity-state</id>
    <published>2023-02-16T07:47:30.000Z</published>
    <updated>2023-02-16T11:26:27.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EntityState"><a href="#EntityState" class="headerlink" title="EntityState"></a>EntityState</h1><ol><li>Added，在上下文中，而且对象是需要添加的状态</li><li>Deleted，在上下文中，而且对象是需要删除的状态</li><li>Modified，在上下文中，而且对象是需要修改的状态</li><li>UnChanged，在上下文中，对象没有任何状态</li><li>Detached，没有在上下文中，和 ef 上下文没有关联的状态</li></ol><p>new 的新对象属于 Detached 状态；<br>查询出来的对象属于 UnChanged 状态；<br>new 的新对象调用 Attach 方法后对象属于 Unchanged 状态；<br>调用 Add 方法后对象属于 Added 状态；<br>Remove 方法将状态修改为 Deleted；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;EntityState&quot;&gt;&lt;a href=&quot;#EntityState&quot; class=&quot;headerlink&quot; title=&quot;EntityState&quot;&gt;&lt;/a&gt;EntityState&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Added，在上下文中，而且对象是需要添加的状态&lt;/li</summary>
      
    
    
    
    <category term="EntityFramework" scheme="http://cencuansen.github.com/categories/EntityFramework/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term="EntityFramework" scheme="http://cencuansen.github.com/tags/EntityFramework/"/>
    
  </entry>
  
  <entry>
    <title>NETCore .NET中的设计模式</title>
    <link href="http://cencuansen.github.com/csharp/NETCore-design-patten-in-NET"/>
    <id>http://cencuansen.github.com/csharp/NETCore-design-patten-in-NET</id>
    <published>2023-02-16T07:31:11.000Z</published>
    <updated>2023-02-16T11:26:27.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><p><code>中间件</code>的设计就是责任链模式的应用和变形。每个中间件根据需要处理请求，并且可以根据请求信息自己决定是否传递给下一个中间件。</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>依赖注入的本质就是将对象的创建交给 <code>IOC 容器</code> 来处理，所以其实 IOC 容器本质就是一个工厂，从 IOC 中获取服务实例的过程就是工厂创建对象的过程，只是会根据服务的生命周期来决定是创建新对象还是返回已有对象。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ul><li>Cache</li><li>DbContext</li><li>HttpClient</li><li>LoggerFactory</li><li>Configuration</li></ul><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p><code>字符串池</code>(string intern)</p><h1 id="观察者模式-x2F-发布订阅模式"><a href="#观察者模式-x2F-发布订阅模式" class="headerlink" title="观察者模式&#x2F;发布订阅模式"></a>观察者模式&#x2F;发布订阅模式</h1><p>使用<code>事件</code>(event)进行解耦，外部代码通过订阅事件来解耦，实现对内部状态的观察。</p><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>ServiceProviderFactory, 使得 .NET Core 可以更方便的集成第三方的依赖注入框架，这里使用了适配器模式。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="观察者模式-amp-发布订阅模式"><a href="#观察者模式-amp-发布订阅模式" class="headerlink" title="观察者模式 &amp; 发布订阅模式"></a>观察者模式 &amp; 发布订阅模式</h2><p>虽然这两种模式在很多情况下非常相似，但是它们还是有一些区别。<br>观察者模式通常用于更加简单的情况，而发布-订阅模式则更加通用，并且可以通过中间件来实现进程间<code>通信</code>。<br>在发布-订阅模式中，发布者和订阅者之间可以有多个中间件，可以将其视为事件的处理<code>管道</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;责任链模式&quot;&gt;&lt;a href=&quot;#责任链模式&quot; class=&quot;headerlink&quot; title=&quot;责任链模式&quot;&gt;&lt;/a&gt;责任链模式&lt;/h1&gt;&lt;p&gt;&lt;code&gt;中间件&lt;/code&gt;的设计就是责任链模式的应用和变形。每个中间件根据需要处理请求，并且可以根据请求信息自</summary>
      
    
    
    
    <category term="NETCore" scheme="http://cencuansen.github.com/categories/NETCore/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term="NETCore" scheme="http://cencuansen.github.com/tags/NETCore/"/>
    
    <category term="Design Patten" scheme="http://cencuansen.github.com/tags/Design-Patten/"/>
    
  </entry>
  
  <entry>
    <title>NETCore 身份验证和授权</title>
    <link href="http://cencuansen.github.com/csharp/NETCore-oauth-and-oidc"/>
    <id>http://cencuansen.github.com/csharp/NETCore-oauth-and-oidc</id>
    <published>2023-02-16T07:26:45.000Z</published>
    <updated>2023-02-16T11:26:27.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>OAuth 是授权协议（Authorization），不支持身份认证。<br>OpenID Connect（OIDC）是基于 OAuth 的简单身份认证协议。</p><h1 id="OAuth-2-0-授权方式"><a href="#OAuth-2-0-授权方式" class="headerlink" title="OAuth 2.0 授权方式"></a>OAuth 2.0 授权方式</h1><ol><li>授权码</li><li>隐式</li><li>密码</li><li>客户端凭证</li></ol><h1 id="授权码"><a href="#授权码" class="headerlink" title="授权码"></a>授权码</h1><p>功能最完整、流程最严密，适合通用前后端服务，由客户端的后台服务向授权服务请求 token。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户正在访问网站 A ，A 支持用 QQ 登录。</span><br><span class="line">A 网站跳转 QQ 授权页（https://qq.com/oauth/authorize?response_type=code&amp;client_id=CLIENT_ID&amp;redirect_uri=http://a.com/callback&amp;scope=read）。</span><br><span class="line">QQ 提供登录页，用户用 QQ 登录，然后 QQ 跳转 A 网站（http://a.com/callback），并携带授权码（code）。</span><br><span class="line">A 网站使用授权码，向 QQ 请求 Token（https://qq.com/oauth/token?client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;grant_type=authorization_code&amp;code=AUTHORIZATION_CODE&amp;redirect_uri=http://a.com/callback）。</span><br><span class="line">QQ 收到请求，跳转 A 网站（http://a.com/callback），并携带 Token。</span><br></pre></td></tr></table></figure><h1 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h1><p>用户必须高度信任该网站。用户向客户端提供账号密码，客户端向授权服务请求 token。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用户在 A 网站直接用 B 网站的账号密码进行登录。</span><br><span class="line">A 网站带上用户提供的 B 网站的账号密码向 B 网站发起登录请求（https://oauth.b.com/token?grant_type=password&amp;username=USERNAME&amp;password=PASSWORD&amp;client_id=CLIENT_ID）。</span><br><span class="line">在 B 网站验证账号密码成功后直接返回 Token，相当于直接响应。</span><br></pre></td></tr></table></figure><h1 id="凭证式"><a href="#凭证式" class="headerlink" title="凭证式"></a>凭证式</h1><p>客户端以自己的名义（不是以用户的名义），用 clientid 和 clientsecret 向授权服务请求 token。这会涉及客户端身份验证（clientid）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A 服务使用 clientid 和 clientsecret 向授权服务申请 Token（https://oauth.b.com/token?grant_type=client_credentials&amp;client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET）。</span><br><span class="line">授权服务验证通过以后，直接返回 Token。</span><br></pre></td></tr></table></figure><h1 id="隐式"><a href="#隐式" class="headerlink" title="隐式"></a>隐式</h1><p>无后端的服务，如 swagger 服务。客户端用 clientid 直接向授权服务器请求 token，不涉及客户端身份验证。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swagger 访问授权服务（https://id4.com/oauth/authorize?response_type=token&amp;client_id=CLIENT_ID&amp;redirect_uri=CALLBACK_URL&amp;scope=read）。</span><br><span class="line">授权服务访问 CALLBACK_URL 并携带 token（CALLBACK_URL#TOKEN）。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;OAuth 是授权协议（Authorization），不支持身份认证。&lt;br&gt;OpenID Connect（OIDC）是基于 OAuth 的</summary>
      
    
    
    
    <category term="NETCore" scheme="http://cencuansen.github.com/categories/NETCore/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term="NETCore" scheme="http://cencuansen.github.com/tags/NETCore/"/>
    
    <category term="OAuth" scheme="http://cencuansen.github.com/tags/OAuth/"/>
    
    <category term="OIDC" scheme="http://cencuansen.github.com/tags/OIDC/"/>
    
  </entry>
  
  <entry>
    <title>NETCore IOC</title>
    <link href="http://cencuansen.github.com/csharp/NETCore-IOC"/>
    <id>http://cencuansen.github.com/csharp/NETCore-IOC</id>
    <published>2023-02-16T07:24:52.000Z</published>
    <updated>2023-02-16T11:26:27.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>Singleton：实例化一次，然后在整个应用程序中重复使用；<br>Scoped：单个请求中会实例化一次实例，请求中可以重复使用；<br>Transient：每次使用时都会创建新实例；</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>缓存服务、Option 等配置服务注册成 Singleton；<br>一般服务（Service）注册成 Scoped；</p><h1 id="常见-IOC-容器"><a href="#常见-IOC-容器" class="headerlink" title="常见 IOC 容器"></a>常见 IOC 容器</h1><p>ServiceCollection、Autofac、Unity</p><h1 id="批量注册服务"><a href="#批量注册服务" class="headerlink" title="批量注册服务"></a>批量注册服务</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 根据前缀后缀注册服务</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;services&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;assembly&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;postfix&quot;&gt;</span>后缀<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;prefix&quot;&gt;</span>前缀<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IServiceCollection <span class="title">AddBusinessServices</span>(<span class="params"><span class="keyword">this</span> IServiceCollection services, Assembly assembly, <span class="built_in">string</span> postfix, <span class="built_in">string</span> prefix = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> types = assembly?.GetTypes().Where(type =&gt; type.IsClass &amp;&amp; !type.IsAbstract).ToList();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrWhiteSpace(postfix))</span><br><span class="line">    &#123;</span><br><span class="line">        types = types?.Where(type =&gt; type.Name.EndsWith(postfix, StringComparison.OrdinalIgnoreCase)).ToList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrWhiteSpace(prefix))</span><br><span class="line">    &#123;</span><br><span class="line">        types = types?.Where(type =&gt; type.Name.StartsWith(prefix, StringComparison.OrdinalIgnoreCase)).ToList();</span><br><span class="line">    &#125;</span><br><span class="line">    types?.ForEach(type =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> it <span class="keyword">in</span> type.GetInterfaces())</span><br><span class="line">        &#123;</span><br><span class="line">            services.AddScoped(it, type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>Singleton 中如何访问 Scoped？<br>通过 IServiceProvider.GetRequireService()。</li><li>GetService 和 GetRequiredService 区别？<br>a. GetService 如果服务未注册，则返回 null；<br>b. GetRequiredService 如果服务未注册，则抛出一个 Exception 异常；</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生命周期&quot;&gt;&lt;a href=&quot;#生命周期&quot; class=&quot;headerlink&quot; title=&quot;生命周期&quot;&gt;&lt;/a&gt;生命周期&lt;/h1&gt;&lt;p&gt;Singleton：实例化一次，然后在整个应用程序中重复使用；&lt;br&gt;Scoped：单个请求中会实例化一次实例，请求中可以重</summary>
      
    
    
    
    <category term="NETCore" scheme="http://cencuansen.github.com/categories/NETCore/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term="NETCore" scheme="http://cencuansen.github.com/tags/NETCore/"/>
    
    <category term="IOC" scheme="http://cencuansen.github.com/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>NETCore 请求管道</title>
    <link href="http://cencuansen.github.com/csharp/NETCore-request-pipeline"/>
    <id>http://cencuansen.github.com/csharp/NETCore-request-pipeline</id>
    <published>2023-02-16T07:12:47.000Z</published>
    <updated>2023-02-16T11:26:27.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><h2 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h2><p>app.Use：use 中间件可以由 next。<br>app.Run：不能调用 next，用于断路或者管道末尾。<br>app.Map：map request，可用于匹配条件走对应的逻辑，搭配 Use。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="app-Use"><a href="#app-Use" class="headerlink" title="app.Use"></a>app.Use</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.Use(<span class="keyword">async</span> (context, next) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> next.Invoke();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="app-Run"><a href="#app-Run" class="headerlink" title="app.Run"></a>app.Run</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.Run(<span class="keyword">async</span> context =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;hello world3&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="app-Map"><a href="#app-Map" class="headerlink" title="app.Map"></a>app.Map</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.Map(<span class="keyword">new</span> PathString(<span class="string">&quot;/test&quot;</span>), application =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  application.Use(<span class="keyword">async</span> (context, next) =&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="常见中间件"><a href="#常见中间件" class="headerlink" title="常见中间件"></a>常见中间件</h2><p>UsingRouting、UsingEndpoint、UseAuthentication、UseAuthorization。</p><h3 id="UseRouting"><a href="#UseRouting" class="headerlink" title="UseRouting"></a>UseRouting</h3><p>注册路由，根据请求匹配路由；UseEndpoints 执行路由委托；<br>在 UseRouting 和 UseEndpoint 管道之间注册其自定义中间件，以实现业务逻辑；UseAuthorization 应该注册在 UseRouting 之后，UseEndpoint 之前。实现对 UseRouting 匹配到的路由进行拦截，做授权验证操作等，验证通过则执行下一个中间件。</p><h3 id="UseEndpoints"><a href="#UseEndpoints" class="headerlink" title="UseEndpoints"></a>UseEndpoints</h3><p>对于传统路由（控制器和视图）需要用 endpoints.MapControllerRoute，restful 属性路由（用属性修饰控制器和方法）需要用 endpoints.MapController。</p><h3 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h3><p>认证，表明用户身份的信息，你是谁；Authorization 授权，表明你有系统什么权限，管理员权限或普通用户权限等。例如：你要登机，你需要出示你的身份证和机票，身份证是为了证明你张三确实是你张三，这就是 authentication；而机票是为了证明你张三确实买了票可以上飞机，这就是 authorization。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 路由匹配，用来匹配Controller中Action</span></span><br><span class="line">    app.UseRouting();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 其他处理，如鉴权、授权等</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对UseRouting匹配到的路由进行委托方法的执行</span></span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 配置默认首页是HomeController下的Index方法</span></span><br><span class="line">        endpoints.MapControllerRoute(name: <span class="string">&quot;default&quot;</span>, pattern: <span class="string">&quot;&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>过滤器(Filters)只能应用到 Action 或 Controller 方法上。</p><h2 id="常用过滤器"><a href="#常用过滤器" class="headerlink" title="常用过滤器"></a>常用过滤器</h2><ul><li>Authorization filters</li><li>Resource filters</li><li>Action filters</li><li>Exception filters</li><li>Result filters</li></ul><p><img src="/images/filter-pipeline-2.png" alt="过滤器示意图"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>[TypeFilter(typeof(xxxxxx))]</li><li>[ServiceFilter(typeof(xxxxxx))]</li></ul><p>TypeFilter 不需要注册到服务容器就能直接使用；<br>ServiceFilter 需要注册到服务容器中才能使用，如：service.AddTransient<xxxFilterAttrbute>();</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中间件&quot;&gt;&lt;a href=&quot;#中间件&quot; class=&quot;headerlink&quot; title=&quot;中间件&quot;&gt;&lt;/a&gt;中间件&lt;/h1&gt;&lt;h2 id=&quot;形式&quot;&gt;&lt;a href=&quot;#形式&quot; class=&quot;headerlink&quot; title=&quot;形式&quot;&gt;&lt;/a&gt;形式&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="NETCore" scheme="http://cencuansen.github.com/categories/NETCore/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term="NETCore" scheme="http://cencuansen.github.com/tags/NETCore/"/>
    
    <category term="Pipeline" scheme="http://cencuansen.github.com/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>NETCore 程序启动流程</title>
    <link href="http://cencuansen.github.com/csharp/NETCore-app-start-flow"/>
    <id>http://cencuansen.github.com/csharp/NETCore-app-start-flow</id>
    <published>2023-02-16T07:07:14.000Z</published>
    <updated>2023-02-16T11:26:27.664Z</updated>
    
    <content type="html"><![CDATA[<p>Program.main</p><ol><li>创建主机(Host.CreateDefaultBuilder(args))；</li><li>配置主机(ConfigureWebHostDefaults())：<ul><li>使用 kestrel 主机</li><li>读取配置文件</li><li>配置 log 组件</li><li>注册默认 IOC 容器</li><li>使用 Startup</li></ul></li><li>Startup.ConfigureServices 对程序中涉及的相关服务进行注册；</li><li>Startup.Configure 配置请求管道。</li></ol><p>启动执行顺序</p><ol><li>ConfigureWebHostDefaults 注册组件，比如 Configuration 组件、IOC 容器组件等</li><li>ConfigureHostConfiguration 设置生成器自身的配置，比如配置监听的端口、URL 地址</li><li>ConfigureAppConfiguration 为应用程序设置其他配置，比如设置自定义配置文件</li><li>ConfigureServices、ConfigureLogging、Startup.ConfigureServices 服务注册</li><li>Startup.Configure 配置请求中间件</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Program.main&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建主机(Host.CreateDefaultBuilder(args))；&lt;/li&gt;
&lt;li&gt;配置主机(ConfigureWebHostDefaults())：&lt;ul&gt;
&lt;li&gt;使用 kestrel 主机&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="NETCore" scheme="http://cencuansen.github.com/categories/NETCore/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term="NETCore" scheme="http://cencuansen.github.com/tags/NETCore/"/>
    
  </entry>
  
</feed>
