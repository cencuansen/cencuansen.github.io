<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cencuansen&#39;s blogs</title>
  
  
  <link href="https://chengshen.me/atom.xml" rel="self"/>
  
  <link href="https://chengshen.me/"/>
  <updated>2023-03-04T15:49:31.631Z</updated>
  <id>https://chengshen.me/</id>
  
  <author>
    <name>cencuansen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 更多常用指令</title>
    <link href="https://chengshen.me/linux/Linux-more-commands"/>
    <id>https://chengshen.me/linux/Linux-more-commands</id>
    <published>2023-03-04T15:44:18.000Z</published>
    <updated>2023-03-04T15:49:31.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件操作类指令"><a href="#文件操作类指令" class="headerlink" title="文件操作类指令"></a>文件操作类指令</h1><p>ls：列出目录内容<br>cd：切换目录<br>cp：复制文件或目录<br>mv：移动或重命名文件或目录<br>rm：删除文件或目录<br>mkdir：创建新目录<br>rmdir：删除空目录</p><h1 id="文件内容查看和编辑类指令"><a href="#文件内容查看和编辑类指令" class="headerlink" title="文件内容查看和编辑类指令"></a>文件内容查看和编辑类指令</h1><p>cat：查看文件内容<br>more：逐页查看文件内容<br>less：也是逐页查看文件内容，但比 more 更加强大<br>head：查看文件头部内容<br>tail：查看文件尾部内容<br>nano：文本编辑器</p><h1 id="系统信息类指令"><a href="#系统信息类指令" class="headerlink" title="系统信息类指令"></a>系统信息类指令</h1><p>uname：显示系统信息<br>top：实时查看系统进程信息<br>free：查看内存使用情况<br>df：查看磁盘空间使用情况<br>ps：查看进程状态信息<br>netstat：查看网络状态信息</p><h1 id="网络连接类指令"><a href="#网络连接类指令" class="headerlink" title="网络连接类指令"></a>网络连接类指令</h1><p>ping：测试网络连接是否通畅<br>curl：用于访问 URL 并获取相关内容<br>wget：下载文件或页面<br>ssh：远程登录 Linux 系统<br>scp：远程复制文件或目录</p><h1 id="权限管理类指令"><a href="#权限管理类指令" class="headerlink" title="权限管理类指令"></a>权限管理类指令</h1><p>chown：改变文件或目录的拥有者<br>chgrp：改变文件或目录所属的组<br>chmod：改变文件或目录的权限</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>nohup [command] &amp;：在后台运行命令</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件操作类指令&quot;&gt;&lt;a href=&quot;#文件操作类指令&quot; class=&quot;headerlink&quot; title=&quot;文件操作类指令&quot;&gt;&lt;/a&gt;文件操作类指令&lt;/h1&gt;&lt;p&gt;ls：列出目录内容&lt;br&gt;cd：切换目录&lt;br&gt;cp：复制文件或目录&lt;br&gt;mv：移动或重命名文件或</summary>
      
    
    
    
    <category term="Linux" scheme="https://chengshen.me/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://chengshen.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 空设备文件</title>
    <link href="https://chengshen.me/linux/Linux-null-device-file"/>
    <id>https://chengshen.me/linux/Linux-null-device-file</id>
    <published>2023-03-04T15:14:52.000Z</published>
    <updated>2023-03-04T15:33:14.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>空设备文件：<code>/dev/null</code>，是个特殊的文件，可读写不可执行，通常结合重定向符号使用。<br>可以通过把命令的输出重定向到 &#x2F;dev&#x2F;null 来丢弃脚本的全部输出。<br>每个进程默认都会打开三个文件描述符，分别是 0、1 和 2，对应的是标准输入、标准输出和标准错误输出。</p><p>丢弃标准输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, it&#x27;s me&quot;</span> &gt; /dev/null</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, it&#x27;s me&quot;</span> 1&gt; /dev/null</span><br></pre></td></tr></table></figure><p>丢弃标准错误输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jiamingling 2&gt; /dev/null</span><br></pre></td></tr></table></figure><p>同时丢弃标准输出和标准错误输出<br>1&gt; 将标准输出重定向到空设备文件，2&gt; 将标准错误输出重定向到 1，因为标准输出已经被重定向到空设备文件，标准错误输出也输出到空设备文件，即丢弃标准输出和标准错误输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>清空文件内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/null &gt; 1.txt</span><br></pre></td></tr></table></figure><h1 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h1><p>区分标准输出(stdout)和 标准错误输出(stderr)的意义是：在执行 Linux 命令得到的输出信息中，既有正常内容，也有错误内容，就可以根据需要选择性丢弃输出信息。<br>如果只关心正常内容，就丢弃错误信息：2&gt; &#x2F;dev&#x2F;null，如果只关心报错内容，就丢弃普通信息：&gt; &#x2F;dev&#x2F;null</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;空设备文件：&lt;code&gt;/dev/null&lt;/code&gt;，是个特殊的文件，可读写不可执行，通常结合重定向符号使用。&lt;br&gt;可以通过把命令的输</summary>
      
    
    
    
    <category term="Linux" scheme="https://chengshen.me/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://chengshen.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 命令集合</title>
    <link href="https://chengshen.me/linux/Linux-commands"/>
    <id>https://chengshen.me/linux/Linux-commands</id>
    <published>2023-03-04T14:46:17.000Z</published>
    <updated>2023-03-04T15:12:58.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="grep-文本搜索"><a href="#grep-文本搜索" class="headerlink" title="grep 文本搜索"></a>grep 文本搜索</h1><p>grep：global search regular expression and print out the line，用于全面搜索的正则表达式并将结果输出。<br>grep：标准搜索命令；<br>egrep：扩展搜索命令，等价于“grep -E”命令，支持扩展的正则表达式；<br>fgrep：快速搜索命令，等价于“grep -F”命令，不支持正则表达式，直接按照字符串内容进行匹配；</p><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><p>grep [参数] 文件</p><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-i</td><td>忽略大小写</td></tr><tr><td>-c</td><td>只输出匹配行的数量</td></tr><tr><td>-l</td><td>只列出符合匹配的文件名，不列出具体的匹配行</td></tr><tr><td>-n</td><td>列出所有的匹配行，显示行号</td></tr><tr><td>-h</td><td>查询多文件时不显示文件名</td></tr><tr><td>-s</td><td>不显示不存在、没有匹配文本的错误信息</td></tr><tr><td>-v</td><td>显示不包含匹配文本的所有行</td></tr><tr><td>-w</td><td>匹配整词</td></tr><tr><td>-x</td><td>匹配整行</td></tr><tr><td>-r</td><td>递归搜索</td></tr><tr><td>-q</td><td>禁止输出任何结果，已退出状态表示搜索是否成功</td></tr><tr><td>-b</td><td>打印匹配行距文件头部的偏移量，以字节为单位</td></tr><tr><td>-o</td><td>与-b 结合使用，打印匹配的词据文件头部的偏移量，以字节为单位</td></tr><tr><td>-F</td><td>匹配固定字符串的内容</td></tr><tr><td>-E</td><td>支持扩展的正则表达式</td></tr></tbody></table><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><p>passwd 文件中搜以 root 开头的文本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep ^root /etc/passwd</span><br></pre></td></tr></table></figure><h2 id="更多案例"><a href="#更多案例" class="headerlink" title="更多案例"></a>更多案例</h2><p><a href="https://www.linuxcool.com/grep">https://www.linuxcool.com/grep</a></p><h1 id="find-文件搜索"><a href="#find-文件搜索" class="headerlink" title="find 文件搜索"></a>find 文件搜索</h1><p>通常进行的是从根目录（&#x2F;）开始的全盘搜索。</p><h2 id="语法格式-1"><a href="#语法格式-1" class="headerlink" title="语法格式"></a>语法格式</h2><p>find [路径] [参数]</p><h2 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h2><table><thead><tr><th align="left">参数</th><th>说明</th></tr></thead><tbody><tr><td align="left">-name</td><td>匹配名称</td></tr><tr><td align="left">-perm</td><td>匹配权限（mode 为完全匹配，-mode 为包含即可）</td></tr><tr><td align="left">-user</td><td>匹配所有者</td></tr><tr><td align="left">-group</td><td>匹配所有组</td></tr><tr><td align="left">-mtime -n +n</td><td>匹配修改内容的时间（-n 指 n 天以内，+n 指 n 天以前）</td></tr><tr><td align="left">-atime -n +n</td><td>匹配访问文件的时间（-n 指 n 天以内，+n 指 n 天以前）</td></tr><tr><td align="left">-ctime -n +n</td><td>匹配修改文件权限的时间（-n 指 n 天以内，+n 指 n 天以前）</td></tr><tr><td align="left">-nouser</td><td>匹配无所有者的文件</td></tr><tr><td align="left">-nogroup</td><td>匹配无所有组的文件</td></tr><tr><td align="left">-newer f1 !f2</td><td>匹配比文件 f1 新但比 f2 旧的文件</td></tr><tr><td align="left">-type b&#x2F;d&#x2F;c&#x2F;p&#x2F;l&#x2F;f</td><td>匹配文件类型，依次表示块设备、目录、字符设备、管道、链接文件、文本文件</td></tr><tr><td align="left">-size</td><td>匹配文件的大小，+50KB 大于 50KB 的文件，-50KB 小于 50KB 的文件</td></tr><tr><td align="left">-prune</td><td>忽略某个目录</td></tr><tr><td align="left">-exec …… {};</td><td>后面可跟用于进一步处理搜索结果的命令</td></tr></tbody></table><h2 id="案例演示-1"><a href="#案例演示-1" class="headerlink" title="案例演示"></a>案例演示</h2><p>全盘搜索系统中所有以.conf 结尾的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name *.conf</span><br></pre></td></tr></table></figure><p>查找后并删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name <span class="string">&quot;*.mp4&quot;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure><h2 id="更多案例-1"><a href="#更多案例-1" class="headerlink" title="更多案例"></a>更多案例</h2><p><a href="https://www.linuxcool.com/find">https://www.linuxcool.com/find</a></p><h1 id="rpm-包管理"><a href="#rpm-包管理" class="headerlink" title="rpm 包管理"></a>rpm 包管理</h1><p>rpm：RedHat Package Manager，红帽软件包管理器。用于在 Linux 系统下对软件包进行安装、卸载、查询、验证、升级等。</p><h2 id="语法格式-2"><a href="#语法格式-2" class="headerlink" title="语法格式"></a>语法格式</h2><p>rpm [参数] 软件包</p><h2 id="常用参数-2"><a href="#常用参数-2" class="headerlink" title="常用参数"></a>常用参数</h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>查询所有的软件包</td></tr><tr><td>-b</td><td>或-t 设置包装套件的完成阶段，并指定套件档的文件名称；</td></tr><tr><td>-c</td><td>只列出组态配置文件，本参数需配合”-l”参数使用</td></tr><tr><td>-d</td><td>只列出文本文件，本参数需配合”-l”参数使用</td></tr><tr><td>-e</td><td>卸载软件包</td></tr><tr><td>-f</td><td>查询文件或命令属于哪个软件包</td></tr><tr><td>-h</td><td>安装软件包时列出标记</td></tr><tr><td>-i</td><td>安装软件包</td></tr><tr><td>-l</td><td>显示软件包的文件列表</td></tr><tr><td>-p</td><td>查询指定的 rpm 软件包</td></tr><tr><td>-q</td><td>查询软件包</td></tr><tr><td>-R</td><td>显示软件包的依赖关系</td></tr><tr><td>-s</td><td>显示文件状态，本参数需配合”-l”参数使用</td></tr><tr><td>-U</td><td>升级软件包</td></tr><tr><td>-v</td><td>显示命令执行过程</td></tr><tr><td>-vv</td><td>详细显示指令执行过程</td></tr></tbody></table><h2 id="案例演示-2"><a href="#案例演示-2" class="headerlink" title="案例演示"></a>案例演示</h2><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh cockpit-185-2.el8.x86_64.rpm</span><br></pre></td></tr></table></figure><p>卸载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -evh cockpit</span><br></pre></td></tr></table></figure><p>升级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh cockpit-185-2.el8.x86_64.rpm</span><br></pre></td></tr></table></figure><p>查询</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql cockpit</span><br></pre></td></tr></table></figure><h2 id="更多案例-2"><a href="#更多案例-2" class="headerlink" title="更多案例"></a>更多案例</h2><p><a href="https://www.linuxcool.com/rpm">https://www.linuxcool.com/rpm</a></p><h1 id="ps-显示进程状态"><a href="#ps-显示进程状态" class="headerlink" title="ps 显示进程状态"></a>ps 显示进程状态</h1><p>ps：process status，查看到进程的所有信息，例如进程的号码、发起者、系统资源使用占比（处理器与内存）、运行状态等。</p><h2 id="语法格式-3"><a href="#语法格式-3" class="headerlink" title="语法格式"></a>语法格式</h2><p>ps [参数]</p><h2 id="常用参数-3"><a href="#常用参数-3" class="headerlink" title="常用参数"></a>常用参数</h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>a</td><td>显示现行终端机下的所有程序，包括其他用户的程序</td></tr><tr><td>-A</td><td>显示所有程序</td></tr><tr><td>c</td><td>显示每个程序真正的指令名称，而不包含路径</td></tr><tr><td>-C &lt;指令名称&gt;</td><td>指定执行指令的名称，并列出该指令的程序的状况</td></tr><tr><td>-d</td><td>显示所有程序，但不包括阶段作业管理员的程序</td></tr><tr><td>e</td><td>列出程序时，显示每个程序所使用的环境变量</td></tr><tr><td>-f</td><td>显示 UID,PPIP,C 与 STIME 栏位</td></tr><tr><td>f</td><td>用 ASCII 字符显示树状结构，表达程序间的相互关系</td></tr><tr><td>g</td><td>显示现行终端机下的所有程序，包括所属组的程序</td></tr><tr><td>-G &lt;群组识别码&gt;</td><td>列出属于该群组的程序的状况</td></tr><tr><td>h</td><td>不显示标题列</td></tr><tr><td>-H</td><td>显示树状结构，表示程序间的相互关系</td></tr><tr><td>-j</td><td>采用工作控制的格式显示程序状况</td></tr><tr><td>-l</td><td>采用详细的格式来显示程序状况</td></tr><tr><td>L</td><td>列出栏位的相关信息</td></tr><tr><td>-m</td><td>显示所有的执行绪</td></tr><tr><td>n</td><td>以数字来表示 USER 和 WCHAN 栏位</td></tr><tr><td>-N</td><td>显示所有的程序，除了执行 ps 指令终端机下的程序之外</td></tr><tr><td>-p &lt;程序识别码&gt;</td><td>指定程序识别码，并列出该程序的状况</td></tr><tr><td>r</td><td>只列出现行终端机正在执行中的程序</td></tr><tr><td>-s &lt;阶段作业&gt;</td><td>列出隶属该阶段作业的程序的状况</td></tr><tr><td>s</td><td>采用程序信号的格式显示程序状况</td></tr><tr><td>S</td><td>列出程序时，包括已中断的子程序资料</td></tr><tr><td>-t &lt;终端机编号&gt;</td><td>列出属于该终端机的程序的状况</td></tr><tr><td>-T</td><td>显示现行终端机下的所有程序</td></tr><tr><td>u</td><td>以用户为主的格式来显示程序状况</td></tr><tr><td>-U &lt;用户识别码&gt;</td><td>列出属于该用户的程序的状况</td></tr><tr><td>U &lt;用户名称&gt;</td><td>列出属于该用户的程序的状况</td></tr><tr><td>v</td><td>采用虚拟内存的格式显示程序状况</td></tr><tr><td>-V 或 V</td><td>显示版本信息</td></tr><tr><td>-w 或 w</td><td>采用宽阔的格式来显示程序状况</td></tr><tr><td>x</td><td>显示所有程序，不以终端机来区分</td></tr><tr><td>X</td><td>采用旧式的 Linux i386 登陆格式显示程序状况</td></tr><tr><td>-y</td><td>配合选项”-l”使用时，不显示 F(flag)栏位，并以 RSS 栏位取代 ADDR 栏位</td></tr><tr><td>–cols &lt;每列字符数&gt;</td><td>设置每列的最大字符数</td></tr><tr><td>–headers</td><td>重复显示标题列</td></tr><tr><td>–help</td><td>在线帮助</td></tr><tr><td>–info</td><td>显示排错信息</td></tr><tr><td>–lines &lt;显示列数&gt;</td><td>设置显示画面的列数</td></tr></tbody></table><h2 id="案例演示-3"><a href="#案例演示-3" class="headerlink" title="案例演示"></a>案例演示</h2><p>显示系统中全部的进程信息，含详细信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure><p>过滤只显示指定信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep ssh</span><br></pre></td></tr></table></figure><h2 id="更多案例-3"><a href="#更多案例-3" class="headerlink" title="更多案例"></a>更多案例</h2><p><a href="https://www.linuxcool.com/ps">https://www.linuxcool.com/ps</a></p><h1 id="df-磁盘空间使用情况"><a href="#df-磁盘空间使用情况" class="headerlink" title="df 磁盘空间使用情况"></a>df 磁盘空间使用情况</h1><p>df：Disk Free，用于显示系统上磁盘空间的使用量情况</p><h2 id="语法格式-4"><a href="#语法格式-4" class="headerlink" title="语法格式"></a>语法格式</h2><p>df [参数] [对象磁盘&#x2F;分区]</p><h2 id="常用参数-4"><a href="#常用参数-4" class="headerlink" title="常用参数"></a>常用参数</h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示所有系统文件</td></tr><tr><td>-B &lt;块大小&gt;</td><td>指定显示时的块大小</td></tr><tr><td>-h</td><td>以容易阅读的方式显示</td></tr><tr><td>-H</td><td>以 1000 字节为换算单位来显示</td></tr><tr><td>-i</td><td>显示索引字节信息</td></tr><tr><td>-k</td><td>指定块大小为 1KB</td></tr><tr><td>-l</td><td>只显示本地文件系统</td></tr><tr><td>-t &lt;文件系统类型&gt;</td><td>只显示指定类型的文件系统</td></tr><tr><td>-T</td><td>输出时显示文件系统类型</td></tr><tr><td>– -sync</td><td>在取得磁盘使用信息前，先执行 sync 命令</td></tr></tbody></table><h2 id="案例演示-4"><a href="#案例演示-4" class="headerlink" title="案例演示"></a>案例演示</h2><p>带有容量单位的显示系统全部磁盘使用量情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><h2 id="更多案例-4"><a href="#更多案例-4" class="headerlink" title="更多案例"></a>更多案例</h2><p><a href="https://www.linuxcool.com/df">https://www.linuxcool.com/df</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;grep-文本搜索&quot;&gt;&lt;a href=&quot;#grep-文本搜索&quot; class=&quot;headerlink&quot; title=&quot;grep 文本搜索&quot;&gt;&lt;/a&gt;grep 文本搜索&lt;/h1&gt;&lt;p&gt;grep：global search regular expression and </summary>
      
    
    
    
    <category term="Linux" scheme="https://chengshen.me/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://chengshen.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux WSL</title>
    <link href="https://chengshen.me/linux/Linux-wsl"/>
    <id>https://chengshen.me/linux/Linux-wsl</id>
    <published>2023-03-04T14:32:46.000Z</published>
    <updated>2023-03-04T15:39:19.618Z</updated>
    
    <content type="html"><![CDATA[<p>WSL：windows 下的 linux 子系统</p><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p>打开管理员模式 cmd，输入如下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --install</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure><p>重启电脑</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>下载 <a href="https://github.com/wsldl-pg/centwsl/releases/tag/7.0.1907.3">centos 7</a>，然后双击运行安装。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>列出全部系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure><p>将 CentOS7 设为默认</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default CentOS7</span><br></pre></td></tr></table></figure><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><p>注销</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister CentOS7</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;WSL：windows 下的 linux 子系统&lt;/p&gt;
&lt;h1 id=&quot;前置&quot;&gt;&lt;a href=&quot;#前置&quot; class=&quot;headerlink&quot; title=&quot;前置&quot;&gt;&lt;/a&gt;前置&lt;/h1&gt;&lt;p&gt;打开管理员模式 cmd，输入如下指令：&lt;/p&gt;
&lt;figure class=</summary>
      
    
    
    
    <category term="Linux" scheme="https://chengshen.me/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://chengshen.me/tags/Linux/"/>
    
    <category term="WSL" scheme="https://chengshen.me/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>Design Patten SOLID</title>
    <link href="https://chengshen.me/design-patten/Design-Patten-SOLID"/>
    <id>https://chengshen.me/design-patten/Design-Patten-SOLID</id>
    <published>2023-03-04T14:27:29.000Z</published>
    <updated>2023-03-04T14:30:29.719Z</updated>
    
    <content type="html"><![CDATA[<p>SOLID &#x3D; <code>S</code>RP + <code>O</code>CP + <code>L</code>SP + <code>I</code>SP + <code>D</code>IP</p><table><thead><tr><th></th><th></th><th>解释</th></tr></thead><tbody><tr><td>SRP</td><td>单一责任原则</td><td>一个类或者一个方法只做一件事</td></tr><tr><td>OCP</td><td>开放封闭原则</td><td>类独立之后就不应该去修改它，而是以扩展的方式适应新需求</td></tr><tr><td>LSP</td><td>里氏替换原则</td><td>所有基类出现的地方都可以用派生类替换</td></tr><tr><td>ISP</td><td>接口隔离原则</td><td>类不应该依赖不需要的接口</td></tr><tr><td>DIP</td><td>依赖倒置原则</td><td>程序要依赖于抽象接口，不要依赖于具体实现</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SOLID &amp;#x3D; &lt;code&gt;S&lt;/code&gt;RP + &lt;code&gt;O&lt;/code&gt;CP + &lt;code&gt;L&lt;/code&gt;SP + &lt;code&gt;I&lt;/code&gt;SP + &lt;code&gt;D&lt;/code&gt;IP&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/</summary>
      
    
    
    
    <category term="Design Patten" scheme="https://chengshen.me/categories/Design-Patten/"/>
    
    
    <category term="Design Patten" scheme="https://chengshen.me/tags/Design-Patten/"/>
    
    <category term="SOLID" scheme="https://chengshen.me/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>Design Patten 概念</title>
    <link href="https://chengshen.me/design-patten/Design-Patten-concepts"/>
    <id>https://chengshen.me/design-patten/Design-Patten-concepts</id>
    <published>2023-03-04T14:18:58.000Z</published>
    <updated>2023-03-04T14:25:44.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>创建型、结构型、行为型。<br>创建型：关注对象的创建，花式实例化对象。<br>结构型：关注类与类之间的关系，组合优于继承。<br>行为型：关注对象和行为的关系（类和方法间关系），方法到底放哪。</p><table><thead><tr><th>创建型</th><th>结构型</th><th>行为型</th></tr></thead><tbody><tr><td>单例模式</td><td>适配器模式</td><td>策略模式</td></tr><tr><td>工厂模式</td><td>装饰器模式</td><td>模板方法模式</td></tr><tr><td>工厂方法模式</td><td>代理模式</td><td>观察者模式</td></tr><tr><td>原型模式</td><td>外观模式</td><td>迭代子模式</td></tr><tr><td>建造者模式</td><td>桥接模式</td><td>责任链模式</td></tr><tr><td></td><td>组合模式</td><td>命令模式</td></tr><tr><td></td><td>享元模式</td><td>备忘录模式</td></tr><tr><td></td><td></td><td>状态模式</td></tr><tr><td></td><td></td><td>访问者模式</td></tr><tr><td></td><td></td><td>中介者模式</td></tr><tr><td></td><td></td><td>解释器模式</td></tr></tbody></table><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>用来创建对象。<br>应用场景：IOC 容器就是一个常见的工厂，负责产生实例对象。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>类只被实例化一次。<br>应用场景：数据库连接池、缓存、日志记录器等。</p><ol><li>懒汉</li><li>饿汉</li><li>双检锁</li><li>lazy(.NET)</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LazySingleton</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Lazy&lt;LazySingleton&gt; _instance = <span class="keyword">new</span> Lazy&lt;LazySingleton&gt;(() =&gt; <span class="keyword">new</span> LazySingleton());</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton Instance =&gt; _instance.Value;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span>()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>抹平类之间的兼容性问题，核心思想就是封装。<br>应用场景：</p><ol><li>电源适配器：转化电流电压等，使电器能正常充电；</li><li>EF 对不同数据库的同时支持；</li></ol><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>封装原对象，外部使用代理对象。代理模式只应该添加通用逻辑，不添加业务逻辑。<br>应用场景：</p><ol><li>VPN、代理商</li><li>在代理对象中进行日志、异常、缓存、权限等处理。</li><li>使用动态代理模式来实现 AOP。</li></ol><h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><p>目标对象在流程上被每个部分依次处理。<br>应用场景：</p><ol><li>DOM 上的事件冒泡、事件捕获；</li><li>审批流；</li><li>WebAPI 中的请求管道；</li></ol><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>资源复用共享形式。Java、C# 等，用于减少创建对象的数量，减少内存占用。<br>应用场景：C# 或 Java 对字符串对象的创建，类似于享元模式。</p><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>在父子模式下，对通用功能、数据进行复用。<br>应用场景：JavaScript 中原型中存放通用字段或方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h1&gt;&lt;p&gt;创建型、结构型、行为型。&lt;br&gt;创建型：关注对象的创建，花式实例化对象。&lt;br&gt;结构型：关注类与类之间的关系，组合优于继承。&lt;br&gt;行为型：</summary>
      
    
    
    
    <category term="Design Patten" scheme="https://chengshen.me/categories/Design-Patten/"/>
    
    
    <category term="Design Patten" scheme="https://chengshen.me/tags/Design-Patten/"/>
    
  </entry>
  
  <entry>
    <title>CSGO 单机练习配置</title>
    <link href="https://chengshen.me/csgo/CSGO-solo-practice-config"/>
    <id>https://chengshen.me/csgo/CSGO-solo-practice-config</id>
    <published>2023-03-04T12:43:01.000Z</published>
    <updated>2023-03-04T15:52:28.220Z</updated>
    
    <content type="html"><![CDATA[<p>将配置保存到 <code>[配置文件名].cfg</code> 文件中，然后在游戏里的控制台执行 <code>exce 配置文件名</code> 加载配置。</p><p>单机投掷物练习配置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">sv_cheats 1</span><br><span class="line">sv_alltalk 1</span><br><span class="line">sv_grenade_trajectory 0</span><br><span class="line">sv_grenade_trajectory_thickness 0.1</span><br><span class="line">sv_grenade_trajectory_time 5</span><br><span class="line">sv_showimpacts 0</span><br><span class="line">sv_showimpacts_time 0</span><br><span class="line">sv_infinite_ammo 2</span><br><span class="line">ammo_grenade_limit_total 5</span><br><span class="line">bot_stop 1</span><br><span class="line">bot_chatter off</span><br><span class="line">mp_warmuptime 60</span><br><span class="line">mp_teammates_are_enemies 1</span><br><span class="line">mp_maxmoney 999999</span><br><span class="line">mp_startmoney 999999</span><br><span class="line">mp_freezetime 0</span><br><span class="line">mp_buytime 999999</span><br><span class="line">mp_buy_anywhere 1</span><br><span class="line">mp_limitteams 0</span><br><span class="line">mp_autoteambalance 0</span><br><span class="line">mp_c4timer 3600</span><br><span class="line">mp_randomspawn 1</span><br><span class="line">mp_roundtime_defuse 60</span><br><span class="line">mp_roundtime_hostage 60</span><br><span class="line">mp_respawn_on_death_t 1</span><br><span class="line">mp_respawn_on_death_ct 1</span><br><span class="line">mp_death_drop_c4 0</span><br><span class="line">mp_death_drop_gun 0</span><br><span class="line">mp_death_drop_taser 0</span><br><span class="line">mp_death_drop_grenade 0</span><br><span class="line">mp_death_drop_defuser 0</span><br><span class="line">mp_death_drop_breachcharge 1</span><br><span class="line">bind alt noclip</span><br><span class="line">mp_restartgame 1</span><br></pre></td></tr></table></figure><p>局域网对战模式配置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">sv_lan 1</span><br><span class="line">sv_cheats 0</span><br><span class="line">sv_alltalk 1</span><br><span class="line">sv_showimpacts 0</span><br><span class="line">sv_matchend_drops_enabled 0</span><br><span class="line">ammo_grenade_limit_total 5</span><br><span class="line">bot_stop 0</span><br><span class="line">bot_chatter off</span><br><span class="line">bot_difficulty 0</span><br><span class="line">bot_dont_shoot 0</span><br><span class="line">mp_warmup_end</span><br><span class="line">mp_teammates_are_enemies 0</span><br><span class="line">mp_roundtime_defuse 60</span><br><span class="line">mp_roundtime_hostage 60</span><br><span class="line">mp_maxmoney 65535</span><br><span class="line">mp_startmoney 65535</span><br><span class="line">mp_freezetime 0</span><br><span class="line">mp_buytime 999999</span><br><span class="line">mp_buy_anywhere 1</span><br><span class="line">mp_limitteams 0</span><br><span class="line">mp_autoteambalance 0</span><br><span class="line">mp_c4timer 9999999</span><br><span class="line">mp_randomspawn 1</span><br><span class="line">mp_respawn_on_death_t 1</span><br><span class="line">mp_respawn_on_death_ct 1</span><br><span class="line">mp_death_drop_gun 0</span><br><span class="line">mp_death_drop_grenade 0</span><br><span class="line">mp_death_drop_defuser 0</span><br><span class="line">mp_death_drop_taser 0</span><br><span class="line">mp_friendlyfire 0</span><br><span class="line">mp_death_drop_c4 0</span><br><span class="line">mp_ignore_round_win_conditions 1</span><br><span class="line">mp_t_default_primary weapon_ak47</span><br><span class="line">mp_ct_default_primary weapon_ak47</span><br><span class="line">mp_t_default_secondary weapon_deagle</span><br><span class="line">mp_ct_default_secondary weapon_deagle</span><br><span class="line">mp_restartgame 1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;将配置保存到 &lt;code&gt;[配置文件名].cfg&lt;/code&gt; 文件中，然后在游戏里的控制台执行 &lt;code&gt;exce 配置文件名&lt;/code&gt; 加载配置。&lt;/p&gt;
&lt;p&gt;单机投掷物练习配置：&lt;/p&gt;
&lt;figure class=&quot;highlight text&quot;&gt;&lt;tabl</summary>
      
    
    
    
    <category term="CSGO" scheme="https://chengshen.me/categories/CSGO/"/>
    
    
    <category term="CSGO" scheme="https://chengshen.me/tags/CSGO/"/>
    
  </entry>
  
  <entry>
    <title>CSGO 自用按键绑定</title>
    <link href="https://chengshen.me/csgo/CSGO-key-binding"/>
    <id>https://chengshen.me/csgo/CSGO-key-binding</id>
    <published>2023-03-04T12:40:34.000Z</published>
    <updated>2023-03-04T12:41:02.057Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bind &quot;KP_END&quot; &quot; buy smokegrenade&quot;</span><br><span class="line">bind &quot;KP_DOWNARROW&quot; &quot; buy flashbang&quot;</span><br><span class="line">bind &quot;KP_PGDN&quot; &quot; buy hegrenade&quot;</span><br><span class="line">bind &quot;KP_LEFTARROW&quot; &quot; buy molotov&quot;</span><br><span class="line">bind &quot;KP_5&quot; &quot; buy decoy&quot;</span><br><span class="line">bind &quot;RIGHTARROW&quot; &quot;buy smokegrenade;buy hegrenade;buy molotov;buy flashbang;&quot;</span><br><span class="line">bind &quot;LEFTARROW&quot; &quot;buy deagle; buy ak47&quot;</span><br><span class="line">bind &quot;SPACE&quot; &quot;r_cleardecals&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="CSGO" scheme="https://chengshen.me/categories/CSGO/"/>
    
    
    <category term="CSGO" scheme="https://chengshen.me/tags/CSGO/"/>
    
  </entry>
  
  <entry>
    <title>CSGO 控制台指令</title>
    <link href="https://chengshen.me/csgo/CSGO-console-commands"/>
    <id>https://chengshen.me/csgo/CSGO-console-commands</id>
    <published>2023-03-04T12:31:41.000Z</published>
    <updated>2023-03-04T12:39:28.099Z</updated>
    
    <content type="html"><![CDATA[<p>单机作弊模式：<code>sv_cheats 1</code><br>穿墙：<code>noclip</code><br>按键绑定：<code>bind [key] [command]</code><br>清除血迹：<code>r_cleardecals</code><br>左手持枪：<code>cl_righthand 0</code><br>保存变更：<code>mat_savechanges</code><br>第一人称视角：<code>cam_command 2</code><br>第三人称视角：<code>cam_command 1</code><br>重掷投掷物：<code>sv_rethrow_last_grenade</code><br>动态投掷物轨迹预测：<code>cl_grenadepreview</code><br>显示投掷物轨迹：<code>sv_grenade_trajectory 1</code><br>只显示击杀：<code>cl_draw_only_deathnotices 1</code><br>投掷物轨迹预测：<code>cl_sim_grenade_trajectory</code><br>投掷物轨迹时间：<code>sv_grenade_trajectory_time 5</code><br>显示骨骼：<code>bind &quot;j&quot; &quot;toggle r_drawothermodels 1 2&quot;</code><br>服务器时间加速：<code>bind &quot;k&quot; &quot;incrementvar host_timescale 1 10 9&quot;</code><br>投掷物：<code>buy smokegrenade;buy hegrenade;buy molotov;buy flashbang;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单机作弊模式：&lt;code&gt;sv_cheats 1&lt;/code&gt;&lt;br&gt;穿墙：&lt;code&gt;noclip&lt;/code&gt;&lt;br&gt;按键绑定：&lt;code&gt;bind [key] [command]&lt;/code&gt;&lt;br&gt;清除血迹：&lt;code&gt;r_cleardecals&lt;/code&gt;&lt;br</summary>
      
    
    
    
    <category term="CSGO" scheme="https://chengshen.me/categories/CSGO/"/>
    
    
    <category term="CSGO" scheme="https://chengshen.me/tags/CSGO/"/>
    
    <category term="Gaming" scheme="https://chengshen.me/tags/Gaming/"/>
    
    <category term="commands" scheme="https://chengshen.me/tags/commands/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用指令</title>
    <link href="https://chengshen.me/others/Git-basic-concepts"/>
    <id>https://chengshen.me/others/Git-basic-concepts</id>
    <published>2023-02-25T06:45:34.000Z</published>
    <updated>2023-02-25T06:58:00.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 设置代理</span><br><span class="line">git config --global http.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:1080</span><br><span class="line"></span><br><span class="line">// 取消代理</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure><h1 id="切分支"><a href="#切分支" class="headerlink" title="切分支"></a>切分支</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev:origin/dev</span><br></pre></td></tr></table></figure><h1 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry pick"></a>cherry pick</h1><p>已知当前分支为 master。<br>dev 分支的 commit 记录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">commit 023sb6f299849a1fec3bbe72baaf315482522cb6</span><br><span class="line">Author: sunguowei &lt;me@xx.com&gt;</span><br><span class="line">Date:   Thu Nov 9 11:01:13 2017 +0800</span><br><span class="line">修复bug 3</span><br><span class="line">Change-Id: I30850819d3dcfb8814b5d67124133215a4469374</span><br><span class="line"></span><br><span class="line">commit 5d2c18fsf4b85b4564991963d7c3c3917e951364</span><br><span class="line">Author: sunguowei &lt;me@xx.com&gt;</span><br><span class="line">Date:   Wed Nov 8 16:33:58 2017 +0800</span><br><span class="line">修复bug 2</span><br><span class="line">Change-Id: I0c94d305a35ef8372afc127b2eab13f4ebb70386</span><br><span class="line"></span><br><span class="line">commit ba51861402b0a18663f2c9ee28ed054b0879b225</span><br><span class="line">Author: shenjiaqi &lt;other@xx.com&gt;</span><br><span class="line">Date:   Sun Nov 5 18:50:28 2017 +0800</span><br><span class="line">修复bug 1</span><br><span class="line">Change-Id: I32a8e29523f709eed59f6044c7a06311e953727e</span><br></pre></td></tr></table></figure><p>将 dev 分支 ba518 到 023sb 之间的 commits 复制到 master 分支，<code>..</code>代表范围，而且是(左不包含，右包含]。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick ba518..023sb</span><br></pre></td></tr></table></figure><h1 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><h1 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h1><p>已知存在 master 和 feature 两个分支。<br><img src="/images/git-rebase-1.png" alt="分支"><br>当前分支为 feature，同步 master 到 feature 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase master feature</span><br></pre></td></tr></table></figure><p><img src="/images/git-rebase-1.png" alt="变基"><br><code>feature</code>：待变基分支、当前分支<br><code>master</code>：基分支、目标分支<br><code>变基</code>，可以直接理解为改变基底，这里就是改变 feature 的基底，从 B 变成 M。<br>改变后：master 分支为 ABM，feature 分支为 ABMC’D’。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;代理&quot;&gt;&lt;a href=&quot;#代理&quot; class=&quot;headerlink&quot; title=&quot;代理&quot;&gt;&lt;/a&gt;代理&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c</summary>
      
    
    
    
    <category term="Git" scheme="https://chengshen.me/categories/Git/"/>
    
    
    <category term="Git" scheme="https://chengshen.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 实操</title>
    <link href="https://chengshen.me/microservices/RabbitMQ-practical-operation"/>
    <id>https://chengshen.me/microservices/RabbitMQ-practical-operation</id>
    <published>2023-02-19T14:03:07.000Z</published>
    <updated>2023-02-19T14:07:26.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Erlang-环境"><a href="#Erlang-环境" class="headerlink" title="Erlang 环境"></a>Erlang 环境</h1><p>需要配置 Er 语言环境。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>ttps:&#x2F;&#x2F;<a href="http://www.erlang.org/downloads">www.erlang.org/downloads</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>windows 环境变量的 path 中添加 erlang 的 bin 文件夹。</p><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h2><p>windows 安装包：<a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.10.1/rabbitmq-server-3.10.1.exe">https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.10.1/rabbitmq-server-3.10.1.exe</a></p><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><ol><li>windows 环境变量的 path 中添加 rabbitmq 的 sbin 文件夹。</li><li>执行 <code>rabbitmq-plugins enable rabbitmq_management</code>。</li><li>添加用户 <code>rabbitmqctl add_user [username] [password]</code>。</li><li>为用户配置权限 <code>rabbitmqctl set_user_tags [username] administrator</code>。</li><li>访问管理后台 <a href="http://localhost:15672，账号：guest，密码：guest。">http://localhost:15672，账号：guest，密码：guest。</a></li><li>后台中配置用户权限：Admin - 点击用户名 - Set permission。</li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>创建 2 个 ASP.NET 项目。分别是生产端和消费端。</p><h1 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MQProducer</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">      <span class="comment">// 创建连接工厂对象</span></span><br><span class="line">      IConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory</span><br><span class="line">      &#123;</span><br><span class="line">        HostName = <span class="string">&quot;172.21.46.105&quot;</span>,</span><br><span class="line">        Port = <span class="number">5672</span>,</span><br><span class="line">        UserName = <span class="string">&quot;rabbit1&quot;</span>,</span><br><span class="line">        Password = <span class="string">&quot;rabbit1&quot;</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 创建连接对象</span></span><br><span class="line">      IConnection con = factory.CreateConnection();</span><br><span class="line">      <span class="comment">// 创建连接会话对象</span></span><br><span class="line">      IModel channel = con.CreateModel();</span><br><span class="line"></span><br><span class="line">      <span class="built_in">string</span> name = <span class="string">&quot;demo&quot;</span>;</span><br><span class="line">      <span class="comment">// 声明一个队列</span></span><br><span class="line">      channel.QueueDeclare(</span><br><span class="line">        queue: name,       <span class="comment">// 消息队列名称</span></span><br><span class="line">        durable: <span class="literal">false</span>,    <span class="comment">// 是否持久化,true持久化,队列会保存磁盘,服务器重启时可以保证不丢失相关信息。</span></span><br><span class="line">        exclusive: <span class="literal">false</span>,  <span class="comment">// 是否排他,true排他的,如果一个队列声明为排他队列,该队列仅对首次声明它的连接可见,并在连接断开时自动删除.</span></span><br><span class="line">        autoDelete: <span class="literal">false</span>, <span class="comment">// 是否自动删除。true是自动删除。自动删除的前提是：致少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时,才会自动删除.</span></span><br><span class="line">        arguments: <span class="literal">null</span>);  <span class="comment">// 设置队列的一些其它参数</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">string</span> str = <span class="built_in">string</span>.Empty;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;发送内容:&quot;</span>);</span><br><span class="line">        str = Console.ReadLine();</span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        <span class="built_in">byte</span>[] body = Encoding.UTF8.GetBytes(str);</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        channel.BasicPublish(<span class="string">&quot;&quot;</span>, name, <span class="literal">null</span>, body);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;成功发送消息:&quot;</span> + str);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (str.Trim().ToLower() != <span class="string">&quot;exit&quot;</span>);</span><br><span class="line"></span><br><span class="line">      con.Close();</span><br><span class="line">      channel.Close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"><span class="keyword">using</span> RabbitMQ.Client.Events;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MQConsumer</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line">      IConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory</span><br><span class="line">      &#123;</span><br><span class="line">        HostName = <span class="string">&quot;172.21.46.105&quot;</span>,</span><br><span class="line">        Port = <span class="number">5672</span>,</span><br><span class="line">        UserName = <span class="string">&quot;rabbit1&quot;</span>,</span><br><span class="line">        Password = <span class="string">&quot;rabbit1&quot;</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      IConnection conn = factory.CreateConnection();</span><br><span class="line">      IModel channel = conn.CreateModel();</span><br><span class="line">      <span class="built_in">string</span> name = <span class="string">&quot;demo&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 声明一个队列</span></span><br><span class="line">      channel.QueueDeclare(</span><br><span class="line">        <span class="comment">// 消息队列名称</span></span><br><span class="line">        queue: name,</span><br><span class="line">        <span class="comment">// 是否持久化</span></span><br><span class="line">        durable: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// 是否排他。仅当前连接可用该队列</span></span><br><span class="line">        exclusive: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// 是否自动删除。最后一个消费者断开连接后，该队列自动删除</span></span><br><span class="line">        autoDelete: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// 设置队列的一些其它参数</span></span><br><span class="line">        arguments: <span class="literal">null</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">      <span class="comment">//创建消费者对象</span></span><br><span class="line">      <span class="keyword">var</span> consumer = <span class="keyword">new</span> EventingBasicConsumer(channel);</span><br><span class="line">      consumer.Received += (model, ea) =&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] message = ea.Body.ToArray();<span class="comment">//接收到的消息</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;接收到消息为:&quot;</span> + Encoding.UTF8.GetString(message));</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//消费者开启监听</span></span><br><span class="line">      channel.BasicConsume(name, <span class="literal">true</span>, consumer);</span><br><span class="line">      Console.ReadKey();</span><br><span class="line">      channel.Dispose();</span><br><span class="line">      conn.Close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Erlang-环境&quot;&gt;&lt;a href=&quot;#Erlang-环境&quot; class=&quot;headerlink&quot; title=&quot;Erlang 环境&quot;&gt;&lt;/a&gt;Erlang 环境&lt;/h1&gt;&lt;p&gt;需要配置 Er 语言环境。&lt;/p&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载</summary>
      
    
    
    
    <category term="RabbitMQ" scheme="https://chengshen.me/categories/RabbitMQ/"/>
    
    
    <category term="RabbitMQ" scheme="https://chengshen.me/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 基础</title>
    <link href="https://chengshen.me/microservices/RabbitMQ-basic-concepts"/>
    <id>https://chengshen.me/microservices/RabbitMQ-basic-concepts</id>
    <published>2023-02-19T13:37:33.000Z</published>
    <updated>2023-02-19T14:01:10.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><p>点对点模式：一个消息被一个消费者消费；<br>发布订阅模式：一个消息被多个消费者消费。</p><h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><p>交换机负责消息转发，不具备存储消息的能力，没有匹配的队列时，消息会丢失。<br>扇形交换机：Fanout ，广播，将消息发给所有绑定到交换机的队列；<br>直连交换机：Direct，定向，消息的 routing key 和 队列 binding key 对应投递；<br>主题交换机：Topic，通配符，将消息交给符合指定 routing pattern 的队列；</p><h1 id="消息流程"><a href="#消息流程" class="headerlink" title="消息流程"></a>消息流程</h1><p>生产者向交换机发送一条消息，交换机通过 routing key 和队列绑定规则(binding key)，将消息分发到队列。<br><img src="/images/rabbit-mq.webp" alt="mq"></p><h1 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h1><ol><li>推：消费者用 channel.basicConsume 订阅队列，RabbitMQ 会推送消息给消费者；</li><li>拉：消费者用 channel.basicGet 主动从指定队列拉取消息；</li></ol><h1 id="消息队列用途"><a href="#消息队列用途" class="headerlink" title="消息队列用途"></a>消息队列用途</h1><p>解耦：功能模块之间通过消息进行关系解耦；<br>削峰填谷：保护系统不因短期大流量冲击而服务崩溃；<br>冗余数据：防止系统在保存数据时崩溃导致数据丢失；<br>顺序消费：能保持消息被顺序消费；</p><h1 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h1><p>死信（Dead Letter）产生原因可能是：</p><ol><li>消费者拒收了，basic.reject、basic.nack、requeue&#x3D;false</li><li>消息超时过期了，ttl</li><li>消息数量超出队列长度了</li></ol><h2 id="配置死信交换机"><a href="#配置死信交换机" class="headerlink" title="配置死信交换机"></a>配置死信交换机</h2><p>策略(Policy)和队列参数(Optional Queue Arguments)两种方式。</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy DLX <span class="string">&quot;.*&quot;</span> <span class="string">&#x27;&#123;&quot;dead-letter-exchange&quot;:&quot;my-dlx&quot;&#125;&#x27;</span> --apply-to queues</span><br></pre></td></tr></table></figure><p>这里将名为 my-dlx 的死信交换机应用到全部队列。</p><h2 id="队列参数"><a href="#队列参数" class="headerlink" title="队列参数"></a>队列参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; queueArgs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;myExchange&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">queueArgs.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;myExchange&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myQueue&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, queueArgs);</span><br></pre></td></tr></table></figure><h2 id="死信路由"><a href="#死信路由" class="headerlink" title="死信路由"></a>死信路由</h2><ol><li>队列参数中定义 x-dead-letter-routing-key；</li><li>否则使用消息上的 routing key 去找死信交换机；</li></ol><h2 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h2><p>死信路由出现死循环，死信就会被丢弃。如：死信没定义 routing key 并投递到默认交换机。</p><h1 id="消息不丢失"><a href="#消息不丢失" class="headerlink" title="消息不丢失"></a>消息不丢失</h1><ol><li>消息生产阶段：从消息被生产出来，然后提交给 MQ 的过程中，只要能正常收到 MQ Broker 的 ack 确认响应，就表示发送成功，所以只要处理好返回值和异常，这个阶段是不会出现消息丢失的。</li><li>消息存储阶段：这个阶段一般会直接交给 MQ 消息中间件来保证，但是你要了解它的原理，比如 Broker 会做副本，保证一条消息至少同步两个节点再返回 ack。</li><li>消息消费阶段：消费端从 Broker 上拉取消息，只要消费端在收到消息后，不立即发送消费确认给 Broker，而是等到执行完业务逻辑后，再发送消费确认，也能保证消息的不丢失。</li><li>进阶：给每个发出的消息都指定一个全局唯一 ID，或者附加一个连续递增的版本号，然后在消费端做对应的版本校验。利用拦截器机制。在生产端发送消息之前，通过拦截器将消息版本号注入消息。</li></ol><h1 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h1><p>建立消息消费日志表。查询消费日志后再去消费，再更新消费日志</p><h1 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul><li>消费者数量不足；</li><li>消费者处理速度慢；</li><li>消息生产速度过快；</li><li>队列没有被正确地消费；</li><li>消费者拒绝消费(basic.reject、basic.nack)：<ul><li>basic.reject 拒绝单个消息，requeue&#x3D;true，重新排队，堆积</li><li>basic.nack 一次性拒绝多个消息，requeue&#x3D;true，重新排队，堆积</li></ul></li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul><li>增加消费者数量，加快消息的消费速度；</li><li>优化消费者的处理逻辑，提高消费速度；</li><li>增加队列的大小，缓解消息积累的问题；</li><li>限制消息的生产速度，防止消息过快地进入队列；</li><li>检查消费者是否正常工作，以及是否正确地处理了消息；</li><li>配置消息过期时间，及时清理过期消息；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模式&quot;&gt;&lt;a href=&quot;#模式&quot; class=&quot;headerlink&quot; title=&quot;模式&quot;&gt;&lt;/a&gt;模式&lt;/h1&gt;&lt;p&gt;点对点模式：一个消息被一个消费者消费；&lt;br&gt;发布订阅模式：一个消息被多个消费者消费。&lt;/p&gt;
&lt;h1 id=&quot;交换机&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="RabbitMQ" scheme="https://chengshen.me/categories/RabbitMQ/"/>
    
    
    <category term="RabbitMQ" scheme="https://chengshen.me/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Docker dockerfile</title>
    <link href="https://chengshen.me/microservices/Docker-dockerfile"/>
    <id>https://chengshen.me/microservices/Docker-dockerfile</id>
    <published>2023-02-19T10:32:48.000Z</published>
    <updated>2023-02-19T11:06:49.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install emacs</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install apache2</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><code>FROM debian</code>：将 debian 镜像作为基础镜像<br><code>RUN apt-get install emacs</code>：安装 emacs<br><code>RUN apt-get install apache2</code>：安装 apache2<br><code>CMD [&quot;/bin/bash&quot;]</code>：执行 bash</p><h1 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h1><p>FROM 用来初始化新的生成阶段，并为后续指令提供基本映像。<br>多个 FROM 代表<code>多阶段</code>构建。<br>Dockerfile 一般以 FROM 开头，ARG 是唯一能在 FROM 之前的指令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span>  CODE_VERSION=latest</span><br><span class="line"><span class="keyword">FROM</span> base:$&#123;CODE_VERSION&#125;</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash">  /code/run-app</span></span><br></pre></td></tr></table></figure><h1 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h1><ol><li>shell 模式：RUN <command></li><li>exec 模式：RUN [“executable”, “param1”, “param2”]</li></ol><p>RUN 会创建新的层（Layer），在新的层上执行命令，并提交（commit）执行结果。<br>shell 模式会调用 shell，exec 模式不会调用 shell。<br>exec 模式默认不会进行字符串替换（指的是变量替换），但可以通过显式调用 shell 的形式处理：</p><p>exec 模式调用 shell，$HOME 为变量：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo <span class="variable">$HOME</span>&quot;</span> ]</span></span><br></pre></td></tr></table></figure><h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><ol><li>exec 模式，首选：CMD [“executable”,”param1”,”param2”]</li><li>为 ENTRYPOINT 提供默认参数形式：CMD [“param1”,”param2”]</li><li>shell 模式：CMD command param1 param2</li></ol><p>一个 Dockerfile 中只能有一个 CMD，如果有多个，也只有最后一个有效。<br>CMD 主要用途是给执行容器默认行为，如：指定默认执行文件。<br>如果 CMD 用的第 2 中模式（为 ENTRYPOINT 提供默认参数形式），那么 ENTRYPOINT 指令也应该用字符串数组的形式，CMD 的值就会是 ENTRYPOINT 默认参数。<br>不要将 RUN 与 CMD 混淆。RUN 实际上运行一个命令并提交结果；CMD 在构建时不执行任何操作，而是为镜像提前设置执行指令。</p><h1 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h1><p>声明哪些端口是将要开放的，docker run 时 使用 -P（P 是大写的）进行随机端口关联映射。或者使用<br>docker run -p 外部端口:容器端口 镜像名。所以 Dockerfile 中使用 EXPOSE 用处不大。</p><h1 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h1><p>设置环境变量，会被持久化进容器。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> MY_NAME=<span class="string">&quot;John Doe&quot;</span>  MY_DOG=<span class="string">&quot;Rex The Dog&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> MY_VAR my-value</span><br></pre></td></tr></table></figure><p>如果不希望 ENV 环境变量持久化进容器，可以使用行内变量：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> DEBIAN_FRONTEND=noninteractive apt-get update &amp;&amp; apt-get install -y ...</span></span><br></pre></td></tr></table></figure><p>这里的 DEBIAN_FRONTEND&#x3D;noninteractive 就是行内变量。<br>或者 ARG 指令也能实现不持久化变量到容器。</p><h1 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [--checksum=&lt;checksum&gt;] &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="string">&quot;&lt;src&gt;&quot;</span>,... <span class="string">&quot;&lt;dest&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>–chown 只支持 Linux 容器。<br>ADD 作用是：从 src 复制文件到镜像中 dest 路径，会创建新的层。<br>src 可以是：本地文件、目录、url 形式的远程文件。<br>如果 src 是本地的压缩文件（.tar.xz），ADD 会自动解压到镜像中。<br>多 src 的，路径被解析为相对路径（相对于 build 路径）。<br>src 可以包含通配符：* 多字符，? 单字符。</p><h1 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="string">&quot;&lt;src&gt;&quot;</span>,... <span class="string">&quot;&lt;dest&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>COPY 功能和 ADD 类似，同样会创建新的层。<br>src 可以是：本地文件、目录。<br>ADD 和 COPY 两者，更推荐使用 COPY。</p><h1 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h1><p>Dockerfile 中 WORKDIR 指令为后续的 RUN、CMD、ENTRYPOINT、COPY、ADD 等指令设置工作目录。<br>多 WORKDIR 指令，如果提供了相对路径，则后出现的 WORKDIR 是基于先前出现的 WORKDIR 的路径的。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure><h1 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h1><ol><li>exec 模式：ENTRYPOINT [“executable”, “param1”, “param2”]</li><li>shell 模式：ENTRYPOINT command param1 param2</li></ol><p>docker run [image] [arguments] 的 arguments 部分会追加到 exec 模式的 ENTRYPOINT 指令数组的后面，并且会替换 CMD 指令中所有元素。如果想替换 ENTRYPOINT，使用 docker run –entrypoint。<br>shell 模式的 ENTRYPOINT 会阻止<br>Dockerfile 中只有最后一个 ENTRYPOINT 是有效指令。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>假设一个简单的场景：公司的服务器需要定期清理旧的日志文件。</p><figure class="highlight bash"><figcaption><span>clean_log 文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;即将删除 <span class="variable">$1</span> 天前的日志文件&quot;</span></span><br><span class="line">find /log_dir -ctime <span class="string">&quot;<span class="variable">$1</span>&quot;</span> -name <span class="string">&#x27;*log&#x27;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><figcaption><span>dockerfile 文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">14.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 clean_log 脚本添加到镜像中</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> clean_log /usr/bin/clean_log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 clean_log 可执行</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /usr/bin/clean_log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将此镜像的入口点定义为 clean_log 脚本</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/bin/clean_log&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为 ENTRYPOINT 提供默认参数，7天</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;7&quot;</span>]</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>构建镜像</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t log-cleaner .</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>运行镜像</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /var/log/myapplogs:/log_dir log-cleaner 365</span><br></pre></td></tr></table></figure><p>上述命令将 &#x2F;var&#x2F;log&#x2F;myapplogs 目录挂载到容器内部的脚本指定的目录，并且 365 这个值会替换掉 CMD 的 7。</p><h1 id="RUN、CMD-和-ENTRYPOINT"><a href="#RUN、CMD-和-ENTRYPOINT" class="headerlink" title="RUN、CMD 和 ENTRYPOINT"></a>RUN、CMD 和 ENTRYPOINT</h1><p>Dockerfile 中 RUN、CMD 和 ENTRYPOINT 都能够用于执行命令，下面是三者的主要用途：<br><code>RUN</code>：命令执行命令并创建新的镜像层，通常用于安装软件包；<br><code>CMD</code>：命令设置容器启动后默认执行的命令及其参数，但 CMD 设置的命令能够被 docker run 命令后面的命令行参数替换。一个 Dockerfile 至多只能有一个 CMD，如果有多个，只有最后一个生效。如果我们在 docker run 时指定了命令或者有 ENTRYPOINT，那么 CMD 就会被覆盖；<br><code>ENTRYPOINT</code>：配置容器启动时的执行命令，不会被忽略，一定会被执行，即使 docker run 时指定了其他命令。如果存在多个 ENTRYPOINT 命令，则只会执行最后一个 ENTRYPOINT 命令。</p><h2 id="RUN-1"><a href="#RUN-1" class="headerlink" title="RUN"></a>RUN</h2><figure class="highlight dockerfile"><figcaption><span>错误写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:jessie</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y gcc libc6-dev make</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis install</span></span><br></pre></td></tr></table></figure><p>该写法会创建 7 层镜像，这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。</p><figure class="highlight dockerfile"><figcaption><span>合理写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:jessie</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> buildDeps=<span class="string">&#x27;gcc libc6-dev make&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">mkdir</span> -p /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> redis.tar.gz \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> -r /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span></span><br></pre></td></tr></table></figure><h2 id="CMD-1"><a href="#CMD-1" class="headerlink" title="CMD"></a>CMD</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://ip.cn&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>该镜像作用是查机器的 IP。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myip</span><br><span class="line">docker run myip</span><br></pre></td></tr></table></figure><p>如果想替换 Dockerfile 中 CMD 中参数，执行一下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run myip curl -s http://ip.cn -i</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>RUN、ADD、COPY 这三个指令都会创建新的层。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h1&gt;&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="Docker" scheme="https://chengshen.me/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://chengshen.me/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 常用指令</title>
    <link href="https://chengshen.me/microservices/Docker-commands"/>
    <id>https://chengshen.me/microservices/Docker-commands</id>
    <published>2023-02-19T10:17:38.000Z</published>
    <updated>2023-02-19T10:31:51.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>docker image ls</td><td>查看所有镜像</td></tr><tr><td>docker images</td><td>查看所有镜像</td></tr><tr><td>docker images</td><td>查看所有镜像</td></tr><tr><td>docker pull</td><td>下载镜像</td></tr><tr><td>docker rmi</td><td>删除镜像</td></tr><tr><td>docker build</td><td>使用 Dockerfile，生成镜像</td></tr></tbody></table><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>docker create</td><td>将镜像创建为容器</td></tr><tr><td>docker ps</td><td>查看所有容器，ps &#x3D; process status</td></tr><tr><td>docker start</td><td>启动容器</td></tr><tr><td>docker stop</td><td>停止容器</td></tr><tr><td>docker logs</td><td>查看容器运行日志</td></tr><tr><td>docker run</td><td>创建并运行一个容器 docker create + docker start</td></tr><tr><td>docker cp</td><td>把本地文件复制到容器，或相反方向也行</td></tr><tr><td>docker diff</td><td>查看容器文件的变化</td></tr><tr><td>docker exec</td><td>在容器中运行命令</td></tr><tr><td>docker commit</td><td>将修改的容器创建为镜像</td></tr><tr><td>docker tag</td><td>为镜像分配一个标记</td></tr><tr><td>docker login</td><td>镜像中登录</td></tr><tr><td>docker logout</td><td>镜像中注销</td></tr><tr><td>docker push</td><td>将镜像发布到仓库</td></tr><tr><td>docker inspect</td><td>查看容器详细配置</td></tr></tbody></table><h2 id="详细指令"><a href="#详细指令" class="headerlink" title="详细指令"></a>详细指令</h2><table><thead><tr><th align="left">指令</th><th>含义</th></tr></thead><tbody><tr><td align="left">docker images -q</td><td>返回全部镜像的 id 集合，-q &#x3D; –quiet</td></tr><tr><td align="left">docker rmi -f $(docker images -q)</td><td>删除全部镜像</td></tr><tr><td align="left">docker create -p 3000:80 –name myApp linux:latest</td><td>用 linux 创建容器；外 3000 内 80；名为 myApp</td></tr><tr><td align="left">docker ps -a</td><td>查看所有容器(已启动 + 未启动)</td></tr><tr><td align="left">docker start myApp</td><td>启动 myApp 容器</td></tr><tr><td align="left">docker start $(docker ps -aq)</td><td>启动所有容器</td></tr><tr><td align="left">docker stop myApp</td><td>停止 myApp 容器</td></tr><tr><td align="left">docker logs myApp</td><td>打印日志</td></tr><tr><td align="left">docker logs -f myApp</td><td>实时打印日志</td></tr><tr><td align="left">docker exec -it myApp &#x2F;bin&#x2F;bash</td><td>进入容器，开启交互式终端，用 bash</td></tr><tr><td align="left">docker commit myApp newName:tagName</td><td>将 myApp 容器保存为镜像</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;指令&quot;&gt;&lt;a href=&quot;#指令&quot; class=&quot;headerlink&quot; title=&quot;指令&quot;&gt;&lt;/a&gt;指令&lt;/h1&gt;&lt;h2 id=&quot;镜像操作&quot;&gt;&lt;a href=&quot;#镜像操作&quot; class=&quot;headerlink&quot; title=&quot;镜像操作&quot;&gt;&lt;/a&gt;镜像操作&lt;/h</summary>
      
    
    
    
    <category term="Docker" scheme="https://chengshen.me/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://chengshen.me/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 镜像和容器</title>
    <link href="https://chengshen.me/microservices/Docker-images"/>
    <id>https://chengshen.me/microservices/Docker-images</id>
    <published>2023-02-19T10:07:48.000Z</published>
    <updated>2023-02-19T10:16:40.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。<br>镜像由文件系统叠加而成，最底端是一个引导文件系统(bootfs)。</p><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>当一个容器启动后，镜像会被移到内存中，而引导文件系统则会被卸载。<br>一个镜像可以放到另一个镜像的顶部，位于下面为父镜像，最底部的为基础镜像。</p><p><img src="/images/%E9%95%9C%E5%83%8F1.png" alt="镜像结构"><br><img src="/images/%E9%95%9C%E5%83%8F3.png" alt="镜像结构"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;镜像&quot;&gt;&lt;a href=&quot;#镜像&quot; class=&quot;headerlink&quot; title=&quot;镜像&quot;&gt;&lt;/a&gt;镜像&lt;/h1&gt;&lt;p&gt;镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时库、环</summary>
      
    
    
    
    <category term="Docker" scheme="https://chengshen.me/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://chengshen.me/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Redis 布隆过滤器</title>
    <link href="https://chengshen.me/database/Redis-bloon-filter"/>
    <id>https://chengshen.me/database/Redis-bloon-filter</id>
    <published>2023-02-18T07:51:41.000Z</published>
    <updated>2023-02-18T07:56:43.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>一个很长的二进制向量（位数组）和一系列随机映射函数。<br>优点：空间效率和查询时间都比一般的算法要好的多；<br>缺点：有一定的误识别率和删除困难。<br>Redis 中的布隆过滤器底层是一个大型<code>位数组</code>（二进制数组）和多个<code>无偏散列函数</code>。<br>位数组越长，空间占用较大，错误率越低；无偏 hash 函数越多，计算耗时较长，错误率越低；</p><h1 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h1><p>通过 k 个无偏 hash 函数计算得到 k 个 hash 值，依次取模数组长度，得到数组索引，将计算得到的数组索引下标位置数据修改为 1</p><h1 id="匹配数据"><a href="#匹配数据" class="headerlink" title="匹配数据"></a>匹配数据</h1><p>通过 k 个无偏 hash 函数计算得到 k 个 hash 值，依次取模数组长度，得到数组索引，判断索引处的值是否全部为 1，如果全部为 1 则<code>可能存在</code>，如果存在一个 0 则<code>必定不存在</code>，1%误判率。</p><h1 id="为什么是“可能存在”"><a href="#为什么是“可能存在”" class="headerlink" title="为什么是“可能存在”"></a>为什么是“可能存在”</h1><p>其实原因很简单，那些被置为 1 的位置也可能是由于其他元素的操作而改变的。<br>比如，元素 1 和 元素 2，这两个元素同时将一个位置变为了 1。<br>在这种情况下，我们就不能判定“元素 1”一定存在，这是布隆过滤器存在误判的根本原因。</p><p>布隆过滤器牺牲了判断的准确率、删除的便利性 ，才做到在时间和空间上的效率比较高，是因为：</p><ul><li>存在误判，可能要查到的元素并没有在容器中，但是 hash 之后得到的 k 个位置上值都是 1。如果 bloom filter 中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。</li><li>删除数据。一个放入容器的元素映射到 bit 数组的 k 个位置上是 1，删除的时候不能简单的直接置为 0，可能会影响其他元素的判断。可以考虑 Counting Bloom Filter</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;布隆过滤器&quot;&gt;&lt;a href=&quot;#布隆过滤器&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器&quot;&gt;&lt;/a&gt;布隆过滤器&lt;/h1&gt;&lt;p&gt;一个很长的二进制向量（位数组）和一系列随机映射函数。&lt;br&gt;优点：空间效率和查询时间都比一般的算法要好的多；&lt;br&gt;</summary>
      
    
    
    
    <category term="Redis" scheme="https://chengshen.me/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://chengshen.me/tags/Redis/"/>
    
    <category term="Bloon Filter" scheme="https://chengshen.me/tags/Bloon-Filter/"/>
    
  </entry>
  
  <entry>
    <title>Redis 事务</title>
    <link href="https://chengshen.me/database/Redis-transaction"/>
    <id>https://chengshen.me/database/Redis-transaction</id>
    <published>2023-02-18T07:49:47.000Z</published>
    <updated>2023-02-18T07:50:36.714Z</updated>
    
    <content type="html"><![CDATA[<p>MULTI 开启一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务。<br>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">SET book-name <span class="string">&quot;Mastering C++ in 21 days</span></span><br><span class="line"><span class="string">SADD tag &quot;</span>C++<span class="string">&quot; &quot;</span>Programming<span class="string">&quot; &quot;</span>Mastering Series<span class="string">&quot;</span></span><br><span class="line"><span class="string">EXEC</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MULTI 开启一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务。&lt;br&gt;单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的，中间某条指令的失败不会导致前面已做指令</summary>
      
    
    
    
    <category term="Redis" scheme="https://chengshen.me/categories/Redis/"/>
    
    
    <category term="Transaction" scheme="https://chengshen.me/tags/Transaction/"/>
    
    <category term="Redis" scheme="https://chengshen.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 持久化</title>
    <link href="https://chengshen.me/database/Redis-persistence"/>
    <id>https://chengshen.me/database/Redis-persistence</id>
    <published>2023-02-18T07:47:34.000Z</published>
    <updated>2023-02-18T07:49:07.718Z</updated>
    
    <content type="html"><![CDATA[<p>redis 持久化有 RDB 和 AOF 两种，redis 持久化是为了后期出现故障能恢复数据到内存。<br>如果 redis 同时使用 RDB 和 AOF 持久化，redis 会优先使用 AOF 进行恢复数据。</p><h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><p>RDB（Redis DataBase，快照持久化），就是完整记录某时刻全部数据。</p><ul><li>save，阻塞主线程；</li><li>bgsave，子进程去做持久化；</li><li>自动持久化：save m n，m 秒内发生 n 次变化时，会触发 bgsave。</li><li>数据恢复：redis 重启会自动从 dump.rdb 中恢复数据。</li></ul><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>AOF（Append Only File，文件追加持久化），向日志文件中追加写操作，会忽略读操作，redis 启动之初会读取该文件重新构建数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;redis 持久化有 RDB 和 AOF 两种，redis 持久化是为了后期出现故障能恢复数据到内存。&lt;br&gt;如果 redis 同时使用 RDB 和 AOF 持久化，redis 会优先使用 AOF 进行恢复数据。&lt;/p&gt;
&lt;h1 id=&quot;RDB&quot;&gt;&lt;a href=&quot;#RDB</summary>
      
    
    
    
    <category term="Redis" scheme="https://chengshen.me/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://chengshen.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 线程模型</title>
    <link href="https://chengshen.me/database/Redis-thread-model"/>
    <id>https://chengshen.me/database/Redis-thread-model</id>
    <published>2023-02-18T07:44:51.000Z</published>
    <updated>2023-02-18T07:46:23.972Z</updated>
    
    <content type="html"><![CDATA[<p>数据<code>增删改查</code>用单线程处理，线程安全。<br>Redis 6.0 中耗时的 Socket 读取、请求解析、单独用一个线程来处理，即：网络 IO 是多线程的。</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>Redis3.0 中的 BIO 线程：文件关闭、AOF 缓冲数据刷新到磁盘，以及清理对象。</p><h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><p>BGSAVE 用于快照持久化，会 fork 出一个子进程去处理。</p><h1 id="为什么单线程"><a href="#为什么单线程" class="headerlink" title="为什么单线程"></a>为什么单线程</h1><p>因为 Redis 是内存操作，CPU 不是 Redis 的瓶颈；<br>单线程避免频繁多线程上下文切换的性能问题；<br>Redis 采用非阻塞的 io 多路复用机制；</p><h1 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h1><p>单线程或单进程同时监测多个文件描述符是否可以执行 IO 操作的能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据&lt;code&gt;增删改查&lt;/code&gt;用单线程处理，线程安全。&lt;br&gt;Redis 6.0 中耗时的 Socket 读取、请求解析、单独用一个线程来处理，即：网络 IO 是多线程的。&lt;/p&gt;
&lt;h1 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="Redis" scheme="https://chengshen.me/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://chengshen.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 缓存</title>
    <link href="https://chengshen.me/database/Redis-cache"/>
    <id>https://chengshen.me/database/Redis-cache</id>
    <published>2023-02-18T07:38:04.000Z</published>
    <updated>2023-02-18T07:43:27.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>缓存穿透，缓存击穿，缓存雪崩</p><ul><li>缓存穿透(多次)：频繁查询数据库中不存在的数据。利用此进行攻击，可能压垮数据库；</li><li>缓存击穿(一次)：缓存过期时大量并发请求；</li><li>缓存雪崩：缓存服务重启或大量缓存集中失效，给后端系统(如 DB)带来很大压力；</li></ul><h1 id="应对"><a href="#应对" class="headerlink" title="应对"></a>应对</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ul><li>缓存空数据；</li><li>布隆过滤器，过滤不存在的数据请求；</li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><ul><li>互斥锁(redis.setnx)，拿锁后查数据库，再缓存；</li><li>热门数据不过期；</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><ul><li>对数据设置不同的过期时间；</li><li>互斥锁；</li></ul><h1 id="过期策略-过期时"><a href="#过期策略-过期时" class="headerlink" title="过期策略(过期时)"></a>过期策略(过期时)</h1><ul><li>定期删除，每个 100ms 随机抽取一些设置了过期时间的 key，如果过期就删除。</li><li>惰性删除，用的时候检查是否过期，如果过期就删除。</li></ul><h1 id="淘汰机制-内存满时"><a href="#淘汰机制-内存满时" class="headerlink" title="淘汰机制(内存满时)"></a>淘汰机制(内存满时)</h1><ul><li>noeviction：不淘汰数据，默认。内存使用达到阀值后，引起申请内存的命令都会报错。</li><li>volatile-ttl：淘汰将要过期的数据。</li><li>volatile-lru：淘汰最近最少使用（过期数据）。</li><li>volatile-lfu：淘汰低使用频率（过期数据）</li><li>volatile-random：随机淘汰（过期数据）。</li><li>allkeys-lru：淘汰最近最少使用（全部数据）。</li><li>allkeys-random：随机淘汰（全部数据）。</li><li>allkey-lfu：淘汰低使用频率（全部数据）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;缓存穿透，缓存击穿，缓存雪崩&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存穿透(多次)：频繁查询数据库中不存在的数据。利用此进行攻击，可能压垮数据库；&lt;/</summary>
      
    
    
    
    <category term="Redis" scheme="https://chengshen.me/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://chengshen.me/tags/Redis/"/>
    
    <category term="Cache" scheme="https://chengshen.me/tags/Cache/"/>
    
  </entry>
  
</feed>
