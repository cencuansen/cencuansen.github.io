<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>San Huo</title>
  
  <subtitle>纤凝翠薇巅，扶光入沧渊，扶摇惊砂起，山弄望舒远</subtitle>
  <link href="http://cencuansen.github.com/atom.xml" rel="self"/>
  
  <link href="http://cencuansen.github.com/"/>
  <updated>2023-02-15T11:53:42.710Z</updated>
  <id>http://cencuansen.github.com/</id>
  
  <author>
    <name>San Huo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CLR GC</title>
    <link href="http://cencuansen.github.com/2023/02/15/csharp/CLR-GC/"/>
    <id>http://cencuansen.github.com/2023/02/15/csharp/CLR-GC/</id>
    <published>2023-02-15T05:12:19.000Z</published>
    <updated>2023-02-15T11:53:42.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h1><ul><li>引用计数</li><li>引用跟踪</li></ul><p>引用计数：每个对象维护一个内存字段来统计程序中有多少部分正在使用该对象，处理不好循环引用。<br>引用跟踪：标记可达对象，清除不可达对象。</p><p>CLR 采用引用跟踪算法，托管堆维护着一个指针 NextObjPtr，它指向下一个对象在堆中的分配位置。<br>GC 时，会暂停进程中所有线程，防止 CLR 检查期间对象状态变更。<br>一旦根离开作用域，它的引用对象就会变得不可达，GC 会回收其内存。</p><h1 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h1><h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><ul><li>通过活动根标记它引用的堆对象，然后递归标记堆对象中引用的对象；</li><li>如果对象被标记过，就停止递归标记，避免死循环；</li></ul><h2 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h2><ul><li>清除无标记的对象：普通对象直接回收内存，有终结器的对象单独回收，清除之后内存占用会变得不连续。</li></ul><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><ul><li>挪动幸存的对象，使它们占用<code>连续</code>内存空间；</li><li>更新活动根引用的对象地址；</li></ul><h1 id="代"><a href="#代" class="headerlink" title="代"></a>代</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>对象越新，生存期越短；</li><li>对象越老，生存期越长；</li><li>堆的部分回收快于整堆回收；</li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ol><li>初始添加的对象为 0 代，同时给 gen0 一个预估的内存大小阈值；</li><li>当初始申请的堆内存不足以分配给新对象时，就会触发 GC；</li><li>回收和压缩完，幸存的对象会被看成 gen1 对象，此时 gen0 被认为是空的；</li><li>新对象会被分配到 gen0；</li><li>如果又遇到 gen0 空间不足时，发现 gen1 老数据空间占用低于阈值，就转而针对 gen0 对象进行垃圾回收处理；</li><li>对于老对象中字段引用新对象情况，垃圾回收器利用 JIT 编译器内部机制，在对象引用字段发生变化时，设置一个标志位，表明老对象在上一轮垃圾回收后更新过，只有发生变化的老对象才需要检查是否引用了 gen0 对象；</li><li>根据假设，老对象中可能不值得去进行垃圾回收，所以就算 1 代存在垃圾对象，也可能会保留下来；</li><li>一顿操作后，gen0 对象也会被认为是 gen1 对象了，gen0 再次被认为是空的；</li><li>gen1 缓慢增长，当某次 0 代空间又不足，触发 GC，发现 gen1 也超出容量阈值，就对 gen0 和 gen1 的对象都进行垃圾回收；</li><li>gen1 变 gen2，gen0 变 gen1，gen0 被认为是空的；</li><li>默认托管堆只支持 3 代(MaxGeneration() 返回 2)；</li></ol><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><ul><li>如果垃圾回收 0 代存活对象很少，可能会减少 0 代容量预算；</li><li>如果垃圾回收 0 代发现没多少内存被回收，就会增加 0 代容量预算；</li><li>如果没有回收到足够内存，垃圾回收器会执行一次完整回收；</li><li>如果还不够，会抛出 OOM(OutOfMemoryException)异常；</li></ul><h1 id="触发-GC"><a href="#触发-GC" class="headerlink" title="触发 GC"></a>触发 GC</h1><ul><li>0 代内存不足；</li><li>显式 GC.Collect()；</li><li>Windows 报告低内存情况；</li><li>CLR 正在卸载 AppDomain；</li><li>CLR 正在关闭；</li></ul><p>大对象：大于等于 85000 字节，被认为是大对象。对于大对象来说，又称为 gen3。<br>大对象堆：存放大对象，称为 gen3。第 3 代和第 2 代一起参与垃圾回收。</p><h1 id="GC-模式"><a href="#GC-模式" class="headerlink" title="GC 模式"></a>GC 模式</h1><ul><li>工作站，默认，适合客户端应用程序。GC 时延低，防 UI 线程明显假死；</li><li>服务器，服务器端应用程序，优化吞吐量和资源利用能力；</li></ul><h1 id="GC-子模式"><a href="#GC-子模式" class="headerlink" title="GC 子模式"></a>GC 子模式</h1><ul><li>并发，默认，后台线程在应用程序运行时并发标记对象。</li><li>非并发。</li></ul><h1 id="延迟模式"><a href="#延迟模式" class="headerlink" title="延迟模式"></a>延迟模式</h1><p>GC 时会暂停应用程序中正在运行的线程，线程被暂停的时间称为延迟。</p><table><thead><tr><th>模式</th><th>说明</th><th></th></tr></thead><tbody><tr><td>Batch</td><td>服务器模式默认值</td><td>禁后台 GC（并发 GC）。用于服务器端或无 UI 的应用程序。会替代 gcConcurrent 设置。</td></tr><tr><td>Interactive</td><td>工作站模式默认值</td><td>用于有 UI 的大多数应用程序。如果托管了某个应用，则会优先考虑托管进程的垃圾回收器设置。</td></tr><tr><td>LowLatency</td><td>（短期）低延迟模式</td><td>禁止 2 代回收，允许 0 代 1 代回收，只能在短时间内使用，仅工作站可用。</td></tr><tr><td>SustainedLowLatency</td><td>长期低延迟模式</td><td>禁止 2 代前台回收，允许 0 代 1 代回收和 2 代后台回收，可以长时间使用，工作站和服务器都可用。</td></tr><tr><td>NoGCRegion</td><td>在程序执行关键路径时将 GC 线程挂起</td><td>不能将该值直接赋值给 GCLatencyMode 属性，通过调用 GC.TryStartGCRegion 方法开始，调用 GC.EndGCRegion 方法结束。</td></tr></tbody></table><h1 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h1><ul><li>不正确的使用静态字段，导致大量数据无法被 GC 释放；</li><li>没有正确执行 Dispose()，非托管资源没有得到释放；</li><li>不正确的使用终结器 Finalize()，导致无法正常释放资源；</li><li>其他不正确的引用，导致大量托管对象无法被 GC 释放；</li></ul><h1 id="托管和非托管资源"><a href="#托管和非托管资源" class="headerlink" title="托管和非托管资源"></a>托管和非托管资源</h1><h2 id="托管资源"><a href="#托管资源" class="headerlink" title="托管资源"></a>托管资源</h2><p>指的是 .NET 可以自动进行回收的资源，主要是指托管堆上分配的内存资源。</p><h2 id="非托管资源"><a href="#非托管资源" class="headerlink" title="非托管资源"></a>非托管资源</h2><p>指的是 .NET 不知道如何回收的资源，最常见的是包装操作系统资源的对象。<br>例如：文件，窗口，网络连接，数据库连接，图标等。通过调用 IDisposable.Dispose 方法来回收非托管资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法分类&quot;&gt;&lt;a href=&quot;#算法分类&quot; class=&quot;headerlink&quot; title=&quot;算法分类&quot;&gt;&lt;/a&gt;算法分类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;引用计数&lt;/li&gt;
&lt;li&gt;引用跟踪&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;引用计数：每个对象维护一个内存字段来统计程序中</summary>
      
    
    
    
    <category term="CLR" scheme="http://cencuansen.github.com/categories/CLR/"/>
    
    
    <category term="CLR" scheme="http://cencuansen.github.com/tags/CLR/"/>
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>CLR 类型对象指针和同步块索引</title>
    <link href="http://cencuansen.github.com/2023/02/15/csharp/CLR-TOP-and-SBI/"/>
    <id>http://cencuansen.github.com/2023/02/15/csharp/CLR-TOP-and-SBI/</id>
    <published>2023-02-15T05:03:10.000Z</published>
    <updated>2023-02-15T11:53:42.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类型对象指针"><a href="#类型对象指针" class="headerlink" title="类型对象指针"></a>类型对象指针</h1><p>又称为方法表指针(MT)；<br>32 位系统占 4 字节，64 位系统占 8 字节；<br>实例化对象时，CLR 自动初始化类型对象指针这个成员，它指向类型对象。<br>用 System.Object.GetType() 方法返回这个成员值，用来知道对象（包括类型对象本身）的类型。</p><h1 id="同步块索引"><a href="#同步块索引" class="headerlink" title="同步块索引"></a>同步块索引</h1><p>32 位系统占 4 字节，64 位系统占 8 字节；</p><h2 id="同步块索引用途"><a href="#同步块索引用途" class="headerlink" title="同步块索引用途"></a>同步块索引用途</h2><ul><li>线程同步 lock；</li><li>GetHashCode，要用到同步块索引的后 26 位；</li><li>GC 时标记对象；</li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当 CLR 初始化的时候，CLR 会初始化一个同步块数组，线程遇到 lock，去检查对象的同步块索引的值，如果值指向同步块数组的项，说明已加锁，等待；否则，就去同步索引数组中找个空闲位置，记录下标值到 lock 对象的同步块索引上。<br>负责为对象分配同步块并且赋值同步块索引的线程本身是线程安全的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类型对象指针&quot;&gt;&lt;a href=&quot;#类型对象指针&quot; class=&quot;headerlink&quot; title=&quot;类型对象指针&quot;&gt;&lt;/a&gt;类型对象指针&lt;/h1&gt;&lt;p&gt;又称为方法表指针(MT)；&lt;br&gt;32 位系统占 4 字节，64 位系统占 8 字节；&lt;br&gt;实例化对象时，</summary>
      
    
    
    
    <category term="CLR" scheme="http://cencuansen.github.com/categories/CLR/"/>
    
    
    <category term="CLR" scheme="http://cencuansen.github.com/tags/CLR/"/>
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>CLR new</title>
    <link href="http://cencuansen.github.com/2023/02/15/csharp/CLR-instance-by-new/"/>
    <id>http://cencuansen.github.com/2023/02/15/csharp/CLR-instance-by-new/</id>
    <published>2023-02-15T04:52:56.000Z</published>
    <updated>2023-02-15T11:53:42.710Z</updated>
    
    <content type="html"><![CDATA[<p>CLR 要求对象都用 new 创建。</p><p>new 实例化对象：</p><ol><li>计算类和基类中所有实例字段的<code>总字节</code>数，外加类型对象指针、同步块索引字节数；</li><li>从托管堆中分配所需空间，空间数据都置为 0；</li><li>初始化对象的类型对象指针、同步块索引成员；</li><li>如果实现了 Finalize 方法，对象地址会被放到<code>终结器队列</code>；</li><li>调用类的实例<code>构造函数</code>，传递必要的参数；</li></ol><p>类型对象指针又叫做方法表指针(MT)；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CLR 要求对象都用 new 创建。&lt;/p&gt;
&lt;p&gt;new 实例化对象：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算类和基类中所有实例字段的&lt;code&gt;总字节&lt;/code&gt;数，外加类型对象指针、同步块索引字节数；&lt;/li&gt;
&lt;li&gt;从托管堆中分配所需空间，空间数据都置为 0；&lt;/li&gt;</summary>
      
    
    
    
    <category term="CLR" scheme="http://cencuansen.github.com/categories/CLR/"/>
    
    
    <category term="CLR" scheme="http://cencuansen.github.com/tags/CLR/"/>
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>CLR 基本概念</title>
    <link href="http://cencuansen.github.com/2023/02/15/csharp/CLR-basic-concepts/"/>
    <id>http://cencuansen.github.com/2023/02/15/csharp/CLR-basic-concepts/</id>
    <published>2023-02-15T04:43:00.000Z</published>
    <updated>2023-02-15T11:53:42.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CLR"><a href="#CLR" class="headerlink" title="CLR"></a>CLR</h1><p>Common Language Runtime，公共语言运行时，一种可被多种编程语言使用的运行时。</p><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><p>内存管理、程序集加载、异常处理、线程同步、安全性。</p><h2 id="托管模块"><a href="#托管模块" class="headerlink" title="托管模块"></a>托管模块</h2><p>无论哪种语言(C++、C#、VB、F#等)，最后通过编译的结果都是托管模块。<br>托管模块是 PE32 文件或 PE32+ 文件，都需要 CLR 才能执行。</p><h2 id="IL"><a href="#IL" class="headerlink" title="IL"></a>IL</h2><p>源代码经语言编译器编译生成.exe 或.dll 是 IL(Intermediate Language，中间语言)代码，CPU 不能直接执行。<br>通过 IL 代码可以了解程序执行的底层通用逻辑。</p><h2 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h2><p>Just In Time，即时编译，以方法为单位，将 IL 编译成本机 CPU 指令。<br>JIT 是按需编译的，来最小化启动开销，未被使用的方法 JIT 不编译，小而多的方法优于大而少的方法。<br>JIT 对小而简单(局部变量少，控制分支简单)的方法进行登记(enregistration)，将局部变量存到寄存器中，访问效率比堆栈更高。</p><h1 id="CTS"><a href="#CTS" class="headerlink" title="CTS"></a>CTS</h1><p>Common Type System，通用类型系统，描述类定义和行为，让不同编程语言能互通。</p><ol><li><p>类的成员：字段、属性、方法、事件等；</p></li><li><p>类和成员的可见性：</p><ul><li>public</li><li>internal</li><li>protected</li><li>private</li></ul></li><li><p>类只能单继承。一个类型只能从一个基类派生；</p></li><li><p>所有类都继承自 System.Object。</p></li></ol><h1 id="CLS"><a href="#CLS" class="headerlink" title="CLS"></a>CLS</h1><p>Common Language Specification，公共语言规范。<br>有的语言不区分大小写，有的语言不支持无符号整数、操作符重载。<br>为了不同语言程序可以进行相互通信，CLS 去定义<code>最小可通用</code>功能集合，让不同语言编译器去支持这些规范，生成的程序彼此间达到兼容目的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CLR&quot;&gt;&lt;a href=&quot;#CLR&quot; class=&quot;headerlink&quot; title=&quot;CLR&quot;&gt;&lt;/a&gt;CLR&lt;/h1&gt;&lt;p&gt;Common Language Runtime，公共语言运行时，一种可被多种编程语言使用的运行时。&lt;/p&gt;
&lt;h2 id=&quot;核心功能</summary>
      
    
    
    
    <category term="CLR" scheme="http://cencuansen.github.com/categories/CLR/"/>
    
    
    <category term="CLR" scheme="http://cencuansen.github.com/tags/CLR/"/>
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>CSharp 线程同步</title>
    <link href="http://cencuansen.github.com/2023/02/15/csharp/CSharp-thread-synchronization/"/>
    <id>http://cencuansen.github.com/2023/02/15/csharp/CSharp-thread-synchronization/</id>
    <published>2023-02-15T02:27:06.000Z</published>
    <updated>2023-02-15T11:53:42.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>线程同步指的是线程之间的协调，以确保它们不会同时执行并彼此冲突。<br>目标是保持数据完整性，避免多个线程同时访问<code>共享资源</code>时可能出现的<code>竞争</code>。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><ul><li>内核模式</li><li>用户模式</li><li>混合模式</li></ul><h1 id="内核模式"><a href="#内核模式" class="headerlink" title="内核模式"></a>内核模式</h1><p>涉及上下文切换（线程或进程切换），比较消耗操作系统资源。</p><ul><li>Mutex</li><li>Event</li><li>Semaphore</li><li>ReaderWriterLock</li></ul><h1 id="用户模式"><a href="#用户模式" class="headerlink" title="用户模式"></a>用户模式</h1><p>轮询 CPU，避免上下文切换，合适短时操作。</p><ul><li>Volatile</li><li>SpinLock</li><li>SpinWait</li><li>Interlocked</li></ul><h1 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h1><p>用户模式 + 内核模式。</p><ul><li>Barrier</li><li>Monitor&#x2F;lock</li><li>SemaphoreSlim</li><li>CountDownEvent</li><li>ManualResetEventSlim</li><li>ReaderWriterLockSlim</li></ul><h1 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h1><h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><p>互斥量，支持<code>线程互斥</code>和<code>进程互斥</code><br>线程互斥：mutex.WaitOne、mutex.ReleaseMutex<br>进程互斥：new Mutex(true, “test”, out flag)</p><ul><li>参数 1：给调用线程赋予初始所有权限</li><li>参数 2：给互斥体取个名字</li><li>参数 3：如果赋予调用线程初始权限成功就返回 true，失败就返回 false。</li></ul><h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>有 AutoResetEvent、ManualResetEvent 等。<br>使用：event.WaitOne、event.Set<br>AutoResetEvent 只激活一个线程，ManualResetEvent 激活全部线程。<br>应用：两个线程<code>交互输出</code>数字</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore 信号量，支持<code>线程同步</code>和<code>进程同步</code>。<br>使用：semaphore.Wait、semaphore.Release<br>SemaphoreSlim 轻量级信号量，用于线程同步。<br>new SemaphoreSlim(int) 设定信号总数，限制总数，比如：限制数据库连接数。</p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>volatile 修饰字段，用来告诉编译器，该字段会被多线程修改，不要对该字段进行访问优化（缓存优化），确保该字段值的多线程可见性。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoWork</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">var</span> y = x + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器第一次发现 y &#x3D; 15，就尝试缓存这个结果，避免每次计算 y &#x3D; x + 10，但 x 有可能被其他线程修改，不该缓存 y &#x3D; 15。<br>解决方法：public volatile int x，表明 x 可能会被多线程修改。</p><h2 id="SpinLock"><a href="#SpinLock" class="headerlink" title="SpinLock"></a>SpinLock</h2><p>自旋锁，一个线程获取该锁，其他线程<code>自旋</code>等待，浪费 CPU，但避免上下文切换，功能与 lock 一样。</p><h2 id="Monitor-x2F-lock"><a href="#Monitor-x2F-lock" class="headerlink" title="Monitor&#x2F;lock"></a>Monitor&#x2F;lock</h2><p>混合锁，可重入，lock 是 Monitor 语法糖，lock 无法设置超时。<br>获得锁失败，线程会由运行转为阻塞，会出现上下文切换。<br>Monitor 可超时，避免无限等待出现死锁。<br>lock 原则：</p><ol><li>只读私有；</li><li>禁用 this、typeof(type)、string；</li><li>避免 MethodImplAttribute 同步；</li></ol><h1 id="同步构造选择逻辑"><a href="#同步构造选择逻辑" class="headerlink" title="同步构造选择逻辑"></a>同步构造选择逻辑</h1><ul><li>避免使用同步构造</li><li>优先选择混合模式，其次同步模式，最次内核模式</li><li>异步锁 SemaphoreSlim.WaitAsync</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="为什么-lock-引用类型"><a href="#为什么-lock-引用类型" class="headerlink" title="为什么 lock 引用类型"></a>为什么 lock 引用类型</h2><p>同步块索引。<br>CLR 为堆内的对象分配同步索引，一个引用类型的同步索引不指向任何同步块数组中的同步块，说明没加锁，否则说明该对象被加锁了。<br>值类型没同步块索引，所以 lock 的只能是引用类型。</p><h2 id="lock-值类型会如何"><a href="#lock-值类型会如何" class="headerlink" title="lock 值类型会如何"></a>lock 值类型会如何</h2><p>值类型会被装箱，每次装箱后的对象都不一样，会导致锁定无效。</p><h2 id="lock-注意项"><a href="#lock-注意项" class="headerlink" title="lock 注意项"></a>lock 注意项</h2><p>别 lock this，无意义的 object 更好；<br>别 lock 类型对象，类型对象是全局的；<br>别 lock 字符串，因为字符串可能被驻留，不同字符对象可能指向同一个字符串；<br>别用 MethodImplAttribute(MethodImplOptions.Synchronized)，它相当于去 lock 一个方法，实例方法 lock 的是 this，静态方法 lock 的是类型对象；</p><h1 id="可超时线程同步"><a href="#可超时线程同步" class="headerlink" title="可超时线程同步"></a>可超时线程同步</h1><ul><li>Mutex：mutex.WaitOne(int)</li><li>Monitor：Monitor.TryEnter(object, int)</li><li>Semaphore：semaphore .WaitOne(int)</li><li>AutoResetEvent：resetEvent.WaitOne(int)</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="两个线程交互输出数字"><a href="#两个线程交互输出数字" class="headerlink" title="两个线程交互输出数字"></a>两个线程交互输出数字</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> some = <span class="keyword">new</span> SomeClass();</span><br><span class="line"><span class="keyword">var</span> t1 = <span class="keyword">new</span> Thread(some.PrintEven) &#123; Name = <span class="string">&quot;even&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> t2 = <span class="keyword">new</span> Thread(some.PrintOdd) &#123; Name = <span class="string">&quot;odd&quot;</span> &#125;;</span><br><span class="line">t1.Start();</span><br><span class="line">t2.Start();</span><br><span class="line"><span class="keyword">class</span> <span class="title">SomeClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 偶数</span></span><br><span class="line">    AutoResetEvent even = <span class="keyword">new</span> AutoResetEvent(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 奇数</span></span><br><span class="line">    AutoResetEvent odd = <span class="keyword">new</span> AutoResetEvent(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="built_in">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">PrintEven</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (number &lt;= <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">$&quot;<span class="subst">&#123;Thread.CurrentThread.Name&#125;</span> - <span class="subst">&#123;number++&#125;</span>&quot;</span>.Dump();</span><br><span class="line">            odd.Set();</span><br><span class="line">            even.WaitOne();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">PrintOdd</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        odd.WaitOne();</span><br><span class="line">        <span class="keyword">while</span> (number &lt;= <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">$&quot;<span class="subst">&#123;Thread.CurrentThread.Name&#125;</span> - <span class="subst">&#123;number++&#125;</span>&quot;</span>.Dump();</span><br><span class="line">            even.Set();</span><br><span class="line">            odd.WaitOne();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;线程同步指的是线程之间的协调，以确保它们不会同时执行并彼此冲突。&lt;br&gt;目标是保持数据完整性，避免多个线程同时访问&lt;code&gt;共享资源&lt;/c</summary>
      
    
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/categories/CSharp/"/>
    
    
    <category term="CLR" scheme="http://cencuansen.github.com/tags/CLR/"/>
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term="Thread Synchronization" scheme="http://cencuansen.github.com/tags/Thread-Synchronization/"/>
    
  </entry>
  
  <entry>
    <title>CSharp LINQ</title>
    <link href="http://cencuansen.github.com/2023/02/15/csharp/CSharp-linq/"/>
    <id>http://cencuansen.github.com/2023/02/15/csharp/CSharp-linq/</id>
    <published>2023-02-15T02:18:03.000Z</published>
    <updated>2023-02-15T11:53:42.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>LINQ 意为<code>集成查询语言</code>，将查询功能集成到 C# 语言的技术统称，借助 LINQ，查询成为了最高级的语言构造，就像类、方法和事件一样。<br>支持数据对象 (LINQ to Objects)、关系数据库 (LINQ to SQL) 和 XML (LINQ to XML) 等。<br>查询表达式必须以 from 子句开头，必须以 group 子句或 select 子句结尾。<br>into 存储分组结果，let 存储临时变量。</p><h1 id="惰性计算-lazy-computation"><a href="#惰性计算-lazy-computation" class="headerlink" title="惰性计算(lazy computation)"></a>惰性计算(lazy computation)</h1><p>是指<code>延迟执行</code>查询，直到实际需要时再执行查询。<br>当查询定义完成后，将创建一个查询<code>表达式树</code>，该树描述查询的结构和要执行的操作。当枚举查询结果或使用查询结果时，才会执行查询表达式树上的操作。<br>每个操作只在该操作对应的结果需要时才被执行，并且结果仅在需要时存储。因此，在数据量很大的情况下，可以避免加载整个数据集到内存中的性能损失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;LINQ 意为&lt;code&gt;集成查询语言&lt;/code&gt;，将查询功能集成到 C# 语言的技术统称，借助 LINQ，查询成为了最高级的语言构造，就</summary>
      
    
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/categories/CSharp/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term="LINQ" scheme="http://cencuansen.github.com/tags/LINQ/"/>
    
  </entry>
  
  <entry>
    <title>CSharp 异步</title>
    <link href="http://cencuansen.github.com/2023/02/15/csharp/CSharp-asynchronous/"/>
    <id>http://cencuansen.github.com/2023/02/15/csharp/CSharp-asynchronous/</id>
    <published>2023-02-15T01:30:32.000Z</published>
    <updated>2023-02-15T11:53:42.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p>同步编程中代码逻辑按<code>顺序执行</code>，处理长时间运行的操作（如：IO 操作）时会导致性能问题：软件速度缓慢且无响应。</p><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><p>异步编程对于长时间运行或 I&#x2F;O 密集型的操作，会<code>释放主线程</code>以执行其他任务，效率更高。<br>C# 中，异步编程是使用 Task 和 async&#x2F;await 关键字等来实现的。</p><h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><p>线程是最基本的工作单元，有自己的栈和内核资源，共用进程资源。</p><h1 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h1><p>线程池是一堆线程的包装器，由 CLR 维护，当有任务需要处理，先用已创建的空闲线程来执行任务，如果没有空闲线程，可能会创建新线程，也可能会等待。<br>线程池适合<code>不需要结果</code>的<code>短时操作</code>。</p><h1 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h1><ol><li><p>.NET 4 推出 Task，.NET 4.5 推出 async&#x2F;await；</p></li><li><p>Task 基于<code>池线程</code>，不是全局线程池，而是本地线程池，避免线程资源竞争；</p></li><li><p>Task 提供了丰富的 API 来管理线程、控制；</p></li><li><p>Task 依赖于 CPU，对于多核的 CPU，性能更佳；</p></li><li><p>创建一个 task 也有 3 种方式：<br>前面 2 种是一样的，不需要用 start 来开始执行，后面一种需要 start 来执行。</p><ul><li>Task.Factory.StartNew()</li><li>Task.Run()</li><li>new Task()</li></ul></li><li><p>对比 Thread、ThreadPool ，Task 原生支持<code>延续</code>、<code>取消</code>、<code>失败通知</code>；</p></li><li><p>Task 不应该用于执行长时任务;</p></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Task&lt;<span class="built_in">string</span>&gt; task1 = Task.Run&lt;<span class="built_in">string</span>&gt;(() =&gt; <span class="string">&quot;something to do&quot;</span>);</span><br><span class="line"><span class="comment">// 在获取Result结果时会阻塞线程</span></span><br><span class="line"><span class="keyword">var</span> result = task1.Result;</span><br></pre></td></tr></table></figure><h1 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h1><p>async&#x2F;await 用于简化异步代码的编写和理解，以更加自然的方式编写异步代码，避免<code>回调地狱</code>和复杂的状态机。<br>async 修饰的方法表示这是一个异步方法，而 await 表示等待异步方法执行完成。<br>使用 await 等待一个异步方法时，程序将暂停执行当前方法，等待异步方法完成，然后继续执行后续代码。<br>async&#x2F;await 更适合处理 <code>I/O 密集型</code> 操作，或 UI 事件响应；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;同步&quot;&gt;&lt;a href=&quot;#同步&quot; class=&quot;headerlink&quot; title=&quot;同步&quot;&gt;&lt;/a&gt;同步&lt;/h1&gt;&lt;p&gt;同步编程中代码逻辑按&lt;code&gt;顺序执行&lt;/code&gt;，处理长时间运行的操作（如：IO 操作）时会导致性能问题：软件速度缓慢且无响应。&lt;/p</summary>
      
    
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/categories/CSharp/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term="Asynchronous" scheme="http://cencuansen.github.com/tags/Asynchronous/"/>
    
    <category term="Synchronous" scheme="http://cencuansen.github.com/tags/Synchronous/"/>
    
    <category term="Task" scheme="http://cencuansen.github.com/tags/Task/"/>
    
    <category term="async/await" scheme="http://cencuansen.github.com/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>CSharp 委托和事件</title>
    <link href="http://cencuansen.github.com/2023/02/15/csharp/CSharp-delegate-and-event/"/>
    <id>http://cencuansen.github.com/2023/02/15/csharp/CSharp-delegate-and-event/</id>
    <published>2023-02-15T01:29:35.000Z</published>
    <updated>2023-02-15T11:53:42.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>委托约定<code>方法签名</code>，引用一个或多个方法，调用委托就是调用委托引用的全部方法。</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>类或对象通过事件向其他类或对象<code>通知</code>发生的相关事情。<br>事件只能在定义的类内部调用；</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SimpleTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Publisher publisher = <span class="keyword">new</span> Publisher();</span><br><span class="line">            Subscriber subscriber = <span class="keyword">new</span> Subscriber(publisher);</span><br><span class="line">            <span class="comment">// 触发事件</span></span><br><span class="line">            publisher.Trigger();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 发布者</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">NoticeHandler</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> NoticeHandler OnNotice;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Trigger</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 传递事件及参数</span></span><br><span class="line">            OnNotice?.Invoke(<span class="string">&quot;警告！警告！警告！警告&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 订阅者</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Subscriber</span>(<span class="params">Publisher pub</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//订阅事件</span></span><br><span class="line">              pub.OnNotice += NoticeHandler;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 订阅事件后的响应函数</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;message&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NoticeHandler</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Notice Handler Got Message: <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyConsole</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">string</span> <span class="title">DelegateFun</span>(<span class="params"><span class="built_in">string</span> word</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> DelegateFun EventSay;</span><br><span class="line">        <span class="keyword">public</span> DelegateFun DelegateSay;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoEventSay</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (EventSay != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                EventSay(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Test t = <span class="keyword">new</span> Test();</span><br><span class="line">            t.EventSay += Say1;</span><br><span class="line">            t.DelegateSay += Say1;</span><br><span class="line">            t.DelegateSay += Say2;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 错误 事件不能在外部直接调用</span></span><br><span class="line">            <span class="comment">// t.eventSay(&quot;eventSay&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正确 事件只能在声明的类内部调用</span></span><br><span class="line">            t.DoEventSay(<span class="string">&quot;eventSay&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正确。委托可以在外部直接调用，内部调用也行，还能有返回值，返回最后一个注册的方法的返回值</span></span><br><span class="line">            <span class="built_in">string</span> str = t.DelegateSay(<span class="string">&quot;deleSay&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Say1</span>(<span class="params"><span class="built_in">string</span> word</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(word);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;return &quot;</span> + word;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Say2</span>(<span class="params"><span class="built_in">string</span> word</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(word);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;return &quot;</span> + word + <span class="string">&quot; 2&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;委托&quot;&gt;&lt;a href=&quot;#委托&quot; class=&quot;headerlink&quot; title=&quot;委托&quot;&gt;&lt;/a&gt;委托&lt;/h1&gt;&lt;p&gt;委托约定&lt;code&gt;方法签名&lt;/code&gt;，引用一个或多个方法，调用委托就是调用委托引用的全部方法。&lt;/p&gt;
&lt;h1 id=&quot;事件&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/categories/CSharp/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term="Delegate" scheme="http://cencuansen.github.com/tags/Delegate/"/>
    
    <category term="Event" scheme="http://cencuansen.github.com/tags/Event/"/>
    
  </entry>
  
  <entry>
    <title>CSharp dispose</title>
    <link href="http://cencuansen.github.com/2023/02/14/csharp/CSharp-dispose/"/>
    <id>http://cencuansen.github.com/2023/02/14/csharp/CSharp-dispose/</id>
    <published>2023-02-14T15:37:48.000Z</published>
    <updated>2023-02-15T11:53:42.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDisposable-Dispose"><a href="#IDisposable-Dispose" class="headerlink" title="IDisposable.Dispose"></a>IDisposable.Dispose</h1><p>对于<code>非托管资源</code>建立和释放，C# 约定由 Dispose 方法来处理。<br>当类库中涉及到非托管资源，就应实现 Dispose 方法，来定义资源释放逻辑。<br>using 用来管理实现了 Dispose 方法的类，编译器会在作用域结束时调用 Dispose 方法。<br>非托管资源包括：网络请求，数据库连接，句柄等。</p><h1 id="标准-dispose-模式"><a href="#标准-dispose-模式" class="headerlink" title="标准 dispose 模式"></a>标准 dispose 模式</h1><ol><li>析构函数中调用 dispose 方法，托底防忘记调用；</li><li>dispose 中最后要调用 GC.SuppressFinaliza 方法，通知 CLR 无需执行析构函数，因为清除工作已完成；</li><li>多次调用 dispose 应该是安全的，dispose 方法调用后，后续再调用都不会执行额外的工作；</li><li>dispose 方法有 2 个重载：public 和 protected，protected 真实清除，public 调用 protected；</li><li>析构函数调用 protected；</li><li>protected 的 bool 参数区分是被析构函数调用（false）还是被 public 调用（true）；</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyConsole.DisposeDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用于模拟一个托管资源</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeManagedResource</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SomeManagedResource</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用于模拟一个非托管资源</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyUnmanagedResource</span> : <span class="title">IDisposable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 模拟一个非托管资源</span></span><br><span class="line">        <span class="keyword">private</span> IntPtr someUnmanagedResource = Marshal.AllocHGlobal(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 模拟一个托管资源</span></span><br><span class="line">        <span class="keyword">private</span> SomeManagedResource managedResource = <span class="keyword">new</span> SomeManagedResource(<span class="string">&quot;这是托管资源&quot;</span>);</span><br><span class="line">        <span class="comment">// 是否被清理过的标识</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">bool</span> baseDisposed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Dispose(<span class="literal">true</span>);</span><br><span class="line">            GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> isDisposing</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">// 确保多次执行的安全性</span></span><br><span class="line">            <span class="keyword">if</span> (baseDisposed)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 被 public 调用，需要额外清理托管资源</span></span><br><span class="line">            <span class="keyword">if</span> (isDisposing)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 要调用 SuppressFinaliza，需手动清理托管资源, 否则无法释放。</span></span><br><span class="line">                <span class="keyword">if</span> (managedResource != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">                    managedResource = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清理非托管资源</span></span><br><span class="line">            <span class="keyword">if</span> (someUnmanagedResource != IntPtr.Zero)</span><br><span class="line">            &#123;</span><br><span class="line">                Marshal.FreeHGlobal(someUnmanagedResource);</span><br><span class="line">                someUnmanagedResource = IntPtr.Zero;</span><br><span class="line">            &#125;</span><br><span class="line">            baseDisposed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 必须，以防忘记调用 Dispose 方法的托底方法</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        ~MyUnmanagedResource()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 必须为false</span></span><br><span class="line">            Dispose(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Finalize"><a href="#Finalize" class="headerlink" title="Finalize"></a>Finalize</h1><ol><li>无法显式的重写 Finalize 方法，只能通过析构函数语法形式来实现。</li><li>struct 中不允许定义析构函数，只有 class 中才可以，并且只能有一个。</li><li>Finalize 方法不能被继承或重载。</li><li>执行垃圾回收之前系统会自动执行 Finalize 操作。</li><li>Finalize 方法会极大地损伤性能。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IDisposable-Dispose&quot;&gt;&lt;a href=&quot;#IDisposable-Dispose&quot; class=&quot;headerlink&quot; title=&quot;IDisposable.Dispose&quot;&gt;&lt;/a&gt;IDisposable.Dispose&lt;/h1&gt;&lt;p&gt;对于</summary>
      
    
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/categories/CSharp/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term="Dispose" scheme="http://cencuansen.github.com/tags/Dispose/"/>
    
  </entry>
  
  <entry>
    <title>CSharp 简单应用</title>
    <link href="http://cencuansen.github.com/2023/02/14/csharp/CSharp-usage/"/>
    <id>http://cencuansen.github.com/2023/02/14/csharp/CSharp-usage/</id>
    <published>2023-02-14T15:27:46.000Z</published>
    <updated>2023-02-15T11:53:42.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stream <span class="title">QRCodeStream</span>(<span class="params"><span class="built_in">string</span> contents</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    QRCodeGenerator qrGenerator = <span class="keyword">new</span> QRCodeGenerator();</span><br><span class="line">    QRCodeData qrCodeData = qrGenerator.CreateQrCode(contents, QRCodeGenerator.ECCLevel.L);</span><br><span class="line">    QRCode qrCode = <span class="keyword">new</span> QRCode(qrCodeData);</span><br><span class="line">    Bitmap bigMap = qrCode.GetGraphic(<span class="number">20</span>, Color.Black, Color.White, <span class="literal">true</span>);</span><br><span class="line">    MemoryStream stream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line">    bigMap.Save(stream, System.Drawing.Imaging.ImageFormat.Png);</span><br><span class="line">    stream.Position = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拼接图片"><a href="#拼接图片" class="headerlink" title="拼接图片"></a>拼接图片</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> file1 = <span class="string">@&quot;C:\Users\Admin\Desktop\images\1.png&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> file2 = <span class="string">@&quot;C:\Users\Admin\Desktop\images\2.png&quot;</span>;</span><br><span class="line">Image image1 = Image.FromStream(<span class="keyword">new</span> MemoryStream(File.ReadAllBytes(file1)));</span><br><span class="line">Image image2 = Image.FromStream(<span class="keyword">new</span> MemoryStream(File.ReadAllBytes(file2)));</span><br><span class="line"><span class="keyword">var</span> image1Width = image1.Width;</span><br><span class="line"><span class="keyword">var</span> image1Height = image1.Height;</span><br><span class="line"><span class="keyword">var</span> image2Width = image2.Height;</span><br><span class="line"><span class="keyword">var</span> image2Height = image2.Height;</span><br><span class="line"><span class="keyword">var</span> stream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line"><span class="keyword">using</span> Bitmap map = <span class="keyword">new</span> Bitmap(image1Width, image1Height);<span class="comment">//定义画布</span></span><br><span class="line">Graphics g = Graphics.FromImage(map);<span class="comment">//定义画笔</span></span><br><span class="line">g.Clear(Color.White);<span class="comment">//把画布更改为白色</span></span><br><span class="line">g.DrawImage(image1, <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">g.DrawImage(image2, <span class="keyword">new</span> Point(image1Width - image2Width, image1Height - image2Height));</span><br><span class="line">map.Save(stream, ImageFormat.Jpeg);</span><br></pre></td></tr></table></figure><h1 id="端口占用检查"><a href="#端口占用检查" class="headerlink" title="端口占用检查"></a>端口占用检查</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;请输入需要检测的端口号(如：80), 输入exit退出此程序&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> inPortString = Console.ReadLine();</span><br><span class="line">  Process process = <span class="keyword">new</span> Process();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (inPortString == <span class="string">&quot;exit&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    process.Close();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> port = <span class="number">80</span>;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrWhiteSpace(inPortString))</span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;输入端口号非法，将查询默认端口号：80&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      port = Convert.ToInt32(inPortString);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception e)</span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;输入端口号非法，将查询默认端口号：80&quot;</span>);</span><br><span class="line">    port = <span class="number">80</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  process.StartInfo.FileName = <span class="string">&quot;cmd.exe&quot;</span>;</span><br><span class="line">  process.StartInfo.UseShellExecute = <span class="literal">false</span>;</span><br><span class="line">  process.StartInfo.RedirectStandardInput = <span class="literal">true</span>;</span><br><span class="line">  process.StartInfo.RedirectStandardOutput = <span class="literal">true</span>;</span><br><span class="line">  process.StartInfo.RedirectStandardError = <span class="literal">true</span>;</span><br><span class="line">  process.StartInfo.CreateNoWindow = <span class="literal">true</span>;</span><br><span class="line">  process.Start();</span><br><span class="line">  process.StandardInput.WriteLine(<span class="string">&quot;netstat -ano&quot;</span>);</span><br><span class="line">  process.StandardInput.WriteLine(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">  Regex reg = <span class="keyword">new</span> Regex(<span class="string">&quot;\\s+&quot;</span>, RegexOptions.Compiled);</span><br><span class="line">  <span class="built_in">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">string</span> line = <span class="built_in">string</span>.Empty;</span><br><span class="line">  <span class="keyword">while</span> ((line = process.StandardOutput.ReadLine()) != <span class="literal">null</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    line = line.Trim();</span><br><span class="line">    <span class="keyword">if</span> (line.StartsWith(<span class="string">&quot;TCP&quot;</span>, StringComparison.OrdinalIgnoreCase))</span><br><span class="line">    &#123;</span><br><span class="line">      line = reg.Replace(line, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">      <span class="built_in">string</span>[] arr = line.Split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (arr[<span class="number">1</span>].EndsWith(<span class="string">$&quot;:<span class="subst">&#123;port&#125;</span>&quot;</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        found = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">int</span> pid = <span class="built_in">int</span>.Parse(arr[<span class="number">4</span>]);</span><br><span class="line">        Process foundProcess = Process.GetProcessById(pid);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;port&#125;</span>端口. pid：<span class="subst">&#123;pid&#125;</span>, 进程名：<span class="subst">&#123;foundProcess.ProcessName&#125;</span>\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!found)</span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;未找到<span class="subst">&#123;port&#125;</span>端口上的进程\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  process.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="byte-、string、stream-间转换"><a href="#byte-、string、stream-间转换" class="headerlink" title="byte[]、string、stream 间转换"></a>byte[]、string、stream 间转换</h1><h2 id="stream-gt-string"><a href="#stream-gt-string" class="headerlink" title="stream -&gt; string"></a>stream -&gt; string</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> StreamReader reader = <span class="keyword">new</span> StreamReader(stream);</span><br><span class="line"><span class="built_in">string</span> result = reader.ReadToEnd();</span><br></pre></td></tr></table></figure><h2 id="string-gt-stream"><a href="#string-gt-stream" class="headerlink" title="string -&gt; stream"></a>string -&gt; stream</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> test = <span class="string">&quot;This is string&quot;</span>;</span><br><span class="line"><span class="keyword">using</span> MemoryStream stream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line"><span class="keyword">using</span> StreamWriter writer = <span class="keyword">new</span> StreamWriter( stream );</span><br><span class="line">writer.Write( test );</span><br><span class="line">writer.Flush();</span><br></pre></td></tr></table></figure><h2 id="byte-gt-string"><a href="#byte-gt-string" class="headerlink" title="byte[] -&gt; string"></a>byte[] -&gt; string</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = System.Text.Encoding.Default.GetString( byteArray );</span><br></pre></td></tr></table></figure><h2 id="string-gt-byte"><a href="#string-gt-byte" class="headerlink" title="string -&gt; byte[]"></a>string -&gt; byte[]</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>[] byteArray = System.Text.Encoding.Default.GetBytes( str );</span><br></pre></td></tr></table></figure><h2 id="stream-gt-byte"><a href="#stream-gt-byte" class="headerlink" title="stream -&gt; byte[]"></a>stream -&gt; byte[]</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>[] bytes = <span class="keyword">new</span> <span class="built_in">byte</span>[stream.Length];</span><br><span class="line">stream.Read(bytes, <span class="number">0</span>, bytes.Length);</span><br></pre></td></tr></table></figure><h2 id="byte-gt-stream"><a href="#byte-gt-stream" class="headerlink" title="byte[] -&gt; stream"></a>byte[] -&gt; stream</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Stream stream = <span class="keyword">new</span> MemoryStream(bytes);</span><br></pre></td></tr></table></figure><h1 id="文本长度"><a href="#文本长度" class="headerlink" title="文本长度"></a>文本长度</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> strTmp = <span class="string">&quot;a1某某某&quot;</span>;</span><br><span class="line"><span class="comment">// 10，Unicode下中英文每个字2字节。</span></span><br><span class="line"><span class="built_in">int</span> len1 = System.Text.Encoding.Unicode.GetBytes(strTmp).Length;</span><br><span class="line"><span class="comment">// 11，Default 等价与 UTF8，中文3个字节，英文1个字节</span></span><br><span class="line"><span class="built_in">int</span> len2 = System.Text.Encoding.Default.GetBytes(strTmp).Length;</span><br><span class="line"><span class="built_in">int</span> len3 = System.Text.Encoding.UTF8.GetBytes(strTmp).Length;</span><br><span class="line"><span class="comment">// 5，就是个数</span></span><br><span class="line"><span class="built_in">int</span> len4 = System.Text.Encoding.Default.GetBytes(strTmp).Length;</span><br></pre></td></tr></table></figure><h1 id="WebSocket-应用"><a href="#WebSocket-应用" class="headerlink" title="WebSocket 应用"></a>WebSocket 应用</h1><h2 id="Startup-Configure"><a href="#Startup-Configure" class="headerlink" title="Startup.Configure"></a>Startup.Configure</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.UseWebSockets();</span><br></pre></td></tr></table></figure><h2 id="Controller-cs"><a href="#Controller-cs" class="headerlink" title="Controller.cs"></a>Controller.cs</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet(<span class="string">&quot;receive-message&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">GetMessage</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (HttpContext.WebSockets.IsWebSocketRequest)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> webSocket = <span class="keyword">await</span> HttpContext.WebSockets.AcceptWebSocketAsync())</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;WebSocket connection established&quot;</span>);</span><br><span class="line">            <span class="keyword">await</span> Echo(webSocket);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        HttpContext.Response.StatusCode = <span class="number">400</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">Echo</span>(<span class="params">WebSocket webSocket</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span> * <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> webSocket.ReceiveAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(buffer), CancellationToken.None);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Message received from Client&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!result.CloseStatus.HasValue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> serverMsg = Encoding.UTF8.GetBytes(<span class="string">$&quot;Server: Hello. You said: <span class="subst">&#123;Encoding.UTF8.GetString(buffer)&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">await</span> webSocket.SendAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(serverMsg, <span class="number">0</span>, serverMsg.Length), result.MessageType, result.EndOfMessage, CancellationToken.None);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Message sent to Client&quot;</span>);</span><br><span class="line">        result = <span class="keyword">await</span> webSocket.ReceiveAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(buffer), CancellationToken.None);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Message received from Client&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> webSocket.CloseAsync(result.CloseStatus.Value, result.CloseStatusDescription, CancellationToken.None);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;WebSocket connection closed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var socket = new WebSocket(&#x27;wss://localhost:6666/receive-message&#x27;);</span><br><span class="line">socket.send(&#x27;前端消息&#x27;);</span><br></pre></td></tr></table></figure><h1 id="HTTP-网络请求"><a href="#HTTP-网络请求" class="headerlink" title="HTTP 网络请求"></a>HTTP 网络请求</h1><p>HttpWebRequest：最早，不阻塞 ui，细节控制；<br>WebClient：对 HttpWebRequest 的简化和封装；<br>HttpClient：.NET 4.5 开始，预热机制，适合发送多次请求；</p><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> httpClientHandler = <span class="keyword">new</span> HttpClientHandler</span><br><span class="line">&#123;</span><br><span class="line">  Proxy = <span class="keyword">new</span> WebProxy(<span class="string">&quot;http://127.0.0.1:1080&quot;</span>, <span class="literal">false</span>),<span class="comment">// 设置代理</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient(httpClientHandler);</span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> httpClient.GetAsync(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> responseText = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br></pre></td></tr></table></figure><p>HttpClient 存在 Dispose 后不能立即释放对应套接字问题，默认需要 4 分钟去释放。<br>可以创建一个 HttpClient 实例，把它存储在一个静态字段中，或者使用 HttpClientFactory，<a href="url=https://www.oschina.net/news/77036/httpclient">相关文章</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生成二维码&quot;&gt;&lt;a href=&quot;#生成二维码&quot; class=&quot;headerlink&quot; title=&quot;生成二维码&quot;&gt;&lt;/a&gt;生成二维码&lt;/h1&gt;&lt;figure class=&quot;highlight c#&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</summary>
      
    
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/categories/CSharp/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>CSharp .NET 和 C#</title>
    <link href="http://cencuansen.github.com/2023/02/14/csharp/CSharp-dotnet-and-csharp/"/>
    <id>http://cencuansen.github.com/2023/02/14/csharp/CSharp-dotnet-and-csharp/</id>
    <published>2023-02-14T15:21:07.000Z</published>
    <updated>2023-02-15T11:53:42.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-和-NET"><a href="#C-和-NET" class="headerlink" title="C# 和 .NET"></a>C# 和 .NET</h1><table><thead><tr><th>语言版本</th><th>发布时间</th><th>.NET Framework 要求</th><th>Visual Studio 版本</th></tr></thead><tbody><tr><td>C# 1.0</td><td>2002.1</td><td>.NET Framework 1.0</td><td>Visual Studio .NET 2002</td></tr><tr><td>C# 1.1&#x2F;1.2</td><td>2003.4</td><td>.NET Framework 1.1</td><td>Visual Studio .NET 2003</td></tr><tr><td>C# 2.0</td><td>2005.11</td><td>.NET Framework 2.0</td><td>Visual Studio 2005</td></tr><tr><td>C# 3.0</td><td>2007.11</td><td>.NET Framework 2.0&#x2F;3.0&#x2F;3.5</td><td>Visual Studio 2008</td></tr><tr><td>C# 4.0</td><td>2010.4</td><td>.NET Framework 4.0</td><td>Visual Studio 2010</td></tr><tr><td>C# 5.0</td><td>2012.8</td><td>.NET Framework 4.5</td><td>Visual Studio 2012&#x2F;2013</td></tr><tr><td>C# 6.0</td><td>2015.7</td><td>.NET Framework 4.6</td><td>Visual Studio 2015</td></tr><tr><td>C# 7.0</td><td>2017.3</td><td>.NET Framework 4.6.2</td><td>Visual Studio 2017</td></tr><tr><td>C# 7.1</td><td>2017.6</td><td>.NET Framework 4.7</td><td>Visual Studio 2017 v15.3 预览版</td></tr><tr><td>C# 7.2</td><td>2017.11</td><td>.NET Framework 4.7.1</td><td>Visual Studio 2017 v15.5</td></tr><tr><td>C# 7.3</td><td>2018.5</td><td>.NET Framework 4.7.2</td><td>Visual Studion 2017 v15.7</td></tr><tr><td>C# 8.0</td><td>2019.04.18</td><td>.NET Framework 4.8&#x2F;.NET Core 3&#x2F;3.1</td><td>Visual Studion 2019</td></tr><tr><td>C# 9</td><td>2020.09.04</td><td>.NET 5</td><td>Visual Studion 2019</td></tr><tr><td>C# 10.0</td><td>2021.11.09</td><td>.NET 6</td><td>Visual Studion 2022</td></tr><tr><td>C# 11</td><td>2022.11.8</td><td>.NET 7</td><td>Visual Studion 2022</td></tr></tbody></table><h1 id="C-版本及其语言特性"><a href="#C-版本及其语言特性" class="headerlink" title="C# 版本及其语言特性"></a>C# 版本及其语言特性</h1><h2 id="C-1-0-2002-年-01-月"><a href="#C-1-0-2002-年-01-月" class="headerlink" title="C# 1.0 [2002 年 01 月]"></a>C# 1.0 [2002 年 01 月]</h2><p>类、结构、接口、事件、属性、委托，运算符和表达式、语句、特性</p><h2 id="C-2-0-2005-年-11-月"><a href="#C-2-0-2005-年-11-月" class="headerlink" title="C# 2.0 [2005 年 11 月]"></a>C# 2.0 [2005 年 11 月]</h2><p>泛型、Partial 类型、匿名方法、迭代器、可空类型、私有 setters、方法组转化(delegates)、协变和逆变、静态类</p><h2 id="C-3-0-2007-年-11-月"><a href="#C-3-0-2007-年-11-月" class="headerlink" title="C# 3.0 [2007 年 11 月]"></a>C# 3.0 [2007 年 11 月]</h2><p>隐式类型的局部变量(var)、对象与集合初始化器、自动实现属性(get;set;)、Partial 方法、匿名类、扩展方法、LINQ、Lambda 表达式、表达式树<br><a href="https://msdn.microsoft.com/en-us/library/bb308966.aspx">https://msdn.microsoft.com/en-us/library/bb308966.aspx</a></p><h2 id="C-4-0-2010-年-04-月"><a href="#C-4-0-2010-年-04-月" class="headerlink" title="C# 4.0 [2010 年 04 月]"></a>C# 4.0 [2010 年 04 月]</h2><p>动态绑定(dynamic)、命名参数和可选参数、泛型协变和逆变、嵌入式互操作类型<br><a href="https://msdn.microsoft.com/en-us/magazine/ff796223.aspx">https://msdn.microsoft.com/en-us/magazine/ff796223.aspx</a></p><h2 id="C-5-0-2012-年-08-月"><a href="#C-5-0-2012-年-08-月" class="headerlink" title="C# 5.0 [2012 年 08 月]"></a>C# 5.0 [2012 年 08 月]</h2><p>异步特性(async &amp; await)、调用者信息<br><a href="https://learn.microsoft.com/zh-cn/archive/blogs/mvpawardprogram/an-introduction-to-new-features-in-c-5-0">https://learn.microsoft.com/zh-cn/archive/blogs/mvpawardprogram/an-introduction-to-new-features-in-c-5-0</a></p><h2 id="C-6-0-2015-年-07-月"><a href="#C-6-0-2015-年-07-月" class="headerlink" title="C# 6.0 [2015 年 07 月]"></a>C# 6.0 [2015 年 07 月]</h2><p>表达式为主体的成员方法和只读属性、属性初始化赋值、nameof 表达式、Await in catch block、异常过滤器(when)、字符串插值<br><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6">https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6</a></p><h2 id="C-7-0-2017-年-03-月"><a href="#C-7-0-2017-年-03-月" class="headerlink" title="C# 7.0 [2017 年 03 月]"></a>C# 7.0 [2017 年 03 月]</h2><p>out variables、Tuples、Discards、Pattern Matching、局部方法、Generalized async return types<br><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7">https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7</a></p><h2 id="C-8-0-2019-年-04-月"><a href="#C-8-0-2019-年-04-月" class="headerlink" title="C# 8.0 [2019 年 04 月]"></a>C# 8.0 [2019 年 04 月]</h2><p>Readonly members、默认接口方法、Using declarations、静态局部方法、Disposable ref structs、可空引用类型<br><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8">https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8</a></p><h2 id="C-9-0-2020-年-09-月"><a href="#C-9-0-2020-年-09-月" class="headerlink" title="C# 9.0 [2020 年 09 月]"></a>C# 9.0 [2020 年 09 月]</h2><p>Records、Init-only properties、Top-level statements、Init accessors and readonly fields、With 表达式、Value-based equality、Primary constructor<br><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9">https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9</a></p><h2 id="C-10-0-2021-年-11-月"><a href="#C-10-0-2021-年-11-月" class="headerlink" title="C# 10.0 [2021 年 11 月]"></a>C# 10.0 [2021 年 11 月]</h2><p>Record structs、Global using directives、File-scoped namespace declaration、Extended Proptery Patterns、Null Parameter Checking、Constant interpolated strings<br><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10">https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10</a></p><h2 id="C-11-0-2022-年-11-月"><a href="#C-11-0-2022-年-11-月" class="headerlink" title="C# 11.0 [2022 年 11 月]"></a>C# 11.0 [2022 年 11 月]</h2><p>原生字符串字面量、Generic math support、泛型 attributes、UTF-8 字符串字面量、Newlines in string interpolation expressions、List patterns、file 类修饰符、Required members、Auto-default structs、Pattern match Span<char> on a constant string、Extended nameof scope、Numeric IntPtr、ref fields and scoped ref、Improved method group conversion to delegate、Warning wave 7<br><a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11">https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11</a><br>综合<br><a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history">https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-和-NET&quot;&gt;&lt;a href=&quot;#C-和-NET&quot; class=&quot;headerlink&quot; title=&quot;C# 和 .NET&quot;&gt;&lt;/a&gt;C# 和 .NET&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;语言版本&lt;/th&gt;
&lt;th&gt;发布时间&lt;/th&gt;
</summary>
      
    
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/categories/CSharp/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term=".NET" scheme="http://cencuansen.github.com/tags/NET/"/>
    
    <category term="Features" scheme="http://cencuansen.github.com/tags/Features/"/>
    
  </entry>
  
  <entry>
    <title>CSharp 基础知识</title>
    <link href="http://cencuansen.github.com/2023/02/14/csharp/CSharp-basic-concepts/"/>
    <id>http://cencuansen.github.com/2023/02/14/csharp/CSharp-basic-concepts/</id>
    <published>2023-02-14T14:49:07.000Z</published>
    <updated>2023-02-15T11:53:42.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="string-Empty、-“”-、-null。"><a href="#string-Empty、-“”-、-null。" class="headerlink" title="string.Empty、 “” 、 null。"></a>string.Empty、 “” 、 null。</h1><p>Empty 是 string 类中的一个静态的只读字段。<br>string.Empty 和 “” 是一样的。<br>string str &#x3D; null 表示 str 未指向任何对象。</p><h1 id="string-和-StringBuilder"><a href="#string-和-StringBuilder" class="headerlink" title="string 和 StringBuilder"></a>string 和 StringBuilder</h1><p>string 是不可变对象，string 是 String 的别名，string 是 c#中的类，String 是 Framework 的类，编译器会把 string 编译成 String。<br>StringBuilder 为动态字符串。StringBuilder 当达到容量时，将自动分配新的空间且容量翻倍。</p><h1 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h1><p>向现有类型“添加”方法，无需派生、重新编译或修改原始类型。<br>扩展方法是一种静态类中的静态方法。<br>扩展方法第一个参数是 this 修饰的被扩展的类。</p><h1 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h1><p>装箱：值类型 -&gt; 引用类型 。<br>拆箱：引用类型 -&gt; 值类型。<br>一次装箱要分配内存（托管堆）和拷贝数据（从栈到托管堆）。<br>拆箱就是装箱的相反操作。</p><h1 id="更改已装箱的对象"><a href="#更改已装箱的对象" class="headerlink" title="更改已装箱的对象"></a>更改已装箱的对象</h1><p>已装箱的对象，无法直接调用其指定方法。<br>让类对象继承一个接口，借助接口方式来更改已装箱的对象中的数据。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISomeClass</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Change</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeClass</span> : <span class="title">ISomeClass</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span> x &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Change</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SomeClass some = <span class="keyword">new</span> SomeClass();</span><br><span class="line">some.x = <span class="number">100</span>;</span><br><span class="line">Object o = some; <span class="comment">// 装箱</span></span><br><span class="line">((SomeClass)o).Change(<span class="number">200</span>); <span class="comment">// 没改掉。</span></span><br><span class="line">((ISomeClass)o).Change(<span class="number">200</span>); <span class="comment">// 改掉了。</span></span><br></pre></td></tr></table></figure><h1 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h1><ul><li>运算符：创建对象实例。</li><li>修饰符：在派生类定义一个重名的方法，隐藏基类方法。</li><li>约束：泛型约束，表示泛型类型要有 public 修饰的无参构造。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ItemFactory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">IComparable</span>, <span class="title">new</span>()</span><br><span class="line">&#123;  &#125;</span><br></pre></td></tr></table></figure><h1 id="new-和-override"><a href="#new-和-override" class="headerlink" title="new 和 override"></a>new 和 override</h1><p>new 和 override 都可用覆盖基类同名方法；<br>new 覆盖基类不完全，父类引用子类实例时，能调用到基类方法，override 覆盖基类是彻底的，一旦子类 override 基类方法后，就无法再调用基类同名方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">Say</span> ()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I am parent&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Child1</span> : <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">Say</span> ()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I am child1&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Child2</span> : <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">new</span> <span class="built_in">string</span> <span class="title">Say</span> ()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I am child2&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类引用子类实例</span></span><br><span class="line">Parent instance1 = <span class="keyword">new</span> Child1();</span><br><span class="line"><span class="comment">// I am child1</span></span><br><span class="line"><span class="built_in">string</span> who1 = instance1.Say();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类引用子类实例</span></span><br><span class="line">Parent instance2 = <span class="keyword">new</span> Child2();</span><br><span class="line"><span class="comment">// 注意，这里就能调用到基类方法，结果为：I am parent</span></span><br><span class="line"><span class="built_in">string</span> who1 = instance2.Say();</span><br></pre></td></tr></table></figure><h1 id="int-和-int"><a href="#int-和-int" class="headerlink" title="int? 和 int"></a>int? 和 int</h1><p>可空类型，默认值可以是 null。<br>int? 是通过 int 装箱为引用类型实现。<br><code>Nullable.GetUnderlyingType(typeof(int?)) != null</code> 用来判断类型是否是可空类型</p><h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>约定方法签名，来对方法进行引用，类似指针，方法能当参数传递给形参，用于事件、回调等。</p><h1 id="const-和-readonly"><a href="#const-和-readonly" class="headerlink" title="const 和 readonly"></a>const 和 readonly</h1><p>readonly 运行时常量。<br>const 编译时常量。<br>readonly 常量只能声明为类字段。<br>const 除了类字段，还可以声明为方法中的局部常量，默认为静态类型，不能用 static 修饰。</p><h1 id="CTS、CLS、CLR"><a href="#CTS、CLS、CLR" class="headerlink" title="CTS、CLS、CLR"></a>CTS、CLS、CLR</h1><p>CTS：通用类型系统；<br>CLS：通用语言规范；<br>CLR：公共语言运行库；</p><h1 id="using"><a href="#using" class="headerlink" title="using"></a>using</h1><ul><li>引用命名空间。</li><li>using 一个非托管资源（IDisposiable），用来释放资源。</li></ul><h1 id="托管资源、非托管资源"><a href="#托管资源、非托管资源" class="headerlink" title="托管资源、非托管资源"></a>托管资源、非托管资源</h1><p>托管资源指的是.NET 可以自动进行回收的资源，主要是指托管堆上分配的内存资源。<br>非托管资源指的是.NET 不知道如何回收的资源，最常见的是包装操作系统资源的对象，例如文件，窗口，网络连接，数据库连接，画刷，图标等。<br>建议通过调用 IDisposable.Dispose()方法来回收非托管资源。</p><h1 id="ref、out、in"><a href="#ref、out、in" class="headerlink" title="ref、out、in"></a>ref、out、in</h1><p>相同：都是按引用传递，形参成为实参的别名；<br>不同：ref 在方法外需初始化；out 需在方法内赋值；in 在方法内是只读的。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  <span class="built_in">int</span> number = <span class="number">50</span>;</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;调用方法前 number 值：&quot;</span> + number);</span><br><span class="line">  RefFunction(<span class="keyword">ref</span> number);</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;调用方法后 number 值：&quot;</span> + number);</span><br><span class="line">  Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入的参数值是 50 ，方法中使用的 num 值也是 50</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RefFunction</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  num = num / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> number = <span class="number">50</span>;</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;调用方法前 number 值：&quot;</span> + number);</span><br><span class="line">  OutFunction(<span class="keyword">out</span> number);</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;调用方法后 number 值：&quot;</span> + number);</span><br><span class="line">  Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法将的参数值 50 传入 ，但是必须在方法中初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OutFunction</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  num = <span class="number">120</span>;</span><br><span class="line">  num = num / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="in-的意义"><a href="#in-的意义" class="headerlink" title="in 的意义"></a>in 的意义</h1><p>结构体实例数据分配在栈上，当需要将大数据量的结构体作为方法参数时，会复制一份该大结构体，成本有点高，使用 in 来按引用传递该大结构体，就能避免复制问题。</p><h1 id="ref、out、in-使用限制"><a href="#ref、out、in-使用限制" class="headerlink" title="ref、out、in 使用限制"></a>ref、out、in 使用限制</h1><p>async 修饰的异步方法中无法使用；<br>迭代器方法（含有 yield return 或 yield break 的方法）中无法使用；<br>扩展方法的第一个参数不能有 in 修饰符，除非该参数是结构体；<br>扩展方法的第一个参数，其中该参数是泛型类型（即使该类型被约束为结构体）；</p><h1 id="Equals-和-x3D-x3D"><a href="#Equals-和-x3D-x3D" class="headerlink" title="Equals 和 &#x3D;&#x3D;"></a>Equals 和 &#x3D;&#x3D;</h1><p>&#x3D;&#x3D; 值类型数据比较的是值，引用类型比较的是引用地址。<br>Equals 引用类型比较的是最终数据。</p><h1 id="as-和-is"><a href="#as-和-is" class="headerlink" title="as 和 is"></a>as 和 is</h1><p>is 判断对象是否兼容于某类型，返回 bool 值，永远不会抛出异常。<br>as 用于在兼容的引用类型之间执行转换。无法转换则为 null。<br>is 需要做两次对象的类型检查，而 as 需要做一次对象类型检查。</p><h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><p>public：共有的，访问不受限制；<br>private：私有的，只能在当前类中访问；<br>internal：内部的，只能在当前程序集中访问；<br>protected：受保护的，只能在当前类或其派生类中访问；<br>file：当前文件范围，C# 11 新增；<br>protected internal：受保护的内部成员，当前程序集或派生自包含类的类型可访问；<br>private protected：私有受保护的成员，当前程序集中的包含类或从包含类派生的类型可访问；<br>class 默认 internal，class member 默认 private。</p><h1 id="class-成员、interface-成员"><a href="#class-成员、interface-成员" class="headerlink" title="class 成员、interface 成员"></a>class 成员、interface 成员</h1><p>class 成员：字段、常量、属性、方法、事件、运算符、索引器、构造函数、终结器、嵌套类型。<br>interface 成员：方法、属性、索引器和事件</p><h1 id="类的执行顺序"><a href="#类的执行顺序" class="headerlink" title="类的执行顺序"></a>类的执行顺序</h1><p>父类，子类，静态块，静态字段，非静态块，非静态字段，构造器，方法</p><h1 id="数据类型和内存占用"><a href="#数据类型和内存占用" class="headerlink" title="数据类型和内存占用"></a>数据类型和内存占用</h1><p>1 byte bool、byte<br>2 byte char、short<br>4 byte int、float<br>8 byte long、double<br>16 byte decimal</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>编译时多态和运行时多态。</p><h2 id="编译时多态"><a href="#编译时多态" class="headerlink" title="编译时多态"></a>编译时多态</h2><p>重载编译时多态。根据签名不同分为不同的方法，编译后就成两个不同名函数。</p><h2 id="运行时多态"><a href="#运行时多态" class="headerlink" title="运行时多态"></a>运行时多态</h2><p>虚方法是运行时多态，父类中有虚方法，子类覆盖实现虚方法。</p><h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><p>在浅拷贝中，仅对顶级对象进行了复制，对低级别对象进行了引用。<br>在深拷贝中，会复制所有对象。</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>继承 ICloneable，实现 Clone()方法，方法中调用 MemberwiseClone()；<br>如果字段是值类型，则执行字段的按位复制；如果字段是引用类型，引用将复制，但被引用的对象不会被复制。</p><h1 id="协变和逆变"><a href="#协变和逆变" class="headerlink" title="协变和逆变"></a>协变和逆变</h1><p>in 逆变，out 协变。<br>赋值的兼容性，用在委托或者接口上。<br>需要<code>返回数据</code>，这种结构化的委托有效性之间的关系叫做协变，用 out 标记泛型类型。<br>需要<code>接受数据</code>，期望传入基类时允许传入派生对象的特性叫逆变，用 in 标记泛型类型。<br>协变：</p><ul><li>IEnumerable<out T></li><li>IEnumerator<out T></li><li>IQueryable<out T></li><li>IGrouping&lt;out TKey, out TElement&gt;</li></ul><p>逆变：</p><ul><li>IComparer<in T></li><li>IEqualityComparer<in T></li><li>IComparable<in T></li><li>Action<in T></li><li>Predicate<in T></li><li>Comparison<in T></li></ul><p>协变 + 逆变：</p><ul><li>TOutput Converter&lt;in TInput, out TOutput&gt;</li></ul><h1 id="object-和-dynamic"><a href="#object-和-dynamic" class="headerlink" title="object 和 dynamic"></a>object 和 dynamic</h1><p>object 是一种引用类型，表示 .NET 框架中的任何类型。它是所有引用类型的基类，允许将任何类型的对象存储在这个变量中。<br>dynamic 是 C# 中的一个关键字，在编译时将变量的类型指定为 dynamic ，对象的实际类型将在运行时确定，这在使用没有特定类型定义的 API 或库时非常有用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>object 是<code>基类</code>，可以存储任何引用类型；<br>dynamic 是<code>关键字</code>，在编译时跳过类型检查，在运行时确定类型。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>object 在我们不知道数据类型时很有用。<br>dynamic 更多是用在反射，支持动态语言，COM 对象调用以及获取 LINQ 的查询结果。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> a = <span class="string">&quot;Rohatash Kumar&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> a1 = a.ToString();</span><br><span class="line"></span><br><span class="line"><span class="built_in">dynamic</span> a = <span class="string">&quot;Rohatash Kumar&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> a1 = a;</span><br></pre></td></tr></table></figure><h1 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h1><ul><li>都能有默认实现；</li><li>都不能直接实例化；</li><li>抽象类单继承，接口多继承；</li><li>抽象类中可以有字段、属性、方法，接口中可以有属性、方法、索引器、事件，没有字段；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;string-Empty、-“”-、-null。&quot;&gt;&lt;a href=&quot;#string-Empty、-“”-、-null。&quot; class=&quot;headerlink&quot; title=&quot;string.Empty、 “” 、 null。&quot;&gt;&lt;/a&gt;string.Empty、 </summary>
      
    
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/categories/CSharp/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>HTML src 和 href</title>
    <link href="http://cencuansen.github.com/2023/02/14/web/HTML-src-and-href/"/>
    <id>http://cencuansen.github.com/2023/02/14/web/HTML-src-and-href/</id>
    <published>2023-02-14T14:27:46.000Z</published>
    <updated>2023-02-15T11:53:42.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用结果不同"><a href="#作用结果不同" class="headerlink" title="作用结果不同"></a>作用结果不同</h1><p>href 用于在当前文档和引用资源之间建立<code>联系</code>。<br>src 加载资源，<code>嵌入</code>相应元素中。</p><h1 id="浏览器解析方式不同"><a href="#浏览器解析方式不同" class="headerlink" title="浏览器解析方式不同"></a>浏览器解析方式不同</h1><p>href 浏览器会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。<br>src 会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，如图片(img)和框架(iframe)等，类似于将资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。</p><h1 id="请求资源类型不同"><a href="#请求资源类型不同" class="headerlink" title="请求资源类型不同"></a>请求资源类型不同</h1><p>href（Hypertext Reference，超文本引用）用来建立当前元素和文档之间的链接。如：link、a。<br>src 的资源，会将资源下载并应用到文档中，常用的有 script，img 、iframe。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;./style.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>click here<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://example.com/foo.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://example.com/bar.png&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;作用结果不同&quot;&gt;&lt;a href=&quot;#作用结果不同&quot; class=&quot;headerlink&quot; title=&quot;作用结果不同&quot;&gt;&lt;/a&gt;作用结果不同&lt;/h1&gt;&lt;p&gt;href 用于在当前文档和引用资源之间建立&lt;code&gt;联系&lt;/code&gt;。&lt;br&gt;src 加载资源，&lt;cod</summary>
      
    
    
    
    <category term="HTML" scheme="http://cencuansen.github.com/categories/HTML/"/>
    
    
    <category term="HTML" scheme="http://cencuansen.github.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Web 浏览器中网络请求过程</title>
    <link href="http://cencuansen.github.com/2023/02/14/web/Web-request-process-in-browser/"/>
    <id>http://cencuansen.github.com/2023/02/14/web/Web-request-process-in-browser/</id>
    <published>2023-02-14T14:21:06.000Z</published>
    <updated>2023-02-15T11:53:42.716Z</updated>
    
    <content type="html"><![CDATA[<ol><li>地址解析，提取出协议、域名、端口等信息等</li><li>通过 DNS 获取到 IP 地址</li><li>进行 TCP 连接(三次握手)<br>a. 第一次握手：建立连接时，客户端发送 syn(建立联机)包到服务器，并进入 syn_send 状态，等待服务器确认；<br>b. 第二次握手：服务器收到 syn 包，确认包信息，同时自己也发送一个 syn + ack(确认)包并进入 syn_recv 状态;<br>c. 第三次握手：客户端收到 syn+ack 包，向服务器发送 ack 包，发送完后，客户端和服务器都进入 established 状态，完成三次握手；</li><li>HTTP 请求</li><li>服务器响应请求</li><li>DOM 解析和渲染</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;地址解析，提取出协议、域名、端口等信息等&lt;/li&gt;
&lt;li&gt;通过 DNS 获取到 IP 地址&lt;/li&gt;
&lt;li&gt;进行 TCP 连接(三次握手)&lt;br&gt;a. 第一次握手：建立连接时，客户端发送 syn(建立联机)包到服务器，并进入 syn_send 状态，等待服务</summary>
      
    
    
    
    <category term="Web" scheme="http://cencuansen.github.com/categories/Web/"/>
    
    
    <category term="Web" scheme="http://cencuansen.github.com/tags/Web/"/>
    
    <category term="Request" scheme="http://cencuansen.github.com/tags/Request/"/>
    
  </entry>
  
  <entry>
    <title>Web DOM 的解析和渲染</title>
    <link href="http://cencuansen.github.com/2023/02/14/web/Web-dom-parsing-and-rendering/"/>
    <id>http://cencuansen.github.com/2023/02/14/web/Web-dom-parsing-and-rendering/</id>
    <published>2023-02-14T14:12:08.000Z</published>
    <updated>2023-02-15T11:53:42.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解析流程"><a href="#解析流程" class="headerlink" title="解析流程"></a>解析流程</h1><ol><li>解析 html，构建 <code>DOM Tree</code></li><li>解析 CSS，构建 <code>CSS Rule Tree</code></li><li>由 DOM Tree 和 CSS Rule Tree 生成 <code>Render Tree</code></li><li>利用 Render Tree 进行布局 <code>Layout</code>，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置</li><li><code>painting</code> 绘制 按照算出来的规则将内容绘制到屏幕上</li></ol><h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><p>问：DOM 树的构建是文档加载完成开始的？<br>答：不是，为更好用户体验，渲染引擎会尽快将内容进行显示，加载部分后就尝试解析、构建、布局、渲染。<br>问：Render 树是 DOM 树和 CSSOM 树构建完毕才开始构建的吗？<br>答：不是。三者交叉进行，一边加载，一边解析，一边渲染。<br>问：CSS 解析顺序？<br>答：选择器从右往左，DOM 树从下向上的解析顺序。嵌套标签越多解析越慢。<br>问：repaint 重绘？<br>答：改变元素背景色、前景色、边框色等，不影响文档中周边元素布局位置。<br>问：reflow 回流？<br>答：影响元素布局<code>位置变更</code>的操作，会导致回流，从根向下重新计算全部元素节点尺寸和位置，比如：元素显隐、元素尺寸变更、定位方式等，都会引起内部、周围、整个页面的重新渲染。通常无法预估页面哪部分会回流，它们都彼此相互影响着。频繁回流会影响性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;解析流程&quot;&gt;&lt;a href=&quot;#解析流程&quot; class=&quot;headerlink&quot; title=&quot;解析流程&quot;&gt;&lt;/a&gt;解析流程&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;解析 html，构建 &lt;code&gt;DOM Tree&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解析 CSS，构建 &lt;cod</summary>
      
    
    
    
    <category term="Web" scheme="http://cencuansen.github.com/categories/Web/"/>
    
    
    <category term="Web" scheme="http://cencuansen.github.com/tags/Web/"/>
    
    <category term="Dom" scheme="http://cencuansen.github.com/tags/Dom/"/>
    
    <category term="Dom Parsing" scheme="http://cencuansen.github.com/tags/Dom-Parsing/"/>
    
    <category term="Dom Rendering" scheme="http://cencuansen.github.com/tags/Dom-Rendering/"/>
    
  </entry>
  
  <entry>
    <title>HTML 块级格式化上下文</title>
    <link href="http://cencuansen.github.com/2023/02/14/web/HTML-block-formatting-context/"/>
    <id>http://cencuansen.github.com/2023/02/14/web/HTML-block-formatting-context/</id>
    <published>2023-02-14T11:53:32.000Z</published>
    <updated>2023-02-15T11:53:42.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>一个块级格式化上下文（<strong>B</strong>lock <strong>F</strong>ormatting <strong>C</strong>ontext），包含该上下文元素的所有<code>直接子元素</code>，但是不包括子元素的子元素。</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box-a&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bfc1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box-b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box-c&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bfc2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box-d&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>#bfc1</code> 的 BFC 指的是 <code>.box-b</code> 和 <code>.box-c</code>；<br><code>#bfc2</code> 的 BFC 指的是 <code>.box-d</code>；</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>每一个 BFC 区域只包括其子元素，不包括其子元素的子元素；</li><li>每一个 BFC 区域都是独立隔绝的，互不影响！</li></ul><h1 id="三种布局"><a href="#三种布局" class="headerlink" title="三种布局"></a>三种布局</h1><ul><li>标准流（normal）</li><li>浮动流（float）</li><li>定位流（position）</li></ul><h1 id="触发-BFC"><a href="#触发-BFC" class="headerlink" title="触发 BFC"></a>触发 BFC</h1><ul><li>body 根元素；</li><li>设置 float，不包括 none；</li><li>设置 position，包括 absoulte、fixed；</li><li>设置 display 为 inline-block；</li><li>设置 overflow，包括 hidden、auto、scroll；</li><li>表格单元格，table-cell；</li><li>弹性布局，flex；</li></ul><h1 id="BFC-实际应用"><a href="#BFC-实际应用" class="headerlink" title="BFC 实际应用"></a>BFC 实际应用</h1><h2 id="兄弟-div-margin-重叠"><a href="#兄弟-div-margin-重叠" class="headerlink" title="兄弟 div margin 重叠"></a>兄弟 div margin 重叠</h2><p>问题描述：文档中相邻 div 元素，上下分布，但两者 margin 默认会重叠。<br>解决思路：将相邻兄弟变成非相邻同级：把这两兄弟元素各用 div 包裹，触发包裹元素的 bfc。</p><h2 id="父子-div-margin-重叠"><a href="#父子-div-margin-重叠" class="headerlink" title="父子 div margin 重叠"></a>父子 div margin 重叠</h2><p>问题描述：文档中父子 div 元素，子 div margin-top 会让父子 div 同时下移。<br>解决思路：触发父级 bfc、父级设置边框。</p><h2 id="清除浮动影响"><a href="#清除浮动影响" class="headerlink" title="清除浮动影响"></a>清除浮动影响</h2><p>问题描述：父元素没设置高度，包含一个子元素，子元素设置浮动，父元素会高度塌陷。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;一个块级格式化上下文（&lt;strong&gt;B&lt;/strong&gt;lock &lt;strong&gt;F&lt;/strong&gt;ormatting &lt;strong&gt;</summary>
      
    
    
    
    <category term="HTML" scheme="http://cencuansen.github.com/categories/HTML/"/>
    
    
    <category term="HTML" scheme="http://cencuansen.github.com/tags/HTML/"/>
    
    <category term="BFC" scheme="http://cencuansen.github.com/tags/BFC/"/>
    
  </entry>
  
  <entry>
    <title>CSS transform、transition、animation</title>
    <link href="http://cencuansen.github.com/2023/02/14/css/CSS-transform-transition-animation/"/>
    <id>http://cencuansen.github.com/2023/02/14/css/CSS-transform-transition-animation/</id>
    <published>2023-02-14T11:41:16.000Z</published>
    <updated>2023-02-15T11:53:42.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h1><p><code>transform: [转换函数];</code><br>转换函数：translate、scale、rotate、skew。<br>transform 只影响当前元素，不影响文档流。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">1px</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">2px</span>);</span><br></pre></td></tr></table></figure><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>参考：<a href="https://www.bilibili.com/video/BV1L3411C76T">https://www.bilibili.com/video/BV1L3411C76T</a></p><ul><li>变换后盒子模型占据的尺寸和位置不会变换；</li><li>变换后会创建层叠上下文；</li><li>对内联元素无效；</li><li>不同顺序效果不同；</li><li>锯齿或虚化问题；</li></ul><h1 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h1><p>改变目标元素的样式：颜色、外观、尺寸，一般<code>搭配伪类</code>。<br>transition 尺寸变更会对文档流产生影响。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">0.4s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者用 JavaScript 改变元素属性触发 transition</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blueviolet;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">1s</span> linear <span class="number">0.5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;box1&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><ul><li>transition 需要触发，没法在网页加载时自动发生。</li><li>transition 是一次性的，不能重复发生，除非一再触发。</li><li>transition 只能定义开始状态和结束状态，不能定义中间状态。</li><li>一条 transition 规则，只能定义一个属性的变化，不能涉及多个属性。</li></ul><h1 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h1><p>transition 不够用的时候，可以使用 animation。<br>animation 搭配 <code>@keyframes</code> 使用，无需搭配伪类，页面加载 animation 就自动开始了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.animation1</span> &#123;</span><br><span class="line">  <span class="comment">/* forwards：动画结束时，就停在最终状态 */</span></span><br><span class="line">  <span class="attribute">animation</span>: changeAnimation <span class="number">1s</span> ease forwards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.animation2</span> &#123;</span><br><span class="line">  <span class="comment">/* infinite alternate：无限循环 + 往复 */</span></span><br><span class="line">  <span class="attribute">animation</span>: changeAnimation <span class="number">1s</span> ease infinite alternate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> changeAnimation &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">110px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">140px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;transform&quot;&gt;&lt;a href=&quot;#transform&quot; class=&quot;headerlink&quot; title=&quot;transform&quot;&gt;&lt;/a&gt;transform&lt;/h1&gt;&lt;p&gt;&lt;code&gt;transform: [转换函数];&lt;/code&gt;&lt;br&gt;转换函数：tr</summary>
      
    
    
    
    <category term="CSS" scheme="http://cencuansen.github.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://cencuansen.github.com/tags/CSS/"/>
    
    <category term="transform" scheme="http://cencuansen.github.com/tags/transform/"/>
    
    <category term="transition" scheme="http://cencuansen.github.com/tags/transition/"/>
    
    <category term="animation" scheme="http://cencuansen.github.com/tags/animation/"/>
    
  </entry>
  
  <entry>
    <title>CSS 伪类和伪元素</title>
    <link href="http://cencuansen.github.com/2023/02/14/css/CSS-pseudo-classes-and-pseudo-elements/"/>
    <id>http://cencuansen.github.com/2023/02/14/css/CSS-pseudo-classes-and-pseudo-elements/</id>
    <published>2023-02-14T09:35:15.000Z</published>
    <updated>2023-02-15T11:53:42.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h1><p>功能和 class 有些类似，但它是基于文档之外的抽象，所以叫伪类。</p><p>:link、:visited、:hover、:active、:focus、:right、:left、:first、:lang、:first-child</p><h1 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h1><p>伪元素是 DOM 树没有定义的虚拟元素。</p><p>::before、::after、::selection</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;伪类&quot;&gt;&lt;a href=&quot;#伪类&quot; class=&quot;headerlink&quot; title=&quot;伪类&quot;&gt;&lt;/a&gt;伪类&lt;/h1&gt;&lt;p&gt;功能和 class 有些类似，但它是基于文档之外的抽象，所以叫伪类。&lt;/p&gt;
&lt;p&gt;:link、:visited、:hover、:activ</summary>
      
    
    
    
    <category term="CSS" scheme="http://cencuansen.github.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://cencuansen.github.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS 选择第二个以及后续元素</title>
    <link href="http://cencuansen.github.com/2023/02/14/css/CSS-select-children-between-2nd-and-last/"/>
    <id>http://cencuansen.github.com/2023/02/14/css/CSS-select-children-between-2nd-and-last/</id>
    <published>2023-02-14T09:28:47.000Z</published>
    <updated>2023-02-15T11:53:42.714Z</updated>
    
    <content type="html"><![CDATA[<p>元素如下，希望除了第一个子 div 不选择，其他子 div 都选择。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-4&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式一</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-of-type</span>(n + <span class="number">2</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-child</span>(n + <span class="number">2</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;元素如下，希望除了第一个子 div 不选择，其他子 div 都选择。&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    <category term="CSS" scheme="http://cencuansen.github.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://cencuansen.github.com/tags/CSS/"/>
    
    <category term="Selector" scheme="http://cencuansen.github.com/tags/Selector/"/>
    
  </entry>
  
  <entry>
    <title>CSS 1像素线</title>
    <link href="http://cencuansen.github.com/2023/02/14/css/CSS-1px-line/"/>
    <id>http://cencuansen.github.com/2023/02/14/css/CSS-1px-line/</id>
    <published>2023-02-14T09:21:43.000Z</published>
    <updated>2023-02-15T11:53:42.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>移动端开发线条的 1 像素线绘制。</p><h1 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h1><ul><li>用 0.5px</li><li>transform scale</li><li>box-shadow 模拟</li><li>图片</li></ul><h2 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>, <span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h1&gt;&lt;p&gt;移动端开发线条的 1 像素线绘制。&lt;/p&gt;
&lt;h1 id=&quot;方式&quot;&gt;&lt;a href=&quot;#方式&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="CSS" scheme="http://cencuansen.github.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://cencuansen.github.com/tags/CSS/"/>
    
    <category term="CSS Tricks" scheme="http://cencuansen.github.com/tags/CSS-Tricks/"/>
    
  </entry>
  
</feed>
