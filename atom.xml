<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>San Huo</title>
  
  <subtitle>纤凝翠薇巅，扶光入沧渊，扶摇惊砂起，山弄望舒远</subtitle>
  <link href="http://cencuansen.github.com/atom.xml" rel="self"/>
  
  <link href="http://cencuansen.github.com/"/>
  <updated>2023-02-14T15:40:56.269Z</updated>
  <id>http://cencuansen.github.com/</id>
  
  <author>
    <name>San Huo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSharp dispose</title>
    <link href="http://cencuansen.github.com/2023/02/14/CSharp-dispose/"/>
    <id>http://cencuansen.github.com/2023/02/14/CSharp-dispose/</id>
    <published>2023-02-14T15:37:48.000Z</published>
    <updated>2023-02-14T15:40:56.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDisposable-Dispose"><a href="#IDisposable-Dispose" class="headerlink" title="IDisposable.Dispose"></a>IDisposable.Dispose</h1><p>对于<code>非托管资源</code>建立和释放，C# 约定由 Dispose 方法来处理。<br>当类库中涉及到非托管资源，就应实现 Dispose 方法，来定义资源释放逻辑。<br>using 用来管理实现了 Dispose 方法的类，编译器会在作用域结束时调用 Dispose 方法。<br>非托管资源包括：网络请求，数据库连接，句柄等。</p><h1 id="标准-dispose-模式"><a href="#标准-dispose-模式" class="headerlink" title="标准 dispose 模式"></a>标准 dispose 模式</h1><ol><li>析构函数中调用 dispose 方法，托底防忘记调用；</li><li>dispose 中最后要调用 GC.SuppressFinaliza 方法，通知 CLR 无需执行析构函数，因为清除工作已完成；</li><li>多次调用 dispose 应该是安全的，dispose 方法调用后，后续再调用都不会执行额外的工作；</li><li>dispose 方法有 2 个重载：public 和 protected，protected 真实清除，public 调用 protected；</li><li>析构函数调用 protected；</li><li>protected 的 bool 参数区分是被析构函数调用（false）还是被 public 调用（true）；</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyConsole.DisposeDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用于模拟一个托管资源</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeManagedResource</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SomeManagedResource</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用于模拟一个非托管资源</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyUnmanagedResource</span> : <span class="title">IDisposable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 模拟一个非托管资源</span></span><br><span class="line">        <span class="keyword">private</span> IntPtr someUnmanagedResource = Marshal.AllocHGlobal(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 模拟一个托管资源</span></span><br><span class="line">        <span class="keyword">private</span> SomeManagedResource managedResource = <span class="keyword">new</span> SomeManagedResource(<span class="string">&quot;这是托管资源&quot;</span>);</span><br><span class="line">        <span class="comment">// 是否被清理过的标识</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">bool</span> baseDisposed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Dispose(<span class="literal">true</span>);</span><br><span class="line">            GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> isDisposing</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">// 确保多次执行的安全性</span></span><br><span class="line">            <span class="keyword">if</span> (baseDisposed)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 被 public 调用，需要额外清理托管资源</span></span><br><span class="line">            <span class="keyword">if</span> (isDisposing)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 要调用 SuppressFinaliza，需手动清理托管资源, 否则无法释放。</span></span><br><span class="line">                <span class="keyword">if</span> (managedResource != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">                    managedResource = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清理非托管资源</span></span><br><span class="line">            <span class="keyword">if</span> (someUnmanagedResource != IntPtr.Zero)</span><br><span class="line">            &#123;</span><br><span class="line">                Marshal.FreeHGlobal(someUnmanagedResource);</span><br><span class="line">                someUnmanagedResource = IntPtr.Zero;</span><br><span class="line">            &#125;</span><br><span class="line">            baseDisposed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 必须，以防忘记调用 Dispose 方法的托底方法</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        ~MyUnmanagedResource()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 必须为false</span></span><br><span class="line">            Dispose(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Finalize"><a href="#Finalize" class="headerlink" title="Finalize"></a>Finalize</h1><ol><li>无法显式的重写 Finalize 方法，只能通过析构函数语法形式来实现。</li><li>struct 中不允许定义析构函数，只有 class 中才可以，并且只能有一个。</li><li>Finalize 方法不能被继承或重载。</li><li>执行垃圾回收之前系统会自动执行 Finalize 操作。</li><li>Finalize 方法会极大地损伤性能。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IDisposable-Dispose&quot;&gt;&lt;a href=&quot;#IDisposable-Dispose&quot; class=&quot;headerlink&quot; title=&quot;IDisposable.Dispose&quot;&gt;&lt;/a&gt;IDisposable.Dispose&lt;/h1&gt;&lt;p&gt;对于</summary>
      
    
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/categories/CSharp/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term="Dispose" scheme="http://cencuansen.github.com/tags/Dispose/"/>
    
  </entry>
  
  <entry>
    <title>CSharp 简单应用</title>
    <link href="http://cencuansen.github.com/2023/02/14/CSharp-usage/"/>
    <id>http://cencuansen.github.com/2023/02/14/CSharp-usage/</id>
    <published>2023-02-14T15:27:46.000Z</published>
    <updated>2023-02-14T15:37:00.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stream <span class="title">QRCodeStream</span>(<span class="params"><span class="built_in">string</span> contents</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    QRCodeGenerator qrGenerator = <span class="keyword">new</span> QRCodeGenerator();</span><br><span class="line">    QRCodeData qrCodeData = qrGenerator.CreateQrCode(contents, QRCodeGenerator.ECCLevel.L);</span><br><span class="line">    QRCode qrCode = <span class="keyword">new</span> QRCode(qrCodeData);</span><br><span class="line">    Bitmap bigMap = qrCode.GetGraphic(<span class="number">20</span>, Color.Black, Color.White, <span class="literal">true</span>);</span><br><span class="line">    MemoryStream stream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line">    bigMap.Save(stream, System.Drawing.Imaging.ImageFormat.Png);</span><br><span class="line">    stream.Position = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拼接图片"><a href="#拼接图片" class="headerlink" title="拼接图片"></a>拼接图片</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> file1 = <span class="string">@&quot;C:\Users\Admin\Desktop\images\1.png&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> file2 = <span class="string">@&quot;C:\Users\Admin\Desktop\images\2.png&quot;</span>;</span><br><span class="line">Image image1 = Image.FromStream(<span class="keyword">new</span> MemoryStream(File.ReadAllBytes(file1)));</span><br><span class="line">Image image2 = Image.FromStream(<span class="keyword">new</span> MemoryStream(File.ReadAllBytes(file2)));</span><br><span class="line"><span class="keyword">var</span> image1Width = image1.Width;</span><br><span class="line"><span class="keyword">var</span> image1Height = image1.Height;</span><br><span class="line"><span class="keyword">var</span> image2Width = image2.Height;</span><br><span class="line"><span class="keyword">var</span> image2Height = image2.Height;</span><br><span class="line"><span class="keyword">var</span> stream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line"><span class="keyword">using</span> Bitmap map = <span class="keyword">new</span> Bitmap(image1Width, image1Height);<span class="comment">//定义画布</span></span><br><span class="line">Graphics g = Graphics.FromImage(map);<span class="comment">//定义画笔</span></span><br><span class="line">g.Clear(Color.White);<span class="comment">//把画布更改为白色</span></span><br><span class="line">g.DrawImage(image1, <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">g.DrawImage(image2, <span class="keyword">new</span> Point(image1Width - image2Width, image1Height - image2Height));</span><br><span class="line">map.Save(stream, ImageFormat.Jpeg);</span><br></pre></td></tr></table></figure><h1 id="端口占用检查"><a href="#端口占用检查" class="headerlink" title="端口占用检查"></a>端口占用检查</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;请输入需要检测的端口号(如：80), 输入exit退出此程序&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> inPortString = Console.ReadLine();</span><br><span class="line">  Process process = <span class="keyword">new</span> Process();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (inPortString == <span class="string">&quot;exit&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    process.Close();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> port = <span class="number">80</span>;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrWhiteSpace(inPortString))</span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;输入端口号非法，将查询默认端口号：80&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      port = Convert.ToInt32(inPortString);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception e)</span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;输入端口号非法，将查询默认端口号：80&quot;</span>);</span><br><span class="line">    port = <span class="number">80</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  process.StartInfo.FileName = <span class="string">&quot;cmd.exe&quot;</span>;</span><br><span class="line">  process.StartInfo.UseShellExecute = <span class="literal">false</span>;</span><br><span class="line">  process.StartInfo.RedirectStandardInput = <span class="literal">true</span>;</span><br><span class="line">  process.StartInfo.RedirectStandardOutput = <span class="literal">true</span>;</span><br><span class="line">  process.StartInfo.RedirectStandardError = <span class="literal">true</span>;</span><br><span class="line">  process.StartInfo.CreateNoWindow = <span class="literal">true</span>;</span><br><span class="line">  process.Start();</span><br><span class="line">  process.StandardInput.WriteLine(<span class="string">&quot;netstat -ano&quot;</span>);</span><br><span class="line">  process.StandardInput.WriteLine(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">  Regex reg = <span class="keyword">new</span> Regex(<span class="string">&quot;\\s+&quot;</span>, RegexOptions.Compiled);</span><br><span class="line">  <span class="built_in">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">string</span> line = <span class="built_in">string</span>.Empty;</span><br><span class="line">  <span class="keyword">while</span> ((line = process.StandardOutput.ReadLine()) != <span class="literal">null</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    line = line.Trim();</span><br><span class="line">    <span class="keyword">if</span> (line.StartsWith(<span class="string">&quot;TCP&quot;</span>, StringComparison.OrdinalIgnoreCase))</span><br><span class="line">    &#123;</span><br><span class="line">      line = reg.Replace(line, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">      <span class="built_in">string</span>[] arr = line.Split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (arr[<span class="number">1</span>].EndsWith(<span class="string">$&quot;:<span class="subst">&#123;port&#125;</span>&quot;</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        found = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">int</span> pid = <span class="built_in">int</span>.Parse(arr[<span class="number">4</span>]);</span><br><span class="line">        Process foundProcess = Process.GetProcessById(pid);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;port&#125;</span>端口. pid：<span class="subst">&#123;pid&#125;</span>, 进程名：<span class="subst">&#123;foundProcess.ProcessName&#125;</span>\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!found)</span><br><span class="line">  &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;未找到<span class="subst">&#123;port&#125;</span>端口上的进程\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  process.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="byte-、string、stream-间转换"><a href="#byte-、string、stream-间转换" class="headerlink" title="byte[]、string、stream 间转换"></a>byte[]、string、stream 间转换</h1><h2 id="stream-gt-string"><a href="#stream-gt-string" class="headerlink" title="stream -&gt; string"></a>stream -&gt; string</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> StreamReader reader = <span class="keyword">new</span> StreamReader(stream);</span><br><span class="line"><span class="built_in">string</span> result = reader.ReadToEnd();</span><br></pre></td></tr></table></figure><h2 id="string-gt-stream"><a href="#string-gt-stream" class="headerlink" title="string -&gt; stream"></a>string -&gt; stream</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> test = <span class="string">&quot;This is string&quot;</span>;</span><br><span class="line"><span class="keyword">using</span> MemoryStream stream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line"><span class="keyword">using</span> StreamWriter writer = <span class="keyword">new</span> StreamWriter( stream );</span><br><span class="line">writer.Write( test );</span><br><span class="line">writer.Flush();</span><br></pre></td></tr></table></figure><h2 id="byte-gt-string"><a href="#byte-gt-string" class="headerlink" title="byte[] -&gt; string"></a>byte[] -&gt; string</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = System.Text.Encoding.Default.GetString( byteArray );</span><br></pre></td></tr></table></figure><h2 id="string-gt-byte"><a href="#string-gt-byte" class="headerlink" title="string -&gt; byte[]"></a>string -&gt; byte[]</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>[] byteArray = System.Text.Encoding.Default.GetBytes( str );</span><br></pre></td></tr></table></figure><h2 id="stream-gt-byte"><a href="#stream-gt-byte" class="headerlink" title="stream -&gt; byte[]"></a>stream -&gt; byte[]</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">byte</span>[] bytes = <span class="keyword">new</span> <span class="built_in">byte</span>[stream.Length];</span><br><span class="line">stream.Read(bytes, <span class="number">0</span>, bytes.Length);</span><br></pre></td></tr></table></figure><h2 id="byte-gt-stream"><a href="#byte-gt-stream" class="headerlink" title="byte[] -&gt; stream"></a>byte[] -&gt; stream</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Stream stream = <span class="keyword">new</span> MemoryStream(bytes);</span><br></pre></td></tr></table></figure><h1 id="文本长度"><a href="#文本长度" class="headerlink" title="文本长度"></a>文本长度</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> strTmp = <span class="string">&quot;a1某某某&quot;</span>;</span><br><span class="line"><span class="comment">// 10，Unicode下中英文每个字2字节。</span></span><br><span class="line"><span class="built_in">int</span> len1 = System.Text.Encoding.Unicode.GetBytes(strTmp).Length;</span><br><span class="line"><span class="comment">// 11，Default 等价与 UTF8，中文3个字节，英文1个字节</span></span><br><span class="line"><span class="built_in">int</span> len2 = System.Text.Encoding.Default.GetBytes(strTmp).Length;</span><br><span class="line"><span class="built_in">int</span> len3 = System.Text.Encoding.UTF8.GetBytes(strTmp).Length;</span><br><span class="line"><span class="comment">// 5，就是个数</span></span><br><span class="line"><span class="built_in">int</span> len4 = System.Text.Encoding.Default.GetBytes(strTmp).Length;</span><br></pre></td></tr></table></figure><h1 id="WebSocket-应用"><a href="#WebSocket-应用" class="headerlink" title="WebSocket 应用"></a>WebSocket 应用</h1><h2 id="Startup-Configure"><a href="#Startup-Configure" class="headerlink" title="Startup.Configure"></a>Startup.Configure</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.UseWebSockets();</span><br></pre></td></tr></table></figure><h2 id="Controller-cs"><a href="#Controller-cs" class="headerlink" title="Controller.cs"></a>Controller.cs</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet(<span class="string">&quot;receive-message&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">GetMessage</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (HttpContext.WebSockets.IsWebSocketRequest)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> webSocket = <span class="keyword">await</span> HttpContext.WebSockets.AcceptWebSocketAsync())</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;WebSocket connection established&quot;</span>);</span><br><span class="line">            <span class="keyword">await</span> Echo(webSocket);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        HttpContext.Response.StatusCode = <span class="number">400</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">Echo</span>(<span class="params">WebSocket webSocket</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span> * <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> webSocket.ReceiveAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(buffer), CancellationToken.None);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Message received from Client&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!result.CloseStatus.HasValue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> serverMsg = Encoding.UTF8.GetBytes(<span class="string">$&quot;Server: Hello. You said: <span class="subst">&#123;Encoding.UTF8.GetString(buffer)&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">await</span> webSocket.SendAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(serverMsg, <span class="number">0</span>, serverMsg.Length), result.MessageType, result.EndOfMessage, CancellationToken.None);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Message sent to Client&quot;</span>);</span><br><span class="line">        result = <span class="keyword">await</span> webSocket.ReceiveAsync(<span class="keyword">new</span> ArraySegment&lt;<span class="built_in">byte</span>&gt;(buffer), CancellationToken.None);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Message received from Client&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> webSocket.CloseAsync(result.CloseStatus.Value, result.CloseStatusDescription, CancellationToken.None);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;WebSocket connection closed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var socket = new WebSocket(&#x27;wss://localhost:6666/receive-message&#x27;);</span><br><span class="line">socket.send(&#x27;前端消息&#x27;);</span><br></pre></td></tr></table></figure><h1 id="HTTP-网络请求"><a href="#HTTP-网络请求" class="headerlink" title="HTTP 网络请求"></a>HTTP 网络请求</h1><p>HttpWebRequest：最早，不阻塞 ui，细节控制；<br>WebClient：对 HttpWebRequest 的简化和封装；<br>HttpClient：.NET 4.5 开始，预热机制，适合发送多次请求；</p><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> httpClientHandler = <span class="keyword">new</span> HttpClientHandler</span><br><span class="line">&#123;</span><br><span class="line">  Proxy = <span class="keyword">new</span> WebProxy(<span class="string">&quot;http://127.0.0.1:1080&quot;</span>, <span class="literal">false</span>),<span class="comment">// 设置代理</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient(httpClientHandler);</span><br><span class="line"><span class="keyword">var</span> response = <span class="keyword">await</span> httpClient.GetAsync(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> responseText = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br></pre></td></tr></table></figure><p>HttpClient 存在 Dispose 后不能立即释放对应套接字问题，默认需要 4 分钟去释放。<br>可以创建一个 HttpClient 实例，把它存储在一个静态字段中，或者使用 HttpClientFactory，<a href="url=https://www.oschina.net/news/77036/httpclient">相关文章</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;生成二维码&quot;&gt;&lt;a href=&quot;#生成二维码&quot; class=&quot;headerlink&quot; title=&quot;生成二维码&quot;&gt;&lt;/a&gt;生成二维码&lt;/h1&gt;&lt;figure class=&quot;highlight c#&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</summary>
      
    
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/categories/CSharp/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>CSharp .NET 和 C#</title>
    <link href="http://cencuansen.github.com/2023/02/14/CSharp-dotnet-and-csharp/"/>
    <id>http://cencuansen.github.com/2023/02/14/CSharp-dotnet-and-csharp/</id>
    <published>2023-02-14T15:21:07.000Z</published>
    <updated>2023-02-14T15:25:54.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-和-NET"><a href="#C-和-NET" class="headerlink" title="C# 和 .NET"></a>C# 和 .NET</h1><table><thead><tr><th>语言版本</th><th>发布时间</th><th>.NET Framework 要求</th><th>Visual Studio 版本</th></tr></thead><tbody><tr><td>C# 1.0</td><td>2002.1</td><td>.NET Framework 1.0</td><td>Visual Studio .NET 2002</td></tr><tr><td>C# 1.1&#x2F;1.2</td><td>2003.4</td><td>.NET Framework 1.1</td><td>Visual Studio .NET 2003</td></tr><tr><td>C# 2.0</td><td>2005.11</td><td>.NET Framework 2.0</td><td>Visual Studio 2005</td></tr><tr><td>C# 3.0</td><td>2007.11</td><td>.NET Framework 2.0&#x2F;3.0&#x2F;3.5</td><td>Visual Studio 2008</td></tr><tr><td>C# 4.0</td><td>2010.4</td><td>.NET Framework 4.0</td><td>Visual Studio 2010</td></tr><tr><td>C# 5.0</td><td>2012.8</td><td>.NET Framework 4.5</td><td>Visual Studio 2012&#x2F;2013</td></tr><tr><td>C# 6.0</td><td>2015.7</td><td>.NET Framework 4.6</td><td>Visual Studio 2015</td></tr><tr><td>C# 7.0</td><td>2017.3</td><td>.NET Framework 4.6.2</td><td>Visual Studio 2017</td></tr><tr><td>C# 7.1</td><td>2017.6</td><td>.NET Framework 4.7</td><td>Visual Studio 2017 v15.3 预览版</td></tr><tr><td>C# 7.2</td><td>2017.11</td><td>.NET Framework 4.7.1</td><td>Visual Studio 2017 v15.5</td></tr><tr><td>C# 7.3</td><td>2018.5</td><td>.NET Framework 4.7.2</td><td>Visual Studion 2017 v15.7</td></tr><tr><td>C# 8.0</td><td>2019.04.18</td><td>.NET Framework 4.8&#x2F;.NET Core 3&#x2F;3.1</td><td>Visual Studion 2019</td></tr><tr><td>C# 9</td><td>2020.09.04</td><td>.NET 5</td><td>Visual Studion 2019</td></tr><tr><td>C# 10.0</td><td>2021.11.09</td><td>.NET 6</td><td>Visual Studion 2022</td></tr><tr><td>C# 11</td><td>2022.11.8</td><td>.NET 7</td><td>Visual Studion 2022</td></tr></tbody></table><h1 id="C-版本及其语言特性"><a href="#C-版本及其语言特性" class="headerlink" title="C# 版本及其语言特性"></a>C# 版本及其语言特性</h1><h2 id="C-1-0-2002-年-01-月"><a href="#C-1-0-2002-年-01-月" class="headerlink" title="C# 1.0 [2002 年 01 月]"></a>C# 1.0 [2002 年 01 月]</h2><p>类、结构、接口、事件、属性、委托，运算符和表达式、语句、特性</p><h2 id="C-2-0-2005-年-11-月"><a href="#C-2-0-2005-年-11-月" class="headerlink" title="C# 2.0 [2005 年 11 月]"></a>C# 2.0 [2005 年 11 月]</h2><p>泛型、Partial 类型、匿名方法、迭代器、可空类型、私有 setters、方法组转化(delegates)、协变和逆变、静态类</p><h2 id="C-3-0-2007-年-11-月"><a href="#C-3-0-2007-年-11-月" class="headerlink" title="C# 3.0 [2007 年 11 月]"></a>C# 3.0 [2007 年 11 月]</h2><p>隐式类型的局部变量(var)、对象与集合初始化器、自动实现属性(get;set;)、Partial 方法、匿名类、扩展方法、LINQ、Lambda 表达式、表达式树<br><a href="https://msdn.microsoft.com/en-us/library/bb308966.aspx">https://msdn.microsoft.com/en-us/library/bb308966.aspx</a></p><h2 id="C-4-0-2010-年-04-月"><a href="#C-4-0-2010-年-04-月" class="headerlink" title="C# 4.0 [2010 年 04 月]"></a>C# 4.0 [2010 年 04 月]</h2><p>动态绑定(dynamic)、命名参数和可选参数、泛型协变和逆变、嵌入式互操作类型<br><a href="https://msdn.microsoft.com/en-us/magazine/ff796223.aspx">https://msdn.microsoft.com/en-us/magazine/ff796223.aspx</a></p><h2 id="C-5-0-2012-年-08-月"><a href="#C-5-0-2012-年-08-月" class="headerlink" title="C# 5.0 [2012 年 08 月]"></a>C# 5.0 [2012 年 08 月]</h2><p>异步特性(async &amp; await)、调用者信息<br><a href="https://learn.microsoft.com/zh-cn/archive/blogs/mvpawardprogram/an-introduction-to-new-features-in-c-5-0">https://learn.microsoft.com/zh-cn/archive/blogs/mvpawardprogram/an-introduction-to-new-features-in-c-5-0</a></p><h2 id="C-6-0-2015-年-07-月"><a href="#C-6-0-2015-年-07-月" class="headerlink" title="C# 6.0 [2015 年 07 月]"></a>C# 6.0 [2015 年 07 月]</h2><p>表达式为主体的成员方法和只读属性、属性初始化赋值、nameof 表达式、Await in catch block、异常过滤器(when)、字符串插值<br><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6">https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6</a></p><h2 id="C-7-0-2017-年-03-月"><a href="#C-7-0-2017-年-03-月" class="headerlink" title="C# 7.0 [2017 年 03 月]"></a>C# 7.0 [2017 年 03 月]</h2><p>out variables、Tuples、Discards、Pattern Matching、局部方法、Generalized async return types<br><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7">https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7</a></p><h2 id="C-8-0-2019-年-04-月"><a href="#C-8-0-2019-年-04-月" class="headerlink" title="C# 8.0 [2019 年 04 月]"></a>C# 8.0 [2019 年 04 月]</h2><p>Readonly members、默认接口方法、Using declarations、静态局部方法、Disposable ref structs、可空引用类型<br><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8">https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8</a></p><h2 id="C-9-0-2020-年-09-月"><a href="#C-9-0-2020-年-09-月" class="headerlink" title="C# 9.0 [2020 年 09 月]"></a>C# 9.0 [2020 年 09 月]</h2><p>Records、Init-only properties、Top-level statements、Init accessors and readonly fields、With 表达式、Value-based equality、Primary constructor<br><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9">https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9</a></p><h2 id="C-10-0-2021-年-11-月"><a href="#C-10-0-2021-年-11-月" class="headerlink" title="C# 10.0 [2021 年 11 月]"></a>C# 10.0 [2021 年 11 月]</h2><p>Record structs、Global using directives、File-scoped namespace declaration、Extended Proptery Patterns、Null Parameter Checking、Constant interpolated strings<br><a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10">https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10</a></p><h2 id="C-11-0-2022-年-11-月"><a href="#C-11-0-2022-年-11-月" class="headerlink" title="C# 11.0 [2022 年 11 月]"></a>C# 11.0 [2022 年 11 月]</h2><p>原生字符串字面量、Generic math support、泛型 attributes、UTF-8 字符串字面量、Newlines in string interpolation expressions、List patterns、file 类修饰符、Required members、Auto-default structs、Pattern match Span<char> on a constant string、Extended nameof scope、Numeric IntPtr、ref fields and scoped ref、Improved method group conversion to delegate、Warning wave 7<br><a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11">https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11</a><br>综合<br><a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history">https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-和-NET&quot;&gt;&lt;a href=&quot;#C-和-NET&quot; class=&quot;headerlink&quot; title=&quot;C# 和 .NET&quot;&gt;&lt;/a&gt;C# 和 .NET&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;语言版本&lt;/th&gt;
&lt;th&gt;发布时间&lt;/th&gt;
</summary>
      
    
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/categories/CSharp/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
    <category term=".NET" scheme="http://cencuansen.github.com/tags/NET/"/>
    
    <category term="Features" scheme="http://cencuansen.github.com/tags/Features/"/>
    
  </entry>
  
  <entry>
    <title>CSharp 基础知识</title>
    <link href="http://cencuansen.github.com/2023/02/14/CSharp-basic-concepts/"/>
    <id>http://cencuansen.github.com/2023/02/14/CSharp-basic-concepts/</id>
    <published>2023-02-14T14:49:07.000Z</published>
    <updated>2023-02-14T15:19:05.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="string-Empty、-quot-quot-、-null。"><a href="#string-Empty、-quot-quot-、-null。" class="headerlink" title="string.Empty、&quot;&quot;、 null。"></a>string.Empty、<code>&quot;&quot;</code>、 null。</h1><p>Empty 是 string 类中的一个静态的只读字段。<br>string.Empty 和<code>&quot;&quot;</code>是一样的。<br>string str &#x3D; null 表示 str 未指向任何对象。</p><h1 id="string-和-StringBuilder"><a href="#string-和-StringBuilder" class="headerlink" title="string 和 StringBuilder"></a>string 和 StringBuilder</h1><p>string 是不可变对象，string 是 String 的别名，string 是 c#中的类，String 是 Framework 的类，编译器会把 string 编译成 String。<br>StringBuilder 为动态字符串。StringBuilder 当达到容量时，将自动分配新的空间且容量翻倍。</p><h1 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h1><p>向现有类型“添加”方法，无需派生、重新编译或修改原始类型。<br>扩展方法是一种静态类中的静态方法。<br>扩展方法第一个参数是 this 修饰的被扩展的类。</p><h1 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h1><p>装箱：值类型 -&gt; 引用类型 。<br>拆箱：引用类型 -&gt; 值类型。<br>一次装箱要分配内存（托管堆）和拷贝数据（从栈到托管堆）。<br>拆箱就是装箱的相反操作。</p><h1 id="更改已装箱的对象"><a href="#更改已装箱的对象" class="headerlink" title="更改已装箱的对象"></a>更改已装箱的对象</h1><p>已装箱的对象，无法直接调用其指定方法。<br>让类对象继承一个接口，借助接口方式来更改已装箱的对象中的数据。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISomeClass</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Change</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeClass</span> : <span class="title">ISomeClass</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span> x &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Change</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SomeClass some = <span class="keyword">new</span> SomeClass();</span><br><span class="line">some.x = <span class="number">100</span>;</span><br><span class="line">Object o = some; <span class="comment">// 装箱</span></span><br><span class="line">((SomeClass)o).Change(<span class="number">200</span>); <span class="comment">// 没改掉。</span></span><br><span class="line">((ISomeClass)o).Change(<span class="number">200</span>); <span class="comment">// 改掉了。</span></span><br></pre></td></tr></table></figure><h1 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h1><ul><li>运算符：创建对象实例。</li><li>修饰符：在派生类定义一个重名的方法，隐藏基类方法。</li><li>约束：泛型约束，表示泛型类型要有 public 修饰的无参构造。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ItemFactory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">IComparable</span>, <span class="title">new</span>()</span><br><span class="line">&#123;  &#125;</span><br></pre></td></tr></table></figure><h1 id="new-和-override"><a href="#new-和-override" class="headerlink" title="new 和 override"></a>new 和 override</h1><p>new 和 override 都可用覆盖基类同名方法；<br>new 覆盖基类不完全，父类引用子类实例时，能调用到基类方法，override 覆盖基类是彻底的，一旦子类 override 基类方法后，就无法再调用基类同名方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">Say</span> ()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I am parent&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Child1</span> : <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">Say</span> ()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I am child1&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Child2</span> : <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">new</span> <span class="built_in">string</span> <span class="title">Say</span> ()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I am child2&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类引用子类实例</span></span><br><span class="line">Parent instance1 = <span class="keyword">new</span> Child1();</span><br><span class="line"><span class="comment">// I am child1</span></span><br><span class="line"><span class="built_in">string</span> who1 = instance1.Say();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类引用子类实例</span></span><br><span class="line">Parent instance2 = <span class="keyword">new</span> Child2();</span><br><span class="line"><span class="comment">// 注意，这里就能调用到基类方法，结果为：I am parent</span></span><br><span class="line"><span class="built_in">string</span> who1 = instance2.Say();</span><br></pre></td></tr></table></figure><h1 id="int-和-int"><a href="#int-和-int" class="headerlink" title="int? 和 int"></a>int? 和 int</h1><p>可空类型，默认值可以是 null。<br>int? 是通过 int 装箱为引用类型实现。<br><code>Nullable.GetUnderlyingType(typeof(int?)) != null</code> 用来判断类型是否是可空类型</p><h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>约定方法签名，来对方法进行引用，类似指针，方法能当参数传递给形参，用于事件、回调等。</p><h1 id="const-和-readonly"><a href="#const-和-readonly" class="headerlink" title="const 和 readonly"></a>const 和 readonly</h1><p>readonly 运行时常量。<br>const 编译时常量。<br>readonly 常量只能声明为类字段。<br>const 除了类字段，还可以声明为方法中的局部常量，默认为静态类型，不能用 static 修饰。</p><h1 id="CTS、CLS、CLR"><a href="#CTS、CLS、CLR" class="headerlink" title="CTS、CLS、CLR"></a>CTS、CLS、CLR</h1><p>CTS：通用类型系统；<br>CLS：通用语言规范；<br>CLR：公共语言运行库；</p><h1 id="using"><a href="#using" class="headerlink" title="using"></a>using</h1><ul><li>引用命名空间。</li><li>using 一个非托管资源（IDisposiable），用来释放资源。</li></ul><h1 id="托管资源、非托管资源"><a href="#托管资源、非托管资源" class="headerlink" title="托管资源、非托管资源"></a>托管资源、非托管资源</h1><p>托管资源指的是.NET 可以自动进行回收的资源，主要是指托管堆上分配的内存资源。<br>非托管资源指的是.NET 不知道如何回收的资源，最常见的是包装操作系统资源的对象，例如文件，窗口，网络连接，数据库连接，画刷，图标等。<br>建议通过调用 IDisposable.Dispose()方法来回收非托管资源。</p><h1 id="ref、out、in"><a href="#ref、out、in" class="headerlink" title="ref、out、in"></a>ref、out、in</h1><p>相同：都是按引用传递，形参成为实参的别名；<br>不同：ref 在方法外需初始化；out 需在方法内赋值；in 在方法内是只读的。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  <span class="built_in">int</span> number = <span class="number">50</span>;</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;调用方法前 number 值：&quot;</span> + number);</span><br><span class="line">  RefFunction(<span class="keyword">ref</span> number);</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;调用方法后 number 值：&quot;</span> + number);</span><br><span class="line">  Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入的参数值是 50 ，方法中使用的 num 值也是 50</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RefFunction</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  num = num / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> number = <span class="number">50</span>;</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;调用方法前 number 值：&quot;</span> + number);</span><br><span class="line">  OutFunction(<span class="keyword">out</span> number);</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;调用方法后 number 值：&quot;</span> + number);</span><br><span class="line">  Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法将的参数值 50 传入 ，但是必须在方法中初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OutFunction</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  num = <span class="number">120</span>;</span><br><span class="line">  num = num / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="in-的意义"><a href="#in-的意义" class="headerlink" title="in 的意义"></a>in 的意义</h1><p>结构体实例数据分配在栈上，当需要将大数据量的结构体作为方法参数时，会复制一份该大结构体，成本有点高，使用 in 来按引用传递该大结构体，就能避免复制问题。</p><h1 id="ref、out、in-使用限制"><a href="#ref、out、in-使用限制" class="headerlink" title="ref、out、in 使用限制"></a>ref、out、in 使用限制</h1><p>async 修饰的异步方法中无法使用；<br>迭代器方法（含有 yield return 或 yield break 的方法）中无法使用；<br>扩展方法的第一个参数不能有 in 修饰符，除非该参数是结构体；<br>扩展方法的第一个参数，其中该参数是泛型类型（即使该类型被约束为结构体）；</p><h1 id="Equals-和-x3D-x3D"><a href="#Equals-和-x3D-x3D" class="headerlink" title="Equals 和 &#x3D;&#x3D;"></a>Equals 和 &#x3D;&#x3D;</h1><p>&#x3D;&#x3D; 值类型数据比较的是值，引用类型比较的是引用地址。<br>Equals 引用类型比较的是最终数据。</p><h1 id="as-和-is"><a href="#as-和-is" class="headerlink" title="as 和 is"></a>as 和 is</h1><p>is 判断对象是否兼容于某类型，返回 bool 值，永远不会抛出异常。<br>as 用于在兼容的引用类型之间执行转换。无法转换则为 null。<br>is 需要做两次对象的类型检查，而 as 需要做一次对象类型检查。</p><h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><p>public：共有的，访问不受限制；<br>private：私有的，只能在当前类中访问；<br>internal：内部的，只能在当前程序集中访问；<br>protected：受保护的，只能在当前类或其派生类中访问；<br>file：当前文件范围，C# 11 新增；<br>protected internal：受保护的内部成员，当前程序集或派生自包含类的类型可访问；<br>private protected：私有受保护的成员，当前程序集中的包含类或从包含类派生的类型可访问；<br>class 默认 internal，class member 默认 private。</p><h1 id="class-成员、interface-成员"><a href="#class-成员、interface-成员" class="headerlink" title="class 成员、interface 成员"></a>class 成员、interface 成员</h1><p>class 成员：字段、常量、属性、方法、事件、运算符、索引器、构造函数、终结器、嵌套类型。<br>interface 成员：方法、属性、索引器和事件</p><h1 id="类的执行顺序"><a href="#类的执行顺序" class="headerlink" title="类的执行顺序"></a>类的执行顺序</h1><p>父类，子类，静态块，静态字段，非静态块，非静态字段，构造器，方法</p><h1 id="数据类型和内存占用"><a href="#数据类型和内存占用" class="headerlink" title="数据类型和内存占用"></a>数据类型和内存占用</h1><p>1 byte bool、byte<br>2 byte char、short<br>4 byte int、float<br>8 byte long、double<br>16 byte decimal</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>编译时多态和运行时多态。</p><h2 id="编译时多态"><a href="#编译时多态" class="headerlink" title="编译时多态"></a>编译时多态</h2><p>重载编译时多态。根据签名不同分为不同的方法，编译后就成两个不同名函数。</p><h2 id="运行时多态"><a href="#运行时多态" class="headerlink" title="运行时多态"></a>运行时多态</h2><p>虚方法是运行时多态，父类中有虚方法，子类覆盖实现虚方法。</p><h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><p>在浅拷贝中，仅对顶级对象进行了复制，对低级别对象进行了引用。<br>在深拷贝中，会复制所有对象。</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>继承 ICloneable，实现 Clone()方法，方法中调用 MemberwiseClone()；<br>如果字段是值类型，则执行字段的按位复制；如果字段是引用类型，引用将复制，但被引用的对象不会被复制。</p><h1 id="协变和逆变"><a href="#协变和逆变" class="headerlink" title="协变和逆变"></a>协变和逆变</h1><p>in 逆变，out 协变。<br>赋值的兼容性，用在委托或者接口上。<br>需要<code>返回数据</code>，这种结构化的委托有效性之间的关系叫做协变，用 out 标记泛型类型。<br>需要<code>接受数据</code>，期望传入基类时允许传入派生对象的特性叫逆变，用 in 标记泛型类型。<br>协变：</p><ul><li>IEnumerable<out T></li><li>IEnumerator<out T></li><li>IQueryable<out T></li><li>IGrouping&lt;out TKey, out TElement&gt;</li></ul><p>逆变：</p><ul><li>IComparer<in T></li><li>IEqualityComparer<in T></li><li>IComparable<in T></li><li>Action<in T></li><li>Predicate<in T></li><li>Comparison<in T></li></ul><p>协变 + 逆变：</p><ul><li>TOutput Converter&lt;in TInput, out TOutput&gt;</li></ul><h1 id="object-和-dynamic"><a href="#object-和-dynamic" class="headerlink" title="object 和 dynamic"></a>object 和 dynamic</h1><p>object 是一种引用类型，表示 .NET 框架中的任何类型。它是所有引用类型的基类，允许将任何类型的对象存储在这个变量中。<br>dynamic 是 C# 中的一个关键字，在编译时将变量的类型指定为 dynamic ，对象的实际类型将在运行时确定，这在使用没有特定类型定义的 API 或库时非常有用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>object 是<code>基类</code>，可以存储任何引用类型；<br>dynamic 是<code>关键字</code>，在编译时跳过类型检查，在运行时确定类型。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>object 在我们不知道数据类型时很有用。<br>dynamic 更多是用在反射，支持动态语言，COM 对象调用以及获取 LINQ 的查询结果。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> a = <span class="string">&quot;Rohatash Kumar&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> a1 = a.ToString();</span><br><span class="line"></span><br><span class="line"><span class="built_in">dynamic</span> a = <span class="string">&quot;Rohatash Kumar&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> a1 = a;</span><br></pre></td></tr></table></figure><h1 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h1><ul><li>都能有默认实现；</li><li>都不能直接实例化；</li><li>抽象类单继承，接口多继承；</li><li>抽象类中可以有字段、属性、方法，接口中可以有属性、方法、索引器、事件，没有字段；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;string-Empty、-quot-quot-、-null。&quot;&gt;&lt;a href=&quot;#string-Empty、-quot-quot-、-null。&quot; class=&quot;headerlink&quot; title=&quot;string.Empty、&amp;quot;&amp;quot;、 nul</summary>
      
    
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/categories/CSharp/"/>
    
    
    <category term="CSharp" scheme="http://cencuansen.github.com/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>HTML src 和 href</title>
    <link href="http://cencuansen.github.com/2023/02/14/HTML-src-and-href/"/>
    <id>http://cencuansen.github.com/2023/02/14/HTML-src-and-href/</id>
    <published>2023-02-14T14:27:46.000Z</published>
    <updated>2023-02-14T14:44:15.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用结果不同"><a href="#作用结果不同" class="headerlink" title="作用结果不同"></a>作用结果不同</h1><p>href 用于在当前文档和引用资源之间建立<code>联系</code>。<br>src 加载资源，<code>嵌入</code>相应元素中。</p><h1 id="浏览器解析方式不同"><a href="#浏览器解析方式不同" class="headerlink" title="浏览器解析方式不同"></a>浏览器解析方式不同</h1><p>href 浏览器会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。<br>src 会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，如图片(img)和框架(iframe)等，类似于将资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。</p><h1 id="请求资源类型不同"><a href="#请求资源类型不同" class="headerlink" title="请求资源类型不同"></a>请求资源类型不同</h1><p>href（Hypertext Reference，超文本引用）用来建立当前元素和文档之间的链接。如：link、a。<br>src 的资源，会将资源下载并应用到文档中，常用的有 script，img 、iframe。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;./style.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>click here<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://example.com/foo.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://example.com/bar.png&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;作用结果不同&quot;&gt;&lt;a href=&quot;#作用结果不同&quot; class=&quot;headerlink&quot; title=&quot;作用结果不同&quot;&gt;&lt;/a&gt;作用结果不同&lt;/h1&gt;&lt;p&gt;href 用于在当前文档和引用资源之间建立&lt;code&gt;联系&lt;/code&gt;。&lt;br&gt;src 加载资源，&lt;cod</summary>
      
    
    
    
    <category term="HTML" scheme="http://cencuansen.github.com/categories/HTML/"/>
    
    
    <category term="HTML" scheme="http://cencuansen.github.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Web 浏览器中网络请求过程</title>
    <link href="http://cencuansen.github.com/2023/02/14/Web-request-process-in-browser/"/>
    <id>http://cencuansen.github.com/2023/02/14/Web-request-process-in-browser/</id>
    <published>2023-02-14T14:21:06.000Z</published>
    <updated>2023-02-14T14:25:05.163Z</updated>
    
    <content type="html"><![CDATA[<ol><li>地址解析，提取出协议、域名、端口等信息等</li><li>通过 DNS 获取到 IP 地址</li><li>进行 TCP 连接(三次握手)<br>a. 第一次握手：建立连接时，客户端发送 syn(建立联机)包到服务器，并进入 syn_send 状态，等待服务器确认；<br>b. 第二次握手：服务器收到 syn 包，确认包信息，同时自己也发送一个 syn + ack(确认)包并进入 syn_recv 状态;<br>c. 第三次握手：客户端收到 syn+ack 包，向服务器发送 ack 包，发送完后，客户端和服务器都进入 established 状态，完成三次握手；</li><li>HTTP 请求</li><li>服务器响应请求</li><li>DOM 解析和渲染</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;地址解析，提取出协议、域名、端口等信息等&lt;/li&gt;
&lt;li&gt;通过 DNS 获取到 IP 地址&lt;/li&gt;
&lt;li&gt;进行 TCP 连接(三次握手)&lt;br&gt;a. 第一次握手：建立连接时，客户端发送 syn(建立联机)包到服务器，并进入 syn_send 状态，等待服务</summary>
      
    
    
    
    <category term="Web" scheme="http://cencuansen.github.com/categories/Web/"/>
    
    
    <category term="Web" scheme="http://cencuansen.github.com/tags/Web/"/>
    
    <category term="Request" scheme="http://cencuansen.github.com/tags/Request/"/>
    
  </entry>
  
  <entry>
    <title>Web DOM 的解析和渲染</title>
    <link href="http://cencuansen.github.com/2023/02/14/Web-dom-parsing-and-rendering/"/>
    <id>http://cencuansen.github.com/2023/02/14/Web-dom-parsing-and-rendering/</id>
    <published>2023-02-14T14:12:08.000Z</published>
    <updated>2023-02-14T14:19:38.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解析流程"><a href="#解析流程" class="headerlink" title="解析流程"></a>解析流程</h1><ol><li>解析 html，构建 <code>DOM Tree</code></li><li>解析 CSS，构建 <code>CSS Rule Tree</code></li><li>由 DOM Tree 和 CSS Rule Tree 生成 <code>Render Tree</code></li><li>利用 Render Tree 进行布局 <code>Layout</code>，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置</li><li><code>painting</code> 绘制 按照算出来的规则将内容绘制到屏幕上</li></ol><h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><p>问：DOM 树的构建是文档加载完成开始的？<br>答：不是，为更好用户体验，渲染引擎会尽快将内容进行显示，加载部分后就尝试解析、构建、布局、渲染。<br>问：Render 树是 DOM 树和 CSSOM 树构建完毕才开始构建的吗？<br>答：不是。三者交叉进行，一边加载，一边解析，一边渲染。<br>问：CSS 解析顺序？<br>答：选择器从右往左，DOM 树从下向上的解析顺序。嵌套标签越多解析越慢。<br>问：repaint 重绘？<br>答：改变元素背景色、前景色、边框色等，不影响文档中周边元素布局位置。<br>问：reflow 回流？<br>答：影响元素布局<code>位置变更</code>的操作，会导致回流，从根向下重新计算全部元素节点尺寸和位置，比如：元素显隐、元素尺寸变更、定位方式等，都会引起内部、周围、整个页面的重新渲染。通常无法预估页面哪部分会回流，它们都彼此相互影响着。频繁回流会影响性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;解析流程&quot;&gt;&lt;a href=&quot;#解析流程&quot; class=&quot;headerlink&quot; title=&quot;解析流程&quot;&gt;&lt;/a&gt;解析流程&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;解析 html，构建 &lt;code&gt;DOM Tree&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解析 CSS，构建 &lt;cod</summary>
      
    
    
    
    <category term="Web" scheme="http://cencuansen.github.com/categories/Web/"/>
    
    
    <category term="Web" scheme="http://cencuansen.github.com/tags/Web/"/>
    
    <category term="Dom" scheme="http://cencuansen.github.com/tags/Dom/"/>
    
    <category term="Dom Parsing" scheme="http://cencuansen.github.com/tags/Dom-Parsing/"/>
    
    <category term="Dom Rendering" scheme="http://cencuansen.github.com/tags/Dom-Rendering/"/>
    
  </entry>
  
  <entry>
    <title>HTML 块级格式化上下文</title>
    <link href="http://cencuansen.github.com/2023/02/14/HTML-block-formatting-context/"/>
    <id>http://cencuansen.github.com/2023/02/14/HTML-block-formatting-context/</id>
    <published>2023-02-14T11:53:32.000Z</published>
    <updated>2023-02-14T12:01:21.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>一个块级格式化上下文（<strong>B</strong>lock <strong>F</strong>ormatting <strong>C</strong>ontext），包含该上下文元素的所有<code>直接子元素</code>，但是不包括子元素的子元素。</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box-a&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bfc1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box-b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box-c&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bfc2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box-d&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>#bfc1</code> 的 BFC 指的是 <code>.box-b</code> 和 <code>.box-c</code>；<br><code>#bfc2</code> 的 BFC 指的是 <code>.box-d</code>；</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>每一个 BFC 区域只包括其子元素，不包括其子元素的子元素；</li><li>每一个 BFC 区域都是独立隔绝的，互不影响！</li></ul><h1 id="三种布局"><a href="#三种布局" class="headerlink" title="三种布局"></a>三种布局</h1><ul><li>标准流（normal）</li><li>浮动流（float）</li><li>定位流（position）</li></ul><h1 id="触发-BFC"><a href="#触发-BFC" class="headerlink" title="触发 BFC"></a>触发 BFC</h1><ul><li>body 根元素；</li><li>设置 float，不包括 none；</li><li>设置 position，包括 absoulte、fixed；</li><li>设置 display 为 inline-block；</li><li>设置 overflow，包括 hidden、auto、scroll；</li><li>表格单元格，table-cell；</li><li>弹性布局，flex；</li></ul><h1 id="BFC-实际应用"><a href="#BFC-实际应用" class="headerlink" title="BFC 实际应用"></a>BFC 实际应用</h1><h2 id="兄弟-div-margin-重叠"><a href="#兄弟-div-margin-重叠" class="headerlink" title="兄弟 div margin 重叠"></a>兄弟 div margin 重叠</h2><p>问题描述：文档中相邻 div 元素，上下分布，但两者 margin 默认会重叠。<br>解决思路：将相邻兄弟变成非相邻同级：把这两兄弟元素各用 div 包裹，触发包裹元素的 bfc。</p><h2 id="父子-div-margin-重叠"><a href="#父子-div-margin-重叠" class="headerlink" title="父子 div margin 重叠"></a>父子 div margin 重叠</h2><p>问题描述：文档中父子 div 元素，子 div margin-top 会让父子 div 同时下移。<br>解决思路：触发父级 bfc、父级设置边框。</p><h2 id="清除浮动影响"><a href="#清除浮动影响" class="headerlink" title="清除浮动影响"></a>清除浮动影响</h2><p>问题描述：父元素没设置高度，包含一个子元素，子元素设置浮动，父元素会高度塌陷。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;一个块级格式化上下文（&lt;strong&gt;B&lt;/strong&gt;lock &lt;strong&gt;F&lt;/strong&gt;ormatting &lt;strong&gt;</summary>
      
    
    
    
    <category term="HTML" scheme="http://cencuansen.github.com/categories/HTML/"/>
    
    
    <category term="HTML" scheme="http://cencuansen.github.com/tags/HTML/"/>
    
    <category term="BFC" scheme="http://cencuansen.github.com/tags/BFC/"/>
    
  </entry>
  
  <entry>
    <title>CSS transform、transition、animation</title>
    <link href="http://cencuansen.github.com/2023/02/14/CSS-transform-transition-animation/"/>
    <id>http://cencuansen.github.com/2023/02/14/CSS-transform-transition-animation/</id>
    <published>2023-02-14T11:41:16.000Z</published>
    <updated>2023-02-14T11:51:24.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h1><p><code>transform: [转换函数];</code><br>转换函数：translate、scale、rotate、skew。<br>transform 只影响当前元素，不影响文档流。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">1px</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">2px</span>);</span><br></pre></td></tr></table></figure><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>参考：<a href="https://www.bilibili.com/video/BV1L3411C76T">https://www.bilibili.com/video/BV1L3411C76T</a></p><ul><li>变换后盒子模型占据的尺寸和位置不会变换；</li><li>变换后会创建层叠上下文；</li><li>对内联元素无效；</li><li>不同顺序效果不同；</li><li>锯齿或虚化问题；</li></ul><h1 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h1><p>改变目标元素的样式：颜色、外观、尺寸，一般<code>搭配伪类</code>。<br>transition 尺寸变更会对文档流产生影响。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">0.4s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者用 JavaScript 改变元素属性触发 transition</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blueviolet;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">1s</span> linear <span class="number">0.5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;box1&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><ul><li>transition 需要触发，没法在网页加载时自动发生。</li><li>transition 是一次性的，不能重复发生，除非一再触发。</li><li>transition 只能定义开始状态和结束状态，不能定义中间状态。</li><li>一条 transition 规则，只能定义一个属性的变化，不能涉及多个属性。</li></ul><h1 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h1><p>transition 不够用的时候，可以使用 animation。<br>animation 搭配 <code>@keyframes</code> 使用，无需搭配伪类，页面加载 animation 就自动开始了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.animation1</span> &#123;</span><br><span class="line">  <span class="comment">/* forwards：动画结束时，就停在最终状态 */</span></span><br><span class="line">  <span class="attribute">animation</span>: changeAnimation <span class="number">1s</span> ease forwards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.animation2</span> &#123;</span><br><span class="line">  <span class="comment">/* infinite alternate：无限循环 + 往复 */</span></span><br><span class="line">  <span class="attribute">animation</span>: changeAnimation <span class="number">1s</span> ease infinite alternate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> changeAnimation &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">110px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">140px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;transform&quot;&gt;&lt;a href=&quot;#transform&quot; class=&quot;headerlink&quot; title=&quot;transform&quot;&gt;&lt;/a&gt;transform&lt;/h1&gt;&lt;p&gt;&lt;code&gt;transform: [转换函数];&lt;/code&gt;&lt;br&gt;转换函数：tr</summary>
      
    
    
    
    <category term="CSS" scheme="http://cencuansen.github.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://cencuansen.github.com/tags/CSS/"/>
    
    <category term="transform" scheme="http://cencuansen.github.com/tags/transform/"/>
    
    <category term="transition" scheme="http://cencuansen.github.com/tags/transition/"/>
    
    <category term="animation" scheme="http://cencuansen.github.com/tags/animation/"/>
    
  </entry>
  
  <entry>
    <title>CSS 伪类和伪元素</title>
    <link href="http://cencuansen.github.com/2023/02/14/CSS-pseudo-classes-and-pseudo-elements/"/>
    <id>http://cencuansen.github.com/2023/02/14/CSS-pseudo-classes-and-pseudo-elements/</id>
    <published>2023-02-14T09:35:15.000Z</published>
    <updated>2023-02-14T10:51:00.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h1><p>功能和 class 有些类似，但它是基于文档之外的抽象，所以叫伪类。</p><p>:link、:visited、:hover、:active、:focus、:right、:left、:first、:lang、:first-child</p><h1 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h1><p>伪元素是 DOM 树没有定义的虚拟元素。</p><p>::before、::after、::selection</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;伪类&quot;&gt;&lt;a href=&quot;#伪类&quot; class=&quot;headerlink&quot; title=&quot;伪类&quot;&gt;&lt;/a&gt;伪类&lt;/h1&gt;&lt;p&gt;功能和 class 有些类似，但它是基于文档之外的抽象，所以叫伪类。&lt;/p&gt;
&lt;p&gt;:link、:visited、:hover、:activ</summary>
      
    
    
    
    <category term="CSS" scheme="http://cencuansen.github.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://cencuansen.github.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS 选择第二个以及后续元素</title>
    <link href="http://cencuansen.github.com/2023/02/14/CSS-select-children-between-2nd-and-last/"/>
    <id>http://cencuansen.github.com/2023/02/14/CSS-select-children-between-2nd-and-last/</id>
    <published>2023-02-14T09:28:47.000Z</published>
    <updated>2023-02-14T10:51:00.612Z</updated>
    
    <content type="html"><![CDATA[<p>元素如下，希望除了第一个子 div 不选择，其他子 div 都选择。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-4&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式一</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-of-type</span>(n + <span class="number">2</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:nth-child</span>(n + <span class="number">2</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;元素如下，希望除了第一个子 div 不选择，其他子 div 都选择。&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    <category term="CSS" scheme="http://cencuansen.github.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://cencuansen.github.com/tags/CSS/"/>
    
    <category term="Selector" scheme="http://cencuansen.github.com/tags/Selector/"/>
    
  </entry>
  
  <entry>
    <title>CSS 1像素线</title>
    <link href="http://cencuansen.github.com/2023/02/14/CSS-1px-line/"/>
    <id>http://cencuansen.github.com/2023/02/14/CSS-1px-line/</id>
    <published>2023-02-14T09:21:43.000Z</published>
    <updated>2023-02-14T10:51:00.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>移动端开发线条的 1 像素线绘制。</p><h1 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h1><ul><li>用 0.5px</li><li>transform scale</li><li>box-shadow 模拟</li><li>图片</li></ul><h2 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>, <span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h1&gt;&lt;p&gt;移动端开发线条的 1 像素线绘制。&lt;/p&gt;
&lt;h1 id=&quot;方式&quot;&gt;&lt;a href=&quot;#方式&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="CSS" scheme="http://cencuansen.github.com/categories/CSS/"/>
    
    
    <category term="CSS" scheme="http://cencuansen.github.com/tags/CSS/"/>
    
    <category term="CSS Tricks" scheme="http://cencuansen.github.com/tags/CSS-Tricks/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 深拷贝和浅拷贝</title>
    <link href="http://cencuansen.github.com/2023/02/14/JavaScript-deep-clone-and-shallow-clone/"/>
    <id>http://cencuansen.github.com/2023/02/14/JavaScript-deep-clone-and-shallow-clone/</id>
    <published>2023-02-14T09:08:52.000Z</published>
    <updated>2023-02-14T10:51:00.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>浅拷贝：复制一层数据，基本类型直接复制，对象类型复制引用。<br>深拷贝：会递归复制。</p><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><ul><li>扩展运算符(<code>...</code>)</li><li>Object.assign</li></ul><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><ul><li>JSON.parse(JSON.stringify())</li><li>遍历递归</li></ul><h2 id="JSON-化问题"><a href="#JSON-化问题" class="headerlink" title="JSON 化问题"></a>JSON 化问题</h2><ol><li>正则变成空对象(<code>&#123;&#125;</code>)；</li><li>函数直接丢；</li><li>日期变成时间字符串(无解)；</li><li>构造函数丢失，变成 Object；</li><li>循环引用无法正确处理；</li></ol><h2 id="遍历深拷贝"><a href="#遍历深拷贝" class="headerlink" title="遍历深拷贝"></a>遍历深拷贝</h2><p>版本一</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理null或者undefined</span></span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="comment">// 处理日期类型</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj);</span><br><span class="line">  <span class="comment">// 处理正则类型</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj);</span><br><span class="line">  <span class="comment">// 普通值或函数不需要深拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="comment">// 对象进行深拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (hash.<span class="title function_">get</span>(obj)) <span class="keyword">return</span> hash.<span class="title function_">get</span>(obj);</span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br><span class="line">  <span class="comment">// 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身</span></span><br><span class="line">  hash.<span class="title function_">set</span>(obj, cloneObj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      <span class="comment">// 实现一个递归拷贝</span></span><br><span class="line">      cloneObj[key] = <span class="title function_">deepClone</span>(obj[key], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本二</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isComplexDataType</span> = obj =&gt; (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> obj === <span class="string">&#x27;function&#x27;</span>) &amp;&amp; (obj !== <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="keyword">function</span> (<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">constructor</span> === <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="comment">// 日期对象直接返回一个新的日期对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">constructor</span> === <span class="title class_">RegExp</span>) &#123;</span><br><span class="line">    <span class="comment">// 正则对象直接返回一个新的正则对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hash.<span class="title function_">has</span>(obj)) &#123;</span><br><span class="line">    <span class="comment">// 如果循环引用了就用 weakMap 来解决</span></span><br><span class="line">    <span class="keyword">return</span> hash.<span class="title function_">get</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> allDescriptors = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj);</span><br><span class="line">  <span class="comment">// 遍历传入参数所有键的特性</span></span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj), allDescriptors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 继承原型链</span></span><br><span class="line">  hash.<span class="title function_">set</span>(obj, cloneObj)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj)) &#123;</span><br><span class="line">    cloneObj[key] = (<span class="title function_">isComplexDataType</span>(obj[key]) &amp;&amp; <span class="keyword">typeof</span> obj[key] !== <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">      ? <span class="title function_">deepClone</span>(obj[key], hash)</span><br><span class="line">      : obj[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cloneObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;浅拷贝：复制一层数据，基本类型直接复制，对象类型复制引用。&lt;br&gt;深拷贝：会递归复制。&lt;/p&gt;
&lt;h1 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://cencuansen.github.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://cencuansen.github.com/tags/JavaScript/"/>
    
    <category term="Deep Clone" scheme="http://cencuansen.github.com/tags/Deep-Clone/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 模块化</title>
    <link href="http://cencuansen.github.com/2023/02/14/JavaScript-module/"/>
    <id>http://cencuansen.github.com/2023/02/14/JavaScript-module/</id>
    <published>2023-02-14T08:57:11.000Z</published>
    <updated>2023-02-14T10:51:00.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h1><ul><li>AMD&#x2F;CMD</li><li>CommonJS(适用于服务端)</li><li>UMD</li><li>ESM(EcmaScript Module)</li></ul><h1 id="AMD-x2F-CMD"><a href="#AMD-x2F-CMD" class="headerlink" title="AMD&#x2F;CMD"></a>AMD&#x2F;CMD</h1><p>AMD：Asynchronous Module Definition，异步模块定义。<br>CMD：Common Module Definition，通用模块定义。<br>相对于 CommonJS，定义了适用于<code>浏览器端</code>的规范。<br>AMD 中有 requirejs，CMD 中有 seajs。<br>用 define 方法来定义一个模块，通过前置依赖列表导入外部模块数据。</p><h1 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h1><p>nodejs 模块化采用的是 CommonJS。<br>module.exports 或 exports 导出，require 导入。<br>CommonJS 规范一些特性：文件系统，同步加载等，不适用于浏览器端，适用于<code>服务端</code>。</p><h1 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h1><p>UMD：Universal Module Definition，通用模块定义<br>不属于一套模块规范，主要用来处理 CommonJS、AMD、CMD 的差异<code>兼容</code>，使模块代码能在前面不同的模块环境下都能正常运行。</p><h1 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a>ESM</h1><p>JavaScript 在 <code>ES6</code> 开始引入模块概念：ES Module。<br>export default 或 export 导出，import 导入。<br>动态导入 import() 返回 promise。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;种类&quot;&gt;&lt;a href=&quot;#种类&quot; class=&quot;headerlink&quot; title=&quot;种类&quot;&gt;&lt;/a&gt;种类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;AMD&amp;#x2F;CMD&lt;/li&gt;
&lt;li&gt;CommonJS(适用于服务端)&lt;/li&gt;
&lt;li&gt;UMD&lt;/li&gt;
&lt;li&gt;ESM</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://cencuansen.github.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://cencuansen.github.com/tags/JavaScript/"/>
    
    <category term="Module" scheme="http://cencuansen.github.com/tags/Module/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 继承</title>
    <link href="http://cencuansen.github.com/2023/02/14/JavaScript-inherit/"/>
    <id>http://cencuansen.github.com/2023/02/14/JavaScript-inherit/</id>
    <published>2023-02-14T08:44:17.000Z</published>
    <updated>2023-02-14T10:51:00.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-继承"><a href="#ES6-继承" class="headerlink" title="ES6 继承"></a>ES6 继承</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;  &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;  &#125;</span><br></pre></td></tr></table></figure><h1 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">parent, child</span>) &#123;</span><br><span class="line">  <span class="comment">// 该操作将 Parent 原型中属性方法等带到 Child</span></span><br><span class="line">  child.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  child.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;parent&quot;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 该 call 操作会将 Parent 自身的属性字段带到 Child</span></span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = <span class="string">&quot;child&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">clone</span>(<span class="title class_">Parent</span>, <span class="title class_">Child</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getFriends</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">friends</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ES6-继承&quot;&gt;&lt;a href=&quot;#ES6-继承&quot; class=&quot;headerlink&quot; title=&quot;ES6 继承&quot;&gt;&lt;/a&gt;ES6 继承&lt;/h1&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://cencuansen.github.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://cencuansen.github.com/tags/JavaScript/"/>
    
    <category term="Inherit" scheme="http://cencuansen.github.com/tags/Inherit/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 词法作用域和动态作用域</title>
    <link href="http://cencuansen.github.com/2023/02/13/JavaScript-lexical-scope-and-dynamic-scope/"/>
    <id>http://cencuansen.github.com/2023/02/13/JavaScript-lexical-scope-and-dynamic-scope/</id>
    <published>2023-02-13T13:40:43.000Z</published>
    <updated>2023-02-14T10:51:00.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>JavaScript 中，<code>变量</code>采用的是<code>词法作用域</code>。</p><h1 id="词法作用域-x2F-静态作用域"><a href="#词法作用域-x2F-静态作用域" class="headerlink" title="词法作用域&#x2F;静态作用域"></a>词法作用域&#x2F;静态作用域</h1><p>作用域在变量<code>定义时</code>就确定。</p><h1 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h1><p>作用域在变量<code>使用时</code>才确定。</p><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">  <span class="title function_">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>();</span><br></pre></td></tr></table></figure><p>这里 bar 中 foo 的 value 输出为 1，说明变量在函数定义时就确定了，属于词法作用域。<br>如果是动态作用域，bar 中 foo 的 value 值就应当等于 2。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>问：this 是动态作用域吗？<br>答：不是。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;JavaScript 中，&lt;code&gt;变量&lt;/code&gt;采用的是&lt;code&gt;词法作用域&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&quot;词法作用域-</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://cencuansen.github.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://cencuansen.github.com/tags/JavaScript/"/>
    
    <category term="Function" scheme="http://cencuansen.github.com/tags/Function/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 闭包</title>
    <link href="http://cencuansen.github.com/2023/02/13/JavaScript-closure/"/>
    <id>http://cencuansen.github.com/2023/02/13/JavaScript-closure/</id>
    <published>2023-02-13T13:15:30.000Z</published>
    <updated>2023-02-14T10:51:00.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>闭包是一个特殊的函数，能够记录自己<code>词法作用域</code>内变量的状态，可以读取该作用域内的变量，在函数或语句块结束后，变量仍然对引用它的函数有效。<br>在一个函数中<code>返回函数</code>或者<code>作为回调</code>，这样创建了闭包。当基于参数创建回调，参数必须在闭包中存储（比如：形参存储），否则就会创建一个闭包指向封闭环境中的变量，而这个变量可能会变。</p><h2 id="场景一，返回函数"><a href="#场景一，返回函数" class="headerlink" title="场景一，返回函数"></a>场景一，返回函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> counter += <span class="number">1</span>; &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>();</span><br></pre></td></tr></table></figure><h2 id="场景二，作为回调"><a href="#场景二，作为回调" class="headerlink" title="场景二，作为回调"></a>场景二，作为回调</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span> <span class="title function_">clo</span>(<span class="params">ii</span>) &#123;</span><br><span class="line">    <span class="comment">// 形参 ii 对 i 进行了存储</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(ii); &#125;, <span class="number">20</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要浏览器版本 &gt; IE9</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params">ii</span>) &#123;</span><br><span class="line">        <span class="comment">// 形参 ii 对 i 进行了存储</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(ii);</span><br><span class="line">        &#125;, <span class="number">20</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>封装变量：闭包可以隐藏内部变量，使得代码变得更加简洁；<br>模拟私有变量：闭包可以模拟私有变量，使得变量不被外部访问；<br>实现回调函数：闭包可以作为回调函数传递给其他函数，以实现延迟执行；<br>实现单例模式：闭包可以保证一个类型仅有一个实例；<br>构建命名空间：闭包可以构建命名空间，使得变量名不冲突；</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>参数未在闭包中存储，就会创建一个闭包指向封闭环境中的变量，这变量会变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 未对变量 i 进行存储</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i is &#x27;</span> + i);</span><br><span class="line">    &#125;, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里参数未在闭包中存储，运行中 i 会变，最终 i 变成 10，输出 10 次 <code>i is 10</code>。<br>类似的有 setTimeout、setInterval、eval() 等。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>问：闭包一定需要 return 吗<br>答：不一定，上面所示的<code>场景二</code>也是闭包，就不涉及 return。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://creeperyang.github.io/2015/01/JavaScript-dynamic-scope-vs-static-scope/">https://creeperyang.github.io/2015/01/JavaScript-dynamic-scope-vs-static-scope/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;闭包是一个特殊的函数，能够记录自己&lt;code&gt;词法作用域&lt;/code&gt;内变量的状态，可以读取该作用域内的变量，在函数或语句块结束后，变量仍然</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://cencuansen.github.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://cencuansen.github.com/tags/JavaScript/"/>
    
    <category term="Closure" scheme="http://cencuansen.github.com/tags/Closure/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript apply、bind、call</title>
    <link href="http://cencuansen.github.com/2023/02/13/JavaScript-apply-bind-call/"/>
    <id>http://cencuansen.github.com/2023/02/13/JavaScript-apply-bind-call/</id>
    <published>2023-02-13T12:53:10.000Z</published>
    <updated>2023-02-14T10:51:00.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>apply、bind、call 用来改变函数内 this 指向</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [arg1, arg2 [,...]])</span><br><span class="line">func.<span class="title function_">bind</span>(<span class="variable language_">this</span>, arg1, arg2 [,...])</span><br><span class="line">func.<span class="title function_">call</span>(<span class="variable language_">this</span>, arg1, arg2 [,...])</span><br></pre></td></tr></table></figure><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><table><thead><tr><th align="right">分类</th><th align="left">说明</th></tr></thead><tbody><tr><td align="right">apply</td><td align="left">参数数组形式传，并调用对应函数</td></tr><tr><td align="right">bind</td><td align="left">参数一个一个传，返回一个函数</td></tr><tr><td align="right">call</td><td align="left">参数一个一个传，并调用对应函数</td></tr></tbody></table><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>问：一个方法连续 bind 多次，结果如何？<br>答：只有第一次 bind 有效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;用途&quot;&gt;&lt;a href=&quot;#用途&quot; class=&quot;headerlink&quot; title=&quot;用途&quot;&gt;&lt;/a&gt;用途&lt;/h1&gt;&lt;p&gt;apply、bind、call 用来改变函数内 this 指向&lt;/p&gt;
&lt;h1 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;h</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://cencuansen.github.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://cencuansen.github.com/tags/JavaScript/"/>
    
    <category term="Function" scheme="http://cencuansen.github.com/tags/Function/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 防抖和节流</title>
    <link href="http://cencuansen.github.com/2023/02/13/JavaScript-debouncing-and-throttling/"/>
    <id>http://cencuansen.github.com/2023/02/13/JavaScript-debouncing-and-throttling/</id>
    <published>2023-02-13T12:35:59.000Z</published>
    <updated>2023-02-14T10:51:00.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h1><p>节流和防抖是 JavaScript 中常用的<code>性能优化</code>手段，用途主要是在<code>高频率</code>的事件触发时，如鼠标移动、滚动事件、输入事件等，避免因频繁调用而导致性能下降。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>页面滚动时需要请求数据，可以使用<code>节流</code>限制请求频率。<br>验证用户输入是否合法，此时可以使用<code>防抖</code>避免频繁验证。</p><h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><p>节流（throttling）是指在一段时间内，只让一个函数有限次执行。它通常用来限制函数在一段时间内的<code>最大调用次数</code>，从而防止对性能造成过大的影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) <span class="keyword">return</span>;</span><br><span class="line">    canRun = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">      canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, interval);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h1><p>防抖（debouncing）是指在一段时间内，等待事件<code>停止触发</code>后才执行一次函数。它通常用来限制事件触发的频率，从而防止对性能造成过大的影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;, interval);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;意义&quot;&gt;&lt;a href=&quot;#意义&quot; class=&quot;headerlink&quot; title=&quot;意义&quot;&gt;&lt;/a&gt;意义&lt;/h1&gt;&lt;p&gt;节流和防抖是 JavaScript 中常用的&lt;code&gt;性能优化&lt;/code&gt;手段，用途主要是在&lt;code&gt;高频率&lt;/code&gt;的事件触发时</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://cencuansen.github.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://cencuansen.github.com/tags/JavaScript/"/>
    
    <category term="Closure" scheme="http://cencuansen.github.com/tags/Closure/"/>
    
    <category term="Performance Optimization" scheme="http://cencuansen.github.com/tags/Performance-Optimization/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 函数</title>
    <link href="http://cencuansen.github.com/2023/02/13/JavaScript-function/"/>
    <id>http://cencuansen.github.com/2023/02/13/JavaScript-function/</id>
    <published>2023-02-13T12:00:45.000Z</published>
    <updated>2023-02-14T10:51:00.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><h2 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">parameters</span>) &#123;  &#125;</span><br></pre></td></tr></table></figure><h2 id="表达式形式"><a href="#表达式形式" class="headerlink" title="表达式形式"></a>表达式形式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> functionName = <span class="keyword">function</span> (<span class="params">parameters</span>) &#123;  &#125;;</span><br></pre></td></tr></table></figure><h2 id="箭头函数形式"><a href="#箭头函数形式" class="headerlink" title="箭头函数形式"></a>箭头函数形式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) =&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><h1 id="提升（Hoisting）"><a href="#提升（Hoisting）" class="headerlink" title="提升（Hoisting）"></a>提升（Hoisting）</h1><p>提升特性让函数可以在声明之前调用，<strong>使用表达式定义函数时，无法提升。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">myFunction</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">y</span>) &#123; <span class="keyword">return</span> y * y; &#125;</span><br></pre></td></tr></table></figure><h1 id="自调用函数"><a href="#自调用函数" class="headerlink" title="自调用函数"></a>自调用函数</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;  &#125;)();</span><br><span class="line">(<span class="function">()=&gt;</span>&#123;  &#125;)();</span><br></pre></td></tr></table></figure><h1 id="箭头函数特点"><a href="#箭头函数特点" class="headerlink" title="箭头函数特点"></a>箭头函数特点</h1><ul><li>不能做构造函数，不能 new</li><li>没有 arguments，可用剩余参数代替</li><li>没有自己的 this，this 取决于箭头函数所在上下文</li><li>apply、bind、call 无法影响 this 指向</li><li>没有原型属性</li><li>不能作为 Generator 函数，不能使用 yield</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数定义&quot;&gt;&lt;a href=&quot;#函数定义&quot; class=&quot;headerlink&quot; title=&quot;函数定义&quot;&gt;&lt;/a&gt;函数定义&lt;/h1&gt;&lt;h2 id=&quot;一般形式&quot;&gt;&lt;a href=&quot;#一般形式&quot; class=&quot;headerlink&quot; title=&quot;一般形式&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://cencuansen.github.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://cencuansen.github.com/tags/JavaScript/"/>
    
    <category term="Function" scheme="http://cencuansen.github.com/tags/Function/"/>
    
  </entry>
  
</feed>
