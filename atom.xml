<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SanHuo&#39;s Blog</title>
  
  
  <link href="https://chengshen.me/atom.xml" rel="self"/>
  
  <link href="https://chengshen.me/"/>
  <updated>2023-02-19T14:07:26.694Z</updated>
  <id>https://chengshen.me/</id>
  
  <author>
    <name>SanHuo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RabbitMQ 实操</title>
    <link href="https://chengshen.me/microservices/RabbitMQ-practical-operation"/>
    <id>https://chengshen.me/microservices/RabbitMQ-practical-operation</id>
    <published>2023-02-19T14:03:07.000Z</published>
    <updated>2023-02-19T14:07:26.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Erlang-环境"><a href="#Erlang-环境" class="headerlink" title="Erlang 环境"></a>Erlang 环境</h1><p>需要配置 Er 语言环境。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>ttps:&#x2F;&#x2F;<a href="http://www.erlang.org/downloads">www.erlang.org/downloads</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>windows 环境变量的 path 中添加 erlang 的 bin 文件夹。</p><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h2><p>windows 安装包：<a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.10.1/rabbitmq-server-3.10.1.exe">https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.10.1/rabbitmq-server-3.10.1.exe</a></p><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><ol><li>windows 环境变量的 path 中添加 rabbitmq 的 sbin 文件夹。</li><li>执行 <code>rabbitmq-plugins enable rabbitmq_management</code>。</li><li>添加用户 <code>rabbitmqctl add_user [username] [password]</code>。</li><li>为用户配置权限 <code>rabbitmqctl set_user_tags [username] administrator</code>。</li><li>访问管理后台 <a href="http://localhost:15672，账号：guest，密码：guest。">http://localhost:15672，账号：guest，密码：guest。</a></li><li>后台中配置用户权限：Admin - 点击用户名 - Set permission。</li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>创建 2 个 ASP.NET 项目。分别是生产端和消费端。</p><h1 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MQProducer</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">      <span class="comment">// 创建连接工厂对象</span></span><br><span class="line">      IConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory</span><br><span class="line">      &#123;</span><br><span class="line">        HostName = <span class="string">&quot;172.21.46.105&quot;</span>,</span><br><span class="line">        Port = <span class="number">5672</span>,</span><br><span class="line">        UserName = <span class="string">&quot;rabbit1&quot;</span>,</span><br><span class="line">        Password = <span class="string">&quot;rabbit1&quot;</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 创建连接对象</span></span><br><span class="line">      IConnection con = factory.CreateConnection();</span><br><span class="line">      <span class="comment">// 创建连接会话对象</span></span><br><span class="line">      IModel channel = con.CreateModel();</span><br><span class="line"></span><br><span class="line">      <span class="built_in">string</span> name = <span class="string">&quot;demo&quot;</span>;</span><br><span class="line">      <span class="comment">// 声明一个队列</span></span><br><span class="line">      channel.QueueDeclare(</span><br><span class="line">        queue: name,       <span class="comment">// 消息队列名称</span></span><br><span class="line">        durable: <span class="literal">false</span>,    <span class="comment">// 是否持久化,true持久化,队列会保存磁盘,服务器重启时可以保证不丢失相关信息。</span></span><br><span class="line">        exclusive: <span class="literal">false</span>,  <span class="comment">// 是否排他,true排他的,如果一个队列声明为排他队列,该队列仅对首次声明它的连接可见,并在连接断开时自动删除.</span></span><br><span class="line">        autoDelete: <span class="literal">false</span>, <span class="comment">// 是否自动删除。true是自动删除。自动删除的前提是：致少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时,才会自动删除.</span></span><br><span class="line">        arguments: <span class="literal">null</span>);  <span class="comment">// 设置队列的一些其它参数</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">string</span> str = <span class="built_in">string</span>.Empty;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;发送内容:&quot;</span>);</span><br><span class="line">        str = Console.ReadLine();</span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        <span class="built_in">byte</span>[] body = Encoding.UTF8.GetBytes(str);</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        channel.BasicPublish(<span class="string">&quot;&quot;</span>, name, <span class="literal">null</span>, body);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;成功发送消息:&quot;</span> + str);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (str.Trim().ToLower() != <span class="string">&quot;exit&quot;</span>);</span><br><span class="line"></span><br><span class="line">      con.Close();</span><br><span class="line">      channel.Close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"><span class="keyword">using</span> RabbitMQ.Client.Events;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MQConsumer</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line">      IConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory</span><br><span class="line">      &#123;</span><br><span class="line">        HostName = <span class="string">&quot;172.21.46.105&quot;</span>,</span><br><span class="line">        Port = <span class="number">5672</span>,</span><br><span class="line">        UserName = <span class="string">&quot;rabbit1&quot;</span>,</span><br><span class="line">        Password = <span class="string">&quot;rabbit1&quot;</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      IConnection conn = factory.CreateConnection();</span><br><span class="line">      IModel channel = conn.CreateModel();</span><br><span class="line">      <span class="built_in">string</span> name = <span class="string">&quot;demo&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 声明一个队列</span></span><br><span class="line">      channel.QueueDeclare(</span><br><span class="line">        <span class="comment">// 消息队列名称</span></span><br><span class="line">        queue: name,</span><br><span class="line">        <span class="comment">// 是否持久化</span></span><br><span class="line">        durable: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// 是否排他。仅当前连接可用该队列</span></span><br><span class="line">        exclusive: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// 是否自动删除。最后一个消费者断开连接后，该队列自动删除</span></span><br><span class="line">        autoDelete: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// 设置队列的一些其它参数</span></span><br><span class="line">        arguments: <span class="literal">null</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">      <span class="comment">//创建消费者对象</span></span><br><span class="line">      <span class="keyword">var</span> consumer = <span class="keyword">new</span> EventingBasicConsumer(channel);</span><br><span class="line">      consumer.Received += (model, ea) =&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] message = ea.Body.ToArray();<span class="comment">//接收到的消息</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;接收到消息为:&quot;</span> + Encoding.UTF8.GetString(message));</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//消费者开启监听</span></span><br><span class="line">      channel.BasicConsume(name, <span class="literal">true</span>, consumer);</span><br><span class="line">      Console.ReadKey();</span><br><span class="line">      channel.Dispose();</span><br><span class="line">      conn.Close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Erlang-环境&quot;&gt;&lt;a href=&quot;#Erlang-环境&quot; class=&quot;headerlink&quot; title=&quot;Erlang 环境&quot;&gt;&lt;/a&gt;Erlang 环境&lt;/h1&gt;&lt;p&gt;需要配置 Er 语言环境。&lt;/p&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载</summary>
      
    
    
    
    <category term="RabbitMQ" scheme="https://chengshen.me/categories/RabbitMQ/"/>
    
    
    <category term="RabbitMQ" scheme="https://chengshen.me/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 基础</title>
    <link href="https://chengshen.me/microservices/RabbitMQ-basic-concepts"/>
    <id>https://chengshen.me/microservices/RabbitMQ-basic-concepts</id>
    <published>2023-02-19T13:37:33.000Z</published>
    <updated>2023-02-19T14:01:10.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><p>点对点模式：一个消息被一个消费者消费；<br>发布订阅模式：一个消息被多个消费者消费。</p><h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><p>交换机负责消息转发，不具备存储消息的能力，没有匹配的队列时，消息会丢失。<br>扇形交换机：Fanout ，广播，将消息发给所有绑定到交换机的队列；<br>直连交换机：Direct，定向，消息的 routing key 和 队列 binding key 对应投递；<br>主题交换机：Topic，通配符，将消息交给符合指定 routing pattern 的队列；</p><h1 id="消息流程"><a href="#消息流程" class="headerlink" title="消息流程"></a>消息流程</h1><p>生产者向交换机发送一条消息，交换机通过 routing key 和队列绑定规则(binding key)，将消息分发到队列。<br><img src="/images/rabbit-mq.webp" alt="mq"></p><h1 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h1><ol><li>推：消费者用 channel.basicConsume 订阅队列，RabbitMQ 会推送消息给消费者；</li><li>拉：消费者用 channel.basicGet 主动从指定队列拉取消息；</li></ol><h1 id="消息队列用途"><a href="#消息队列用途" class="headerlink" title="消息队列用途"></a>消息队列用途</h1><p>解耦：功能模块之间通过消息进行关系解耦；<br>削峰填谷：保护系统不因短期大流量冲击而服务崩溃；<br>冗余数据：防止系统在保存数据时崩溃导致数据丢失；<br>顺序消费：能保持消息被顺序消费；</p><h1 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h1><p>死信（Dead Letter）产生原因可能是：</p><ol><li>消费者拒收了，basic.reject、basic.nack、requeue&#x3D;false</li><li>消息超时过期了，ttl</li><li>消息数量超出队列长度了</li></ol><h2 id="配置死信交换机"><a href="#配置死信交换机" class="headerlink" title="配置死信交换机"></a>配置死信交换机</h2><p>策略(Policy)和队列参数(Optional Queue Arguments)两种方式。</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy DLX <span class="string">&quot;.*&quot;</span> <span class="string">&#x27;&#123;&quot;dead-letter-exchange&quot;:&quot;my-dlx&quot;&#125;&#x27;</span> --apply-to queues</span><br></pre></td></tr></table></figure><p>这里将名为 my-dlx 的死信交换机应用到全部队列。</p><h2 id="队列参数"><a href="#队列参数" class="headerlink" title="队列参数"></a>队列参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; queueArgs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;myExchange&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">queueArgs.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;myExchange&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myQueue&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, queueArgs);</span><br></pre></td></tr></table></figure><h2 id="死信路由"><a href="#死信路由" class="headerlink" title="死信路由"></a>死信路由</h2><ol><li>队列参数中定义 x-dead-letter-routing-key；</li><li>否则使用消息上的 routing key 去找死信交换机；</li></ol><h2 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h2><p>死信路由出现死循环，死信就会被丢弃。如：死信没定义 routing key 并投递到默认交换机。</p><h1 id="消息不丢失"><a href="#消息不丢失" class="headerlink" title="消息不丢失"></a>消息不丢失</h1><ol><li>消息生产阶段：从消息被生产出来，然后提交给 MQ 的过程中，只要能正常收到 MQ Broker 的 ack 确认响应，就表示发送成功，所以只要处理好返回值和异常，这个阶段是不会出现消息丢失的。</li><li>消息存储阶段：这个阶段一般会直接交给 MQ 消息中间件来保证，但是你要了解它的原理，比如 Broker 会做副本，保证一条消息至少同步两个节点再返回 ack。</li><li>消息消费阶段：消费端从 Broker 上拉取消息，只要消费端在收到消息后，不立即发送消费确认给 Broker，而是等到执行完业务逻辑后，再发送消费确认，也能保证消息的不丢失。</li><li>进阶：给每个发出的消息都指定一个全局唯一 ID，或者附加一个连续递增的版本号，然后在消费端做对应的版本校验。利用拦截器机制。在生产端发送消息之前，通过拦截器将消息版本号注入消息。</li></ol><h1 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h1><p>建立消息消费日志表。查询消费日志后再去消费，再更新消费日志</p><h1 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul><li>消费者数量不足；</li><li>消费者处理速度慢；</li><li>消息生产速度过快；</li><li>队列没有被正确地消费；</li><li>消费者拒绝消费(basic.reject、basic.nack)：<ul><li>basic.reject 拒绝单个消息，requeue&#x3D;true，重新排队，堆积</li><li>basic.nack 一次性拒绝多个消息，requeue&#x3D;true，重新排队，堆积</li></ul></li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul><li>增加消费者数量，加快消息的消费速度；</li><li>优化消费者的处理逻辑，提高消费速度；</li><li>增加队列的大小，缓解消息积累的问题；</li><li>限制消息的生产速度，防止消息过快地进入队列；</li><li>检查消费者是否正常工作，以及是否正确地处理了消息；</li><li>配置消息过期时间，及时清理过期消息；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模式&quot;&gt;&lt;a href=&quot;#模式&quot; class=&quot;headerlink&quot; title=&quot;模式&quot;&gt;&lt;/a&gt;模式&lt;/h1&gt;&lt;p&gt;点对点模式：一个消息被一个消费者消费；&lt;br&gt;发布订阅模式：一个消息被多个消费者消费。&lt;/p&gt;
&lt;h1 id=&quot;交换机&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="RabbitMQ" scheme="https://chengshen.me/categories/RabbitMQ/"/>
    
    
    <category term="RabbitMQ" scheme="https://chengshen.me/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Docker dockerfile</title>
    <link href="https://chengshen.me/microservices/Docker-dockerfile"/>
    <id>https://chengshen.me/microservices/Docker-dockerfile</id>
    <published>2023-02-19T10:32:48.000Z</published>
    <updated>2023-02-19T11:06:49.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install emacs</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install apache2</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><code>FROM debian</code>：将 debian 镜像作为基础镜像<br><code>RUN apt-get install emacs</code>：安装 emacs<br><code>RUN apt-get install apache2</code>：安装 apache2<br><code>CMD [&quot;/bin/bash&quot;]</code>：执行 bash</p><h1 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h1><p>FROM 用来初始化新的生成阶段，并为后续指令提供基本映像。<br>多个 FROM 代表<code>多阶段</code>构建。<br>Dockerfile 一般以 FROM 开头，ARG 是唯一能在 FROM 之前的指令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span>  CODE_VERSION=latest</span><br><span class="line"><span class="keyword">FROM</span> base:$&#123;CODE_VERSION&#125;</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash">  /code/run-app</span></span><br></pre></td></tr></table></figure><h1 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h1><ol><li>shell 模式：RUN <command></li><li>exec 模式：RUN [“executable”, “param1”, “param2”]</li></ol><p>RUN 会创建新的层（Layer），在新的层上执行命令，并提交（commit）执行结果。<br>shell 模式会调用 shell，exec 模式不会调用 shell。<br>exec 模式默认不会进行字符串替换（指的是变量替换），但可以通过显式调用 shell 的形式处理：</p><p>exec 模式调用 shell，$HOME 为变量：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo <span class="variable">$HOME</span>&quot;</span> ]</span></span><br></pre></td></tr></table></figure><h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><ol><li>exec 模式，首选：CMD [“executable”,”param1”,”param2”]</li><li>为 ENTRYPOINT 提供默认参数形式：CMD [“param1”,”param2”]</li><li>shell 模式：CMD command param1 param2</li></ol><p>一个 Dockerfile 中只能有一个 CMD，如果有多个，也只有最后一个有效。<br>CMD 主要用途是给执行容器默认行为，如：指定默认执行文件。<br>如果 CMD 用的第 2 中模式（为 ENTRYPOINT 提供默认参数形式），那么 ENTRYPOINT 指令也应该用字符串数组的形式，CMD 的值就会是 ENTRYPOINT 默认参数。<br>不要将 RUN 与 CMD 混淆。RUN 实际上运行一个命令并提交结果；CMD 在构建时不执行任何操作，而是为镜像提前设置执行指令。</p><h1 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h1><p>声明哪些端口是将要开放的，docker run 时 使用 -P（P 是大写的）进行随机端口关联映射。或者使用<br>docker run -p 外部端口:容器端口 镜像名。所以 Dockerfile 中使用 EXPOSE 用处不大。</p><h1 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h1><p>设置环境变量，会被持久化进容器。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> MY_NAME=<span class="string">&quot;John Doe&quot;</span>  MY_DOG=<span class="string">&quot;Rex The Dog&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> MY_VAR my-value</span><br></pre></td></tr></table></figure><p>如果不希望 ENV 环境变量持久化进容器，可以使用行内变量：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> DEBIAN_FRONTEND=noninteractive apt-get update &amp;&amp; apt-get install -y ...</span></span><br></pre></td></tr></table></figure><p>这里的 DEBIAN_FRONTEND&#x3D;noninteractive 就是行内变量。<br>或者 ARG 指令也能实现不持久化变量到容器。</p><h1 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [--checksum=&lt;checksum&gt;] &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="string">&quot;&lt;src&gt;&quot;</span>,... <span class="string">&quot;&lt;dest&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>–chown 只支持 Linux 容器。<br>ADD 作用是：从 src 复制文件到镜像中 dest 路径，会创建新的层。<br>src 可以是：本地文件、目录、url 形式的远程文件。<br>如果 src 是本地的压缩文件（.tar.xz），ADD 会自动解压到镜像中。<br>多 src 的，路径被解析为相对路径（相对于 build 路径）。<br>src 可以包含通配符：* 多字符，? 单字符。</p><h1 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="string">&quot;&lt;src&gt;&quot;</span>,... <span class="string">&quot;&lt;dest&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>COPY 功能和 ADD 类似，同样会创建新的层。<br>src 可以是：本地文件、目录。<br>ADD 和 COPY 两者，更推荐使用 COPY。</p><h1 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h1><p>Dockerfile 中 WORKDIR 指令为后续的 RUN、CMD、ENTRYPOINT、COPY、ADD 等指令设置工作目录。<br>多 WORKDIR 指令，如果提供了相对路径，则后出现的 WORKDIR 是基于先前出现的 WORKDIR 的路径的。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure><h1 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h1><ol><li>exec 模式：ENTRYPOINT [“executable”, “param1”, “param2”]</li><li>shell 模式：ENTRYPOINT command param1 param2</li></ol><p>docker run [image] [arguments] 的 arguments 部分会追加到 exec 模式的 ENTRYPOINT 指令数组的后面，并且会替换 CMD 指令中所有元素。如果想替换 ENTRYPOINT，使用 docker run –entrypoint。<br>shell 模式的 ENTRYPOINT 会阻止<br>Dockerfile 中只有最后一个 ENTRYPOINT 是有效指令。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>假设一个简单的场景：公司的服务器需要定期清理旧的日志文件。</p><figure class="highlight bash"><figcaption><span>clean_log 文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;即将删除 <span class="variable">$1</span> 天前的日志文件&quot;</span></span><br><span class="line">find /log_dir -ctime <span class="string">&quot;<span class="variable">$1</span>&quot;</span> -name <span class="string">&#x27;*log&#x27;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><figcaption><span>dockerfile 文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">14.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 clean_log 脚本添加到镜像中</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> clean_log /usr/bin/clean_log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 clean_log 可执行</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /usr/bin/clean_log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将此镜像的入口点定义为 clean_log 脚本</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/bin/clean_log&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为 ENTRYPOINT 提供默认参数，7天</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;7&quot;</span>]</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>构建镜像</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t log-cleaner .</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>运行镜像</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /var/log/myapplogs:/log_dir log-cleaner 365</span><br></pre></td></tr></table></figure><p>上述命令将 &#x2F;var&#x2F;log&#x2F;myapplogs 目录挂载到容器内部的脚本指定的目录，并且 365 这个值会替换掉 CMD 的 7。</p><h1 id="RUN、CMD-和-ENTRYPOINT"><a href="#RUN、CMD-和-ENTRYPOINT" class="headerlink" title="RUN、CMD 和 ENTRYPOINT"></a>RUN、CMD 和 ENTRYPOINT</h1><p>Dockerfile 中 RUN、CMD 和 ENTRYPOINT 都能够用于执行命令，下面是三者的主要用途：<br><code>RUN</code>：命令执行命令并创建新的镜像层，通常用于安装软件包；<br><code>CMD</code>：命令设置容器启动后默认执行的命令及其参数，但 CMD 设置的命令能够被 docker run 命令后面的命令行参数替换。一个 Dockerfile 至多只能有一个 CMD，如果有多个，只有最后一个生效。如果我们在 docker run 时指定了命令或者有 ENTRYPOINT，那么 CMD 就会被覆盖；<br><code>ENTRYPOINT</code>：配置容器启动时的执行命令，不会被忽略，一定会被执行，即使 docker run 时指定了其他命令。如果存在多个 ENTRYPOINT 命令，则只会执行最后一个 ENTRYPOINT 命令。</p><h2 id="RUN-1"><a href="#RUN-1" class="headerlink" title="RUN"></a>RUN</h2><figure class="highlight dockerfile"><figcaption><span>错误写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:jessie</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y gcc libc6-dev make</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis install</span></span><br></pre></td></tr></table></figure><p>该写法会创建 7 层镜像，这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。</p><figure class="highlight dockerfile"><figcaption><span>合理写法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:jessie</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> buildDeps=<span class="string">&#x27;gcc libc6-dev make&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">mkdir</span> -p /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> redis.tar.gz \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> -r /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span></span><br></pre></td></tr></table></figure><h2 id="CMD-1"><a href="#CMD-1" class="headerlink" title="CMD"></a>CMD</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://ip.cn&quot;</span> ]</span></span><br></pre></td></tr></table></figure><p>该镜像作用是查机器的 IP。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myip</span><br><span class="line">docker run myip</span><br></pre></td></tr></table></figure><p>如果想替换 Dockerfile 中 CMD 中参数，执行一下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run myip curl -s http://ip.cn -i</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>RUN、ADD、COPY 这三个指令都会创建新的层。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h1&gt;&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="Docker" scheme="https://chengshen.me/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://chengshen.me/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 常用指令</title>
    <link href="https://chengshen.me/microservices/Docker-commands"/>
    <id>https://chengshen.me/microservices/Docker-commands</id>
    <published>2023-02-19T10:17:38.000Z</published>
    <updated>2023-02-19T10:31:51.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>docker image ls</td><td>查看所有镜像</td></tr><tr><td>docker images</td><td>查看所有镜像</td></tr><tr><td>docker images</td><td>查看所有镜像</td></tr><tr><td>docker pull</td><td>下载镜像</td></tr><tr><td>docker rmi</td><td>删除镜像</td></tr><tr><td>docker build</td><td>使用 Dockerfile，生成镜像</td></tr></tbody></table><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>docker create</td><td>将镜像创建为容器</td></tr><tr><td>docker ps</td><td>查看所有容器，ps &#x3D; process status</td></tr><tr><td>docker start</td><td>启动容器</td></tr><tr><td>docker stop</td><td>停止容器</td></tr><tr><td>docker logs</td><td>查看容器运行日志</td></tr><tr><td>docker run</td><td>创建并运行一个容器 docker create + docker start</td></tr><tr><td>docker cp</td><td>把本地文件复制到容器，或相反方向也行</td></tr><tr><td>docker diff</td><td>查看容器文件的变化</td></tr><tr><td>docker exec</td><td>在容器中运行命令</td></tr><tr><td>docker commit</td><td>将修改的容器创建为镜像</td></tr><tr><td>docker tag</td><td>为镜像分配一个标记</td></tr><tr><td>docker login</td><td>镜像中登录</td></tr><tr><td>docker logout</td><td>镜像中注销</td></tr><tr><td>docker push</td><td>将镜像发布到仓库</td></tr><tr><td>docker inspect</td><td>查看容器详细配置</td></tr></tbody></table><h2 id="详细指令"><a href="#详细指令" class="headerlink" title="详细指令"></a>详细指令</h2><table><thead><tr><th align="left">指令</th><th>含义</th></tr></thead><tbody><tr><td align="left">docker images -q</td><td>返回全部镜像的 id 集合，-q &#x3D; –quiet</td></tr><tr><td align="left">docker rmi -f $(docker images -q)</td><td>删除全部镜像</td></tr><tr><td align="left">docker create -p 3000:80 –name myApp linux:latest</td><td>用 linux 创建容器；外 3000 内 80；名为 myApp</td></tr><tr><td align="left">docker ps -a</td><td>查看所有容器(已启动 + 未启动)</td></tr><tr><td align="left">docker start myApp</td><td>启动 myApp 容器</td></tr><tr><td align="left">docker start $(docker ps -aq)</td><td>启动所有容器</td></tr><tr><td align="left">docker stop myApp</td><td>停止 myApp 容器</td></tr><tr><td align="left">docker logs myApp</td><td>打印日志</td></tr><tr><td align="left">docker logs -f myApp</td><td>实时打印日志</td></tr><tr><td align="left">docker exec -it myApp &#x2F;bin&#x2F;bash</td><td>进入容器，开启交互式终端，用 bash</td></tr><tr><td align="left">docker commit myApp newName:tagName</td><td>将 myApp 容器保存为镜像</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;指令&quot;&gt;&lt;a href=&quot;#指令&quot; class=&quot;headerlink&quot; title=&quot;指令&quot;&gt;&lt;/a&gt;指令&lt;/h1&gt;&lt;h2 id=&quot;镜像操作&quot;&gt;&lt;a href=&quot;#镜像操作&quot; class=&quot;headerlink&quot; title=&quot;镜像操作&quot;&gt;&lt;/a&gt;镜像操作&lt;/h</summary>
      
    
    
    
    <category term="Docker" scheme="https://chengshen.me/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://chengshen.me/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 镜像和容器</title>
    <link href="https://chengshen.me/microservices/Docker-images"/>
    <id>https://chengshen.me/microservices/Docker-images</id>
    <published>2023-02-19T10:07:48.000Z</published>
    <updated>2023-02-19T10:16:40.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。<br>镜像由文件系统叠加而成，最底端是一个引导文件系统(bootfs)。</p><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>当一个容器启动后，镜像会被移到内存中，而引导文件系统则会被卸载。<br>一个镜像可以放到另一个镜像的顶部，位于下面为父镜像，最底部的为基础镜像。</p><p><img src="/images/%E9%95%9C%E5%83%8F1.png" alt="镜像结构"><br><img src="/images/%E9%95%9C%E5%83%8F3.png" alt="镜像结构"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;镜像&quot;&gt;&lt;a href=&quot;#镜像&quot; class=&quot;headerlink&quot; title=&quot;镜像&quot;&gt;&lt;/a&gt;镜像&lt;/h1&gt;&lt;p&gt;镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时库、环</summary>
      
    
    
    
    <category term="Docker" scheme="https://chengshen.me/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://chengshen.me/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Redis 布隆过滤器</title>
    <link href="https://chengshen.me/database/Redis-bloon-filter"/>
    <id>https://chengshen.me/database/Redis-bloon-filter</id>
    <published>2023-02-18T07:51:41.000Z</published>
    <updated>2023-02-18T07:56:43.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>一个很长的二进制向量（位数组）和一系列随机映射函数。<br>优点：空间效率和查询时间都比一般的算法要好的多；<br>缺点：有一定的误识别率和删除困难。<br>Redis 中的布隆过滤器底层是一个大型<code>位数组</code>（二进制数组）和多个<code>无偏散列函数</code>。<br>位数组越长，空间占用较大，错误率越低；无偏 hash 函数越多，计算耗时较长，错误率越低；</p><h1 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h1><p>通过 k 个无偏 hash 函数计算得到 k 个 hash 值，依次取模数组长度，得到数组索引，将计算得到的数组索引下标位置数据修改为 1</p><h1 id="匹配数据"><a href="#匹配数据" class="headerlink" title="匹配数据"></a>匹配数据</h1><p>通过 k 个无偏 hash 函数计算得到 k 个 hash 值，依次取模数组长度，得到数组索引，判断索引处的值是否全部为 1，如果全部为 1 则<code>可能存在</code>，如果存在一个 0 则<code>必定不存在</code>，1%误判率。</p><h1 id="为什么是“可能存在”"><a href="#为什么是“可能存在”" class="headerlink" title="为什么是“可能存在”"></a>为什么是“可能存在”</h1><p>其实原因很简单，那些被置为 1 的位置也可能是由于其他元素的操作而改变的。<br>比如，元素 1 和 元素 2，这两个元素同时将一个位置变为了 1。<br>在这种情况下，我们就不能判定“元素 1”一定存在，这是布隆过滤器存在误判的根本原因。</p><p>布隆过滤器牺牲了判断的准确率、删除的便利性 ，才做到在时间和空间上的效率比较高，是因为：</p><ul><li>存在误判，可能要查到的元素并没有在容器中，但是 hash 之后得到的 k 个位置上值都是 1。如果 bloom filter 中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。</li><li>删除数据。一个放入容器的元素映射到 bit 数组的 k 个位置上是 1，删除的时候不能简单的直接置为 0，可能会影响其他元素的判断。可以考虑 Counting Bloom Filter</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;布隆过滤器&quot;&gt;&lt;a href=&quot;#布隆过滤器&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器&quot;&gt;&lt;/a&gt;布隆过滤器&lt;/h1&gt;&lt;p&gt;一个很长的二进制向量（位数组）和一系列随机映射函数。&lt;br&gt;优点：空间效率和查询时间都比一般的算法要好的多；&lt;br&gt;</summary>
      
    
    
    
    <category term="Redis" scheme="https://chengshen.me/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://chengshen.me/tags/Redis/"/>
    
    <category term="Bloon Filter" scheme="https://chengshen.me/tags/Bloon-Filter/"/>
    
  </entry>
  
  <entry>
    <title>Redis 事务</title>
    <link href="https://chengshen.me/database/Redis-transaction"/>
    <id>https://chengshen.me/database/Redis-transaction</id>
    <published>2023-02-18T07:49:47.000Z</published>
    <updated>2023-02-18T07:50:36.714Z</updated>
    
    <content type="html"><![CDATA[<p>MULTI 开启一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务。<br>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">SET book-name <span class="string">&quot;Mastering C++ in 21 days</span></span><br><span class="line"><span class="string">SADD tag &quot;</span>C++<span class="string">&quot; &quot;</span>Programming<span class="string">&quot; &quot;</span>Mastering Series<span class="string">&quot;</span></span><br><span class="line"><span class="string">EXEC</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MULTI 开启一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务。&lt;br&gt;单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的，中间某条指令的失败不会导致前面已做指令</summary>
      
    
    
    
    <category term="Redis" scheme="https://chengshen.me/categories/Redis/"/>
    
    
    <category term="Transaction" scheme="https://chengshen.me/tags/Transaction/"/>
    
    <category term="Redis" scheme="https://chengshen.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 持久化</title>
    <link href="https://chengshen.me/database/Redis-persistence"/>
    <id>https://chengshen.me/database/Redis-persistence</id>
    <published>2023-02-18T07:47:34.000Z</published>
    <updated>2023-02-18T07:49:07.718Z</updated>
    
    <content type="html"><![CDATA[<p>redis 持久化有 RDB 和 AOF 两种，redis 持久化是为了后期出现故障能恢复数据到内存。<br>如果 redis 同时使用 RDB 和 AOF 持久化，redis 会优先使用 AOF 进行恢复数据。</p><h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><p>RDB（Redis DataBase，快照持久化），就是完整记录某时刻全部数据。</p><ul><li>save，阻塞主线程；</li><li>bgsave，子进程去做持久化；</li><li>自动持久化：save m n，m 秒内发生 n 次变化时，会触发 bgsave。</li><li>数据恢复：redis 重启会自动从 dump.rdb 中恢复数据。</li></ul><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>AOF（Append Only File，文件追加持久化），向日志文件中追加写操作，会忽略读操作，redis 启动之初会读取该文件重新构建数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;redis 持久化有 RDB 和 AOF 两种，redis 持久化是为了后期出现故障能恢复数据到内存。&lt;br&gt;如果 redis 同时使用 RDB 和 AOF 持久化，redis 会优先使用 AOF 进行恢复数据。&lt;/p&gt;
&lt;h1 id=&quot;RDB&quot;&gt;&lt;a href=&quot;#RDB</summary>
      
    
    
    
    <category term="Redis" scheme="https://chengshen.me/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://chengshen.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 线程模型</title>
    <link href="https://chengshen.me/database/Redis-thread-model"/>
    <id>https://chengshen.me/database/Redis-thread-model</id>
    <published>2023-02-18T07:44:51.000Z</published>
    <updated>2023-02-18T07:46:23.972Z</updated>
    
    <content type="html"><![CDATA[<p>数据<code>增删改查</code>用单线程处理，线程安全。<br>Redis 6.0 中耗时的 Socket 读取、请求解析、单独用一个线程来处理，即：网络 IO 是多线程的。</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>Redis3.0 中的 BIO 线程：文件关闭、AOF 缓冲数据刷新到磁盘，以及清理对象。</p><h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><p>BGSAVE 用于快照持久化，会 fork 出一个子进程去处理。</p><h1 id="为什么单线程"><a href="#为什么单线程" class="headerlink" title="为什么单线程"></a>为什么单线程</h1><p>因为 Redis 是内存操作，CPU 不是 Redis 的瓶颈；<br>单线程避免频繁多线程上下文切换的性能问题；<br>Redis 采用非阻塞的 io 多路复用机制；</p><h1 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h1><p>单线程或单进程同时监测多个文件描述符是否可以执行 IO 操作的能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据&lt;code&gt;增删改查&lt;/code&gt;用单线程处理，线程安全。&lt;br&gt;Redis 6.0 中耗时的 Socket 读取、请求解析、单独用一个线程来处理，即：网络 IO 是多线程的。&lt;/p&gt;
&lt;h1 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="Redis" scheme="https://chengshen.me/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://chengshen.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 缓存</title>
    <link href="https://chengshen.me/database/Redis-cache"/>
    <id>https://chengshen.me/database/Redis-cache</id>
    <published>2023-02-18T07:38:04.000Z</published>
    <updated>2023-02-18T07:43:27.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>缓存穿透，缓存击穿，缓存雪崩</p><ul><li>缓存穿透(多次)：频繁查询数据库中不存在的数据。利用此进行攻击，可能压垮数据库；</li><li>缓存击穿(一次)：缓存过期时大量并发请求；</li><li>缓存雪崩：缓存服务重启或大量缓存集中失效，给后端系统(如 DB)带来很大压力；</li></ul><h1 id="应对"><a href="#应对" class="headerlink" title="应对"></a>应对</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ul><li>缓存空数据；</li><li>布隆过滤器，过滤不存在的数据请求；</li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><ul><li>互斥锁(redis.setnx)，拿锁后查数据库，再缓存；</li><li>热门数据不过期；</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><ul><li>对数据设置不同的过期时间；</li><li>互斥锁；</li></ul><h1 id="过期策略-过期时"><a href="#过期策略-过期时" class="headerlink" title="过期策略(过期时)"></a>过期策略(过期时)</h1><ul><li>定期删除，每个 100ms 随机抽取一些设置了过期时间的 key，如果过期就删除。</li><li>惰性删除，用的时候检查是否过期，如果过期就删除。</li></ul><h1 id="淘汰机制-内存满时"><a href="#淘汰机制-内存满时" class="headerlink" title="淘汰机制(内存满时)"></a>淘汰机制(内存满时)</h1><ul><li>noeviction：不淘汰数据，默认。内存使用达到阀值后，引起申请内存的命令都会报错。</li><li>volatile-ttl：淘汰将要过期的数据。</li><li>volatile-lru：淘汰最近最少使用（过期数据）。</li><li>volatile-lfu：淘汰低使用频率（过期数据）</li><li>volatile-random：随机淘汰（过期数据）。</li><li>allkeys-lru：淘汰最近最少使用（全部数据）。</li><li>allkeys-random：随机淘汰（全部数据）。</li><li>allkey-lfu：淘汰低使用频率（全部数据）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;缓存穿透，缓存击穿，缓存雪崩&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存穿透(多次)：频繁查询数据库中不存在的数据。利用此进行攻击，可能压垮数据库；&lt;/</summary>
      
    
    
    
    <category term="Redis" scheme="https://chengshen.me/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://chengshen.me/tags/Redis/"/>
    
    <category term="Cache" scheme="https://chengshen.me/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>Redis 使用场景</title>
    <link href="https://chengshen.me/database/Redis-usecases"/>
    <id>https://chengshen.me/database/Redis-usecases</id>
    <published>2023-02-18T07:34:46.000Z</published>
    <updated>2023-02-18T07:37:28.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h1 id="分布式数据共享"><a href="#分布式数据共享" class="headerlink" title="分布式数据共享"></a>分布式数据共享</h1><p>分布式 Session</p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>借助 string 的 set。</p><p>set 有如下参数：<br>EX：设置键的过期时间（单位为秒）；<br>PX：设置键的过期时间（单位为毫秒）；<br>NX：只在键不存在时，才对键进行设置操作，set key value NX 和 SETNX key value 等价；<br>XX：只在键已经存在时，才对键进行设置操作；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> lock_key lock_value NX EX 1</span><br></pre></td></tr></table></figure><p>结果：<br>如果返回 false，说明 key 的添加不成功，也就是当前有人在占用这把锁；<br>如果返回 true，则说明得了锁，便可以继续进行操作；<br>并且在操作后通过 del 命令释放掉锁，而且设置了过期时间，该锁也会在 1 秒后自动释放。</p><h1 id="全局-ID"><a href="#全局-ID" class="headerlink" title="全局 ID"></a>全局 ID</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incrby userid <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h1><p>int 类型，incr 方法。</p><h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><p>int 类型，incr 方法，以访问者的 ip 和其他信息作为 key，访问一次增加一次计数，超过次数则返回 false。</p><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>Redis 中 list 的数据结构实现是双向链表，所以可以非常便捷的应用于消息队列，lpush 将消息放入 list，消费者便可以通过 rpop 取出该消息。</p><h1 id="抽奖"><a href="#抽奖" class="headerlink" title="抽奖"></a>抽奖</h1><p>利用 set 结构的无序性，通过 spop 随机获得值。</p><h1 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h1><p>利用 sorted set</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; class=&quot;headerlink&quot; title=&quot;缓存&quot;&gt;&lt;/a&gt;缓存&lt;/h1&gt;&lt;h1 id=&quot;分布式数据共享&quot;&gt;&lt;a href=&quot;#分布式数据共享&quot; class=&quot;headerlink&quot; title=&quot;分布式数据共享&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="Redis" scheme="https://chengshen.me/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://chengshen.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 数据类型</title>
    <link href="https://chengshen.me/database/Redis-data-types"/>
    <id>https://chengshen.me/database/Redis-data-types</id>
    <published>2023-02-18T07:32:02.000Z</published>
    <updated>2023-02-18T07:33:39.418Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>类型</th><th>类型</th></tr></thead><tbody><tr><td>String</td><td>字符串</td></tr><tr><td>Hash</td><td>散列</td></tr><tr><td>List</td><td>列表</td></tr><tr><td>Set</td><td>集合</td></tr><tr><td>Sorted Set</td><td>有序集合</td></tr><tr><td>Bitmap</td><td>布隆过滤器</td></tr><tr><td>GeoHash</td><td>存储地理位置信息，并对存储的信息进行操作</td></tr><tr><td>HyperLogLog</td><td>用来做基数统计的算法</td></tr><tr><td>Streams</td><td>内存版 Kafka，消息订阅发布</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hash&lt;/td&gt;
&lt;td&gt;散列&lt;/td&gt;
&lt;/</summary>
      
    
    
    
    <category term="Redis" scheme="https://chengshen.me/categories/Redis/"/>
    
    
    <category term="Data Types" scheme="https://chengshen.me/tags/Data-Types/"/>
    
    <category term="Redis" scheme="https://chengshen.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 综合</title>
    <link href="https://chengshen.me/database/MySQL-summaries"/>
    <id>https://chengshen.me/database/MySQL-summaries</id>
    <published>2023-02-18T06:48:40.000Z</published>
    <updated>2023-02-18T07:28:16.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="group-concat"><a href="#group-concat" class="headerlink" title="group_concat"></a>group_concat</h1><p>把 name 相同的 code 拼接在一起</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name,group_concat(code) <span class="keyword">from</span> `students` <span class="keyword">group</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure><table><thead><tr><th>name</th><th>group_concat(code)</th></tr></thead><tbody><tr><td>xiaosan</td><td>001,002</td></tr><tr><td>sanhuo</td><td>004,008</td></tr></tbody></table><h1 id="char-length"><a href="#char-length" class="headerlink" title="char_length"></a>char_length</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> students <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%san%&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">char_length</span>(name);</span><br></pre></td></tr></table></figure><p>根据字符长度排序：</p><table><thead><tr><th>name</th></tr></thead><tbody><tr><td>sanhuo</td></tr><tr><td>xiaosan</td></tr></tbody></table><h1 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h1><p>返回关键词在目标字段中的位置。</p><h1 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h1><p>替换字段中的内容。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> students <span class="keyword">set</span> name<span class="operator">=</span>REPLACE(name,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>)  <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1 id="now"><a href="#now" class="headerlink" title="now"></a>now</h1><p>获取当前时间，时间包含毫秒使用 now(3)。</p><h1 id="insert-into-…-select"><a href="#insert-into-…-select" class="headerlink" title="insert into … select"></a>insert into … select</h1><p>从一个表中选数据插入到另一个表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `students`(`id`, `code`, `name`) <span class="keyword">select</span> <span class="keyword">null</span>,code,name <span class="keyword">from</span> `student_infos` <span class="keyword">where</span> code <span class="keyword">in</span> (<span class="string">&#x27;004&#x27;</span>,<span class="string">&#x27;005&#x27;</span>);</span><br></pre></td></tr></table></figure><h1 id="insert-into-…-ignore"><a href="#insert-into-…-ignore" class="headerlink" title="insert into … ignore"></a>insert into … ignore</h1><p>根据主键索引或唯有索引，插入或忽略数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> ignore <span class="keyword">INTO</span> `students`(`id`, `code`, `name`) <span class="keyword">VALUES</span> (<span class="number">123</span>, <span class="string">&#x27;108&#x27;</span>, <span class="string">&#x27;苏三&#x27;</span>);</span><br></pre></td></tr></table></figure><h1 id="select-…-for-update"><a href="#select-…-for-update" class="headerlink" title="select … for update"></a>select … for update</h1><p>行锁、悲观锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">12345</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 该条数据的修改处理</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h1 id="on-duplicate-key-update"><a href="#on-duplicate-key-update" class="headerlink" title="on duplicate key update"></a>on duplicate key update</h1><p>如果主键或唯一索引不存在，则插入数据；<br>如果主键或唯一索引存在，则更新数据。<br>高并发的场景下使用 on duplicate key update 语法，可能会存在死锁的问题</p><h1 id="show-create-table"><a href="#show-create-table" class="headerlink" title="show create table"></a>show create table</h1><p>显示表创建语句。</p><h1 id="create-table-…-select"><a href="#create-table-…-select" class="headerlink" title="create table … select"></a>create table … select</h1><p>创建表，并从某个表中选数据插入到创建的表中。<br>应用场景：快速备份表。</p><h1 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h1><p>可以使用 explain 命令，查看 mysql 的执行计划，它会显示索引的使用情况。</p><h1 id="show-processlist"><a href="#show-processlist" class="headerlink" title="show processlist"></a>show processlist</h1><p>查看数据库进程列表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> processlist</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.processlist limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h1 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h1><p>导出备份数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="operator">-</span>u root <span class="operator">-</span>p123456 dbname <span class="operator">&gt;</span> backup.sql</span><br></pre></td></tr></table></figure><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p><a href="https://mp.weixin.qq.com/s/_0umF8IBEzf9IHW2-e_LTQ">https://mp.weixin.qq.com/s/_0umF8IBEzf9IHW2-e_LTQ</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;group-concat&quot;&gt;&lt;a href=&quot;#group-concat&quot; class=&quot;headerlink&quot; title=&quot;group_concat&quot;&gt;&lt;/a&gt;group_concat&lt;/h1&gt;&lt;p&gt;把 name 相同的 code 拼接在一起&lt;/p&gt;
&lt;fig</summary>
      
    
    
    
    <category term="MySQL" scheme="https://chengshen.me/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://chengshen.me/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>NETCore 接口优化</title>
    <link href="https://chengshen.me/csharp/NETCore-api-optimization"/>
    <id>https://chengshen.me/csharp/NETCore-api-optimization</id>
    <published>2023-02-18T03:36:31.000Z</published>
    <updated>2023-02-18T03:45:43.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="增加缓存"><a href="#增加缓存" class="headerlink" title="增加缓存"></a>增加缓存</h1><p>如果接口返回的数据可以被缓存，可以使用缓存机制来减少接口访问的次数。可以使用本地缓存、分布式缓存或者 CDN 等不同的缓存方式，根据具体情况选择合适的方式进行优化。</p><h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><p>如果接口需要从数据库中查询数据，可以对数据库进行优化，例如增加索引、优化 SQL 查询语句、使用缓存等方式，减少数据库的查询次数，从而提高接口访问的性能。</p><h1 id="网络传输优化"><a href="#网络传输优化" class="headerlink" title="网络传输优化"></a>网络传输优化</h1><p>可以使用压缩技术来减少网络传输的数据量，减少接口访问的时间。也可以使用 CDN 等技术来加速数据传输，提高接口访问的速度。</p><h1 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h1><p>如果接口需要执行耗时的操作，可以使用异步处理来提高接口的响应速度。使用异步操作可以将耗时的操作放在后台进行，不影响接口的响应速度。</p><h1 id="使用缓存技术"><a href="#使用缓存技术" class="headerlink" title="使用缓存技术"></a>使用缓存技术</h1><p>对于经常被访问的数据，可以使用缓存技术来避免每次都从数据库中查询。可以使用内存缓存、Redis 缓存、分布式缓存等技术。</p><h1 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h1><p>可以对接口的代码进行优化，减少不必要的计算和数据传输，从而提高接口的性能。例如，减少使用循环和嵌套循环、尽量避免在循环中执行数据库查询等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;增加缓存&quot;&gt;&lt;a href=&quot;#增加缓存&quot; class=&quot;headerlink&quot; title=&quot;增加缓存&quot;&gt;&lt;/a&gt;增加缓存&lt;/h1&gt;&lt;p&gt;如果接口返回的数据可以被缓存，可以使用缓存机制来减少接口访问的次数。可以使用本地缓存、分布式缓存或者 CDN 等不同的缓存方</summary>
      
    
    
    
    <category term="NETCore" scheme="https://chengshen.me/categories/NETCore/"/>
    
    
    <category term="CSharp" scheme="https://chengshen.me/tags/CSharp/"/>
    
    <category term="NETCore" scheme="https://chengshen.me/tags/NETCore/"/>
    
  </entry>
  
  <entry>
    <title>CLR 反射</title>
    <link href="https://chengshen.me/csharp/CLR-reflection"/>
    <id>https://chengshen.me/csharp/CLR-reflection</id>
    <published>2023-02-18T03:27:59.000Z</published>
    <updated>2023-02-18T06:43:17.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>在运行时获取程序集元数据的能力。它使得程序能够在运行时读取自身的类型信息并执行与该类型相关的操作，例如动态创建类型、调用对象上的方法、读写对象的属性或字段，以及访问程序集中的元数据等。</p><h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><ul><li>对象关系映射(ORM)</li><li>面向切面编程(AOP)</li><li>代码生成</li><li>动态代理</li><li>插件系统：编辑器插件、浏览器插件</li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><h2 id="性能较差"><a href="#性能较差" class="headerlink" title="性能较差"></a>性能较差</h2><p>使用反射进行对象创建、属性赋值、方法调用等操作需要更多的时间和资源，因为这些操作需要在运行时动态计算和解析。相比于直接编写代码实现这些操作，使用反射会增加很多开销。</p><h2 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h2><p>反射可以绕过编译时的类型检查和访问权限检查，因此可能会带来安全性问题。如果恶意用户使用反射来访问不应该被访问的代码或数据，就可能会导致严重的安全漏洞。</p><h2 id="可读性较差"><a href="#可读性较差" class="headerlink" title="可读性较差"></a>可读性较差</h2><p>反射的代码通常比较难读懂，因为它涉及到很多动态计算和解析，可能会包含大量的复杂逻辑。相比于直接编写代码实现相同的功能，使用反射会增加代码的复杂度，降低代码的可读性。</p><h2 id="维护成本较高"><a href="#维护成本较高" class="headerlink" title="维护成本较高"></a>维护成本较高</h2><p>由于反射的代码比较难读懂和理解，因此维护成本也相对较高。如果使用反射编写的代码出现了问题，需要花费更多的时间和精力进行调试和修复。</p><h1 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h1><p>Activator.CreateInstance();<br>Activator.CreateInstanceFrom();<br>AppDomain.CreateDomain().CreateInstance();</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;在运行时获取程序集元数据的能力。它使得程序能够在运行时读取自身的类型信息并执行与该类型相关的操作，例如动态创建类型、调用对象上的方法、读写对</summary>
      
    
    
    
    <category term="CLR" scheme="https://chengshen.me/categories/CLR/"/>
    
    
    <category term="CLR" scheme="https://chengshen.me/tags/CLR/"/>
    
    <category term="CSharp" scheme="https://chengshen.me/tags/CSharp/"/>
    
    <category term="Reflection" scheme="https://chengshen.me/tags/Reflection/"/>
    
  </entry>
  
  <entry>
    <title>CLR AppDomain</title>
    <link href="https://chengshen.me/csharp/CLR-app-domain"/>
    <id>https://chengshen.me/csharp/CLR-app-domain</id>
    <published>2023-02-18T03:25:29.000Z</published>
    <updated>2023-02-18T03:26:35.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h1><p>代表一个应用程序的独立执行环境，在一个进程内可以存在多个 AppDomain。<br>这就允许不同的应用程序或组件运行在同一个进程中，但是它们相互隔离，不共享状态。<br>隔离不同的应用程序和组件，以保证程序的安全和稳定性，比如第三方不受信任的代码。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>两个 AppDomain 中对象无法直接相互访问；<br>AppDomain 可以卸载，程序集不行；<br>AppDomain 可以单独保护；<br>AppDomain 可以单独配置；</p><h1 id="跨-AppDomain"><a href="#跨-AppDomain" class="headerlink" title="跨 AppDomain"></a>跨 AppDomain</h1><p>按引用封送（Marshal-by-Reference）和按值封送（Marshal-by-Value）。</p><h1 id="Custom-Marshaling"><a href="#Custom-Marshaling" class="headerlink" title="Custom Marshaling"></a>Custom Marshaling</h1><p>封送是 Marsal 类提供的一组方法：</p><ul><li>分配非托管内存；</li><li>托管内存数据复制到非托管内存；</li><li>执行非托管函数；</li></ul><p>用于与非托管代码交互、调用从动态链接库（DLL）导出的函数或实现数据类型的自定义封送处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;含义&quot;&gt;&lt;a href=&quot;#含义&quot; class=&quot;headerlink&quot; title=&quot;含义&quot;&gt;&lt;/a&gt;含义&lt;/h1&gt;&lt;p&gt;代表一个应用程序的独立执行环境，在一个进程内可以存在多个 AppDomain。&lt;br&gt;这就允许不同的应用程序或组件运行在同一个进程中，但是它</summary>
      
    
    
    
    <category term="CLR" scheme="https://chengshen.me/categories/CLR/"/>
    
    
    <category term="CLR" scheme="https://chengshen.me/tags/CLR/"/>
    
    <category term="CSharp" scheme="https://chengshen.me/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>CLR 数据类型</title>
    <link href="https://chengshen.me/csharp/CLR-data-types"/>
    <id>https://chengshen.me/csharp/CLR-data-types</id>
    <published>2023-02-18T02:52:08.000Z</published>
    <updated>2023-02-18T03:24:02.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-基元类型"><a href="#C-基元类型" class="headerlink" title="C# 基元类型"></a>C# 基元类型</h1><p>指的是<code>不使用类</code>而直接定义的内置数据类型，由 C# 语言规范定义，属于语言层面，具有特定的语义和行为。</p><p>整数类型：sbyte、byte、short、ushort、int、uint、long 和 ulong<br>浮点类型：float 和 double<br>十进制类型：decimal<br>布尔类型：bool<br>字符类型：char<br>指针类型：指向其他类型的指针类型<br>空类型：void</p><h1 id="C-复杂类型"><a href="#C-复杂类型" class="headerlink" title="C# 复杂类型"></a>C# 复杂类型</h1><p>结构体、枚举和类，是由基元类型组成的。</p><h1 id="CLR-内置类型"><a href="#CLR-内置类型" class="headerlink" title="CLR 内置类型"></a>CLR 内置类型</h1><p>内置类型就是 .NET Framework System 命名空间中写好的类型。</p><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>bool、byte、char、decimal、double、enum、float、int、long、sbyte、short、struct、uint、ulong、ushort。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>object、string、dynamic。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>值类型是直接存储在<code>栈</code>中的，引用类型则是存储在<code>堆</code>中，而栈中存储的仅是指向堆中对象的引用。<br>值类型的内存管理由 CLR 自动处理，不需要手动释放，而引用类型则需要手动释放。</p><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>类、结构体、接口、委托。<br>自定义类型也称为“用户定义类型”或 “托管类型”。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>问：对比 object 和 dynamic<br>dynamic：派生自 object，在运行时动态解释，具有更多的<code>灵活性</code>和<code>动态性</code>，在运行时，编译器会根据实际类型执行<code>动态绑定</code>操作。<br>object：是静态类型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-基元类型&quot;&gt;&lt;a href=&quot;#C-基元类型&quot; class=&quot;headerlink&quot; title=&quot;C# 基元类型&quot;&gt;&lt;/a&gt;C# 基元类型&lt;/h1&gt;&lt;p&gt;指的是&lt;code&gt;不使用类&lt;/code&gt;而直接定义的内置数据类型，由 C# 语言规范定义，属于语言层面，</summary>
      
    
    
    
    <category term="CLR" scheme="https://chengshen.me/categories/CLR/"/>
    
    
    <category term="CLR" scheme="https://chengshen.me/tags/CLR/"/>
    
    <category term="CSharp" scheme="https://chengshen.me/tags/CSharp/"/>
    
    <category term="Data Types" scheme="https://chengshen.me/tags/Data-Types/"/>
    
  </entry>
  
  <entry>
    <title>CLR 字符串</title>
    <link href="https://chengshen.me/csharp/CLR-string"/>
    <id>https://chengshen.me/csharp/CLR-string</id>
    <published>2023-02-18T02:46:05.000Z</published>
    <updated>2023-02-18T02:51:05.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>字符串属于引用类型，具有不可变性。</p><h1 id="暂存池"><a href="#暂存池" class="headerlink" title="暂存池"></a>暂存池</h1><p>暂存池(intern) 是 CLR 维护的哈希表(字典)，键是字符串，值是对堆中该字符串对象的引用。</p><ol><li>暂存池由 CLR 维护，其中所有字符串的值都不同；</li><li>编译阶段字面量字符串会被添加到暂存池；</li><li>运行时期，用 string.Intern() 将动态创建的字符串添加到暂存池；</li></ol><h1 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h1><ol><li>用字面量；</li><li>用 string.Intern()；</li><li>用字面量 + 字面量拼接；</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a，b，c 指向的是同一个堆内存地址</span></span><br><span class="line"><span class="built_in">string</span> a = <span class="string">&quot;this is string&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> b = <span class="built_in">string</span>.Intern(<span class="keyword">new</span> StingBuilder(<span class="string">&quot;this is string&quot;</span>));</span><br><span class="line"><span class="built_in">string</span> c = <span class="string">&quot;this&quot;</span> + <span class="string">&quot; is &quot;</span> + <span class="string">&quot;string&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str1 和 str2 字符串地址不同</span></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str1 和 str2 字符串地址不同</span></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;abc&quot;</span>).ToString();</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str1 和 str2 指向的是同一个堆内存地址</span></span><br><span class="line"><span class="keyword">var</span> charArr = <span class="keyword">new</span> <span class="built_in">char</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> str1 = charArr.ToString();</span><br><span class="line"><span class="keyword">var</span> str2 = charArr.ToString();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h1&gt;&lt;p&gt;字符串属于引用类型，具有不可变性。&lt;/p&gt;
&lt;h1 id=&quot;暂存池&quot;&gt;&lt;a href=&quot;#暂存池&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="CLR" scheme="https://chengshen.me/categories/CLR/"/>
    
    
    <category term="CLR" scheme="https://chengshen.me/tags/CLR/"/>
    
    <category term="CSharp" scheme="https://chengshen.me/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>CLR 终结器</title>
    <link href="https://chengshen.me/csharp/CLR-finalize"/>
    <id>https://chengshen.me/csharp/CLR-finalize</id>
    <published>2023-02-18T02:42:52.000Z</published>
    <updated>2023-02-18T02:45:19.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>终结器(Finalize)，就是<code>析构函数</code>，由波浪线(<code>~</code>)和类名组成，不能被访问修饰符修饰。</p><ol><li>new 一个实例对象后，如果该类定义了 Finalize 方法，实例构造函数被调用前，会将本对象实例的指针放到终结器队列中，终结器队列是由垃圾回收器控制的数据结构。</li><li>需要进行垃圾回收时，终结器列表中的不可达对象会被移动到 freachable 队列，对于没 Finalize 方法的对象会先被垃圾回收器处理掉。</li><li>会有个专门的线程去调用 freachable 队列中对象的 Finalize 方法，freachable 队列为空，该线程就会休眠，一旦队列有记录项时，线程就会被唤醒，将每一项从队列中移除并调用 Finalize 方法。</li><li>freachable 队列就像是一个根集合，让对象变得可达，在下一次 GC 时，freachable 队列不再引用该对象，对象内存会被回收，经历两次垃圾回收才释放它们占用的内存。</li><li>实际情况中，由于对象可能会进入老一代中，垃圾回收次数就不止是两次。</li></ol><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ol><li>不要在 Finalize 方法中访问线程的本地存储。</li><li>在只有一个终结器线程情况下，可能多个 CPU 分配可终结对象，但只有一个线程执行 Finalize 方法，可能导致线程调用跟不上分配的速度，导致性能和伸缩性问题。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;终结器(Finalize)，就是&lt;code&gt;析构函数&lt;/code&gt;，由波浪线(&lt;code&gt;~&lt;/code&gt;)和类名组成，不能被访问修饰符修饰</summary>
      
    
    
    
    <category term="CLR" scheme="https://chengshen.me/categories/CLR/"/>
    
    
    <category term="CLR" scheme="https://chengshen.me/tags/CLR/"/>
    
    <category term="CSharp" scheme="https://chengshen.me/tags/CSharp/"/>
    
    <category term="Finalize" scheme="https://chengshen.me/tags/Finalize/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 慢查询排查</title>
    <link href="https://chengshen.me/database/MySQL-slow-query-troubleshooting"/>
    <id>https://chengshen.me/database/MySQL-slow-query-troubleshooting</id>
    <published>2023-02-16T09:04:39.000Z</published>
    <updated>2023-02-16T11:26:27.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h1><ol><li>查看“慢查询日志”找慢 SQL</li><li>explain“执行计划”查询</li><li>profile 执行耗时分析</li><li>Optimizer Trace</li></ol><h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><p>该功能默认是关闭的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看慢查询日志功能是否开启，默认 OFF</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询超时多久的查询才被记录日志</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;long_query_time&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看日志输出模式 FILE、TABLE</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">LIKE</span> <span class="string">&#x27;%log_output%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>用配置开启慢查询日志，持久性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line"># 开启慢查询日志</span><br><span class="line">slow_query_log = ON</span><br><span class="line"></span><br><span class="line"># 慢查询日志文件位置</span><br><span class="line">slow_query_log_file = dir\filename</span><br><span class="line"></span><br><span class="line"># 大于 3 秒就记录日志</span><br><span class="line">long_query_time = 3</span><br><span class="line"></span><br><span class="line"># 将未使用索引的查询记录日志</span><br><span class="line">log_queries_not_using_indexes = ON</span><br></pre></td></tr></table></figure><p>用命令开启慢查询日志，临时性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL slow_query_log=ON;</span><br><span class="line">SET GLOBAL long_query_time=3;</span><br><span class="line">SET GLOBAL slow_query_log_file=<span class="built_in">dir</span>\filename;</span><br></pre></td></tr></table></figure><p>查看记录的慢查询日志</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mysql.slow_log;</span><br></pre></td></tr></table></figure><h1 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h1><p>执行计划是模拟执行 SQL 查询，来查看执行策略。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;stu&#x27;</span> <span class="keyword">where</span> gender<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1 id="执行耗时分析"><a href="#执行耗时分析" class="headerlink" title="执行耗时分析"></a>执行耗时分析</h1><p>profile 根据最近执行的 SQL，显示执行耗时情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;stu&#x27;</span> <span class="keyword">where</span> gender<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;stu&#x27;</span> <span class="keyword">where</span> gender<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br></pre></td></tr></table></figure><h1 id="Optimizer-Trace"><a href="#Optimizer-Trace" class="headerlink" title="Optimizer Trace"></a>Optimizer Trace</h1><p>optimizer trace 跟踪 SQL 语句解析优化执行过程。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;stu&#x27;</span> <span class="keyword">where</span> gender<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;排查思路&quot;&gt;&lt;a href=&quot;#排查思路&quot; class=&quot;headerlink&quot; title=&quot;排查思路&quot;&gt;&lt;/a&gt;排查思路&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;查看“慢查询日志”找慢 SQL&lt;/li&gt;
&lt;li&gt;explain“执行计划”查询&lt;/li&gt;
&lt;li&gt;profil</summary>
      
    
    
    
    <category term="MySQL" scheme="https://chengshen.me/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://chengshen.me/tags/MySQL/"/>
    
    <category term="Slow Query" scheme="https://chengshen.me/tags/Slow-Query/"/>
    
  </entry>
  
</feed>
