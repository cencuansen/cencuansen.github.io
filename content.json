{"meta":{"title":"San Huo","subtitle":"纤凝翠薇巅，扶光入苍渊，扶摇惊砂起，山弄望舒远","description":"","author":"San Huo","url":"http://cencuansen.github.com","root":"/"},"pages":[{"title":"书单","date":"2023-02-13T11:13:06.776Z","updated":"2023-02-13T11:13:06.776Z","comments":false,"path":"books/index.html","permalink":"http://cencuansen.github.com/books/","excerpt":"","text":""},{"title":"category","date":"2023-02-13T06:19:11.000Z","updated":"2023-02-13T11:13:06.776Z","comments":true,"path":"category/index.html","permalink":"http://cencuansen.github.com/category/","excerpt":"","text":""},{"title":"分类","date":"2023-02-13T11:13:06.776Z","updated":"2023-02-13T11:13:06.776Z","comments":false,"path":"categories/index.html","permalink":"http://cencuansen.github.com/categories/","excerpt":"","text":""},{"title":"Repositories","date":"2023-02-13T11:13:06.776Z","updated":"2023-02-13T11:13:06.776Z","comments":false,"path":"repository/index.html","permalink":"http://cencuansen.github.com/repository/","excerpt":"","text":""},{"title":"关于","date":"2023-02-13T11:13:06.775Z","updated":"2023-02-13T11:13:06.775Z","comments":false,"path":"about/index.html","permalink":"http://cencuansen.github.com/about/","excerpt":"","text":"个人详细介绍"},{"title":"tag","date":"2023-02-13T06:19:03.000Z","updated":"2023-02-13T11:13:06.777Z","comments":true,"path":"tag/index.html","permalink":"http://cencuansen.github.com/tag/","excerpt":"","text":""},{"title":"标签","date":"2023-02-13T11:13:06.777Z","updated":"2023-02-13T11:13:06.777Z","comments":false,"path":"tags/index.html","permalink":"http://cencuansen.github.com/tags/","excerpt":"","text":""}],"posts":[{"title":"CSS 伪类和伪元素","slug":"CSS-pseudo-classes-and-pseudo-elements","date":"2023-02-14T09:35:15.000Z","updated":"2023-02-14T10:51:00.612Z","comments":true,"path":"/2023/02/14/CSS-pseudo-classes-and-pseudo-elements/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/CSS-pseudo-classes-and-pseudo-elements/","excerpt":"","text":"伪类功能和 class 有些类似，但它是基于文档之外的抽象，所以叫伪类。 :link、:visited、:hover、:active、:focus、:right、:left、:first、:lang、:first-child 伪元素伪元素是 DOM 树没有定义的虚拟元素。 ::before、::after、::selection","categories":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/tags/CSS/"}]},{"title":"CSS 选择第二个以及后续元素","slug":"CSS-select-children-between-2nd-and-last","date":"2023-02-14T09:28:47.000Z","updated":"2023-02-14T10:51:00.612Z","comments":true,"path":"/2023/02/14/CSS-select-children-between-2nd-and-last/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/CSS-select-children-between-2nd-and-last/","excerpt":"","text":"元素如下，希望除了第一个子 div 不选择，其他子 div 都选择。 123456&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item item-1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item item-2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item item-3&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;item item-4&quot;&gt;4&lt;/div&gt;&lt;/div&gt; 方式一 12.item:nth-of-type(n + 2) &#123;&#125; 方式二 12.item:nth-child(n + 2) &#123;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/tags/CSS/"},{"name":"Selector","slug":"Selector","permalink":"http://cencuansen.github.com/tags/Selector/"}]},{"title":"CSS 1像素线","slug":"CSS-1px-line","date":"2023-02-14T09:21:43.000Z","updated":"2023-02-14T10:51:00.612Z","comments":true,"path":"/2023/02/14/CSS-1px-line/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/CSS-1px-line/","excerpt":"","text":"场景移动端开发线条的 1 像素线绘制。 方式 用 0.5px transform scale box-shadow 模拟 图片 scale123456div &#123; height: 1px; display: block; transform: scale(1, 0.5); background-color: #000;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/tags/CSS/"},{"name":"CSS Tricks","slug":"CSS-Tricks","permalink":"http://cencuansen.github.com/tags/CSS-Tricks/"}]},{"title":"JavaScript 深拷贝和浅拷贝","slug":"JavaScript-deep-clone-and-shallow-clone","date":"2023-02-14T09:08:52.000Z","updated":"2023-02-14T10:51:00.614Z","comments":true,"path":"/2023/02/14/JavaScript-deep-clone-and-shallow-clone/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/JavaScript-deep-clone-and-shallow-clone/","excerpt":"","text":"定义浅拷贝：复制一层数据，基本类型直接复制，对象类型复制引用。深拷贝：会递归复制。 浅拷贝 扩展运算符(...) Object.assign 深拷贝 JSON.parse(JSON.stringify()) 遍历递归 JSON 化问题 正则变成空对象(&#123;&#125;)； 函数直接丢； 日期变成时间字符串(无解)； 构造函数丢失，变成 Object； 循环引用无法正确处理； 遍历深拷贝版本一 12345678910111213141516171819202122function deepClone(obj, hash = new WeakMap()) &#123; // 处理null或者undefined if (obj === null) return obj; // 处理日期类型 if (obj instanceof Date) return new Date(obj); // 处理正则类型 if (obj instanceof RegExp) return new RegExp(obj); // 普通值或函数不需要深拷贝 if (typeof obj !== &quot;object&quot;) return obj; // 对象进行深拷贝 if (hash.get(obj)) return hash.get(obj); let cloneObj = new obj.constructor(); // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身 hash.set(obj, cloneObj); for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; // 实现一个递归拷贝 cloneObj[key] = deepClone(obj[key], hash); &#125; &#125; return cloneObj;&#125; 版本二 1234567891011121314151617181920212223242526272829303132const isComplexDataType = obj =&gt; (typeof obj === &#x27;object&#x27; || typeof obj === &#x27;function&#x27;) &amp;&amp; (obj !== null)const deepClone = function (obj, hash = new WeakMap()) &#123; if (obj.constructor === Date) &#123; // 日期对象直接返回一个新的日期对象 return new Date(obj); &#125; if (obj.constructor === RegExp) &#123; // 正则对象直接返回一个新的正则对象 return new RegExp(obj); &#125; if (hash.has(obj)) &#123; // 如果循环引用了就用 weakMap 来解决 return hash.get(obj); &#125; let allDescriptors = Object.getOwnPropertyDescriptors(obj); // 遍历传入参数所有键的特性 let cloneObj = Object.create(Object.getPrototypeOf(obj), allDescriptors); // 继承原型链 hash.set(obj, cloneObj) for (let key of Reflect.ownKeys(obj)) &#123; cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; typeof obj[key] !== &#x27;function&#x27;) ? deepClone(obj[key], hash) : obj[key]; &#125; return cloneObj&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Deep Clone","slug":"Deep-Clone","permalink":"http://cencuansen.github.com/tags/Deep-Clone/"}]},{"title":"JavaScript 模块化","slug":"JavaScript-module","date":"2023-02-14T08:57:11.000Z","updated":"2023-02-14T10:51:00.615Z","comments":true,"path":"/2023/02/14/JavaScript-module/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/JavaScript-module/","excerpt":"","text":"种类 AMD&#x2F;CMD CommonJS(适用于服务端) UMD ESM(EcmaScript Module) AMD&#x2F;CMDAMD：Asynchronous Module Definition，异步模块定义。CMD：Common Module Definition，通用模块定义。相对于 CommonJS，定义了适用于浏览器端的规范。AMD 中有 requirejs，CMD 中有 seajs。用 define 方法来定义一个模块，通过前置依赖列表导入外部模块数据。 CommonJSnodejs 模块化采用的是 CommonJS。module.exports 或 exports 导出，require 导入。CommonJS 规范一些特性：文件系统，同步加载等，不适用于浏览器端，适用于服务端。 UMDUMD：Universal Module Definition，通用模块定义不属于一套模块规范，主要用来处理 CommonJS、AMD、CMD 的差异兼容，使模块代码能在前面不同的模块环境下都能正常运行。 ESMJavaScript 在 ES6 开始引入模块概念：ES Module。export default 或 export 导出，import 导入。动态导入 import() 返回 promise。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Module","slug":"Module","permalink":"http://cencuansen.github.com/tags/Module/"}]},{"title":"JavaScript 继承","slug":"JavaScript-inherit","date":"2023-02-14T08:44:17.000Z","updated":"2023-02-14T10:51:00.614Z","comments":true,"path":"/2023/02/14/JavaScript-inherit/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/JavaScript-inherit/","excerpt":"","text":"ES6 继承12class Parent &#123; &#125;class Child extends Parent &#123; &#125; 寄生组合式继承123456789101112131415161718192021222324function clone(parent, child) &#123; // 该操作将 Parent 原型中属性方法等带到 Child child.prototype = Object.create(parent.prototype); child.prototype.constructor = child;&#125;function Parent() &#123; this.name = &quot;parent&quot;; this.play = [1, 2, 3];&#125;Parent.prototype.getName = function() &#123; return this.name; &#125;;function Child() &#123; // 该 call 操作会将 Parent 自身的属性字段带到 Child Parent.call(this); this.friends = &quot;child&quot;;&#125;clone(Parent, Child);Child.prototype.getFriends = function() &#123; return this.friends;&#125;;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Inherit","slug":"Inherit","permalink":"http://cencuansen.github.com/tags/Inherit/"}]},{"title":"JavaScript 词法作用域和动态作用域","slug":"JavaScript-lexical-scope-and-dynamic-scope","date":"2023-02-13T13:40:43.000Z","updated":"2023-02-14T10:51:00.615Z","comments":true,"path":"/2023/02/13/JavaScript-lexical-scope-and-dynamic-scope/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-lexical-scope-and-dynamic-scope/","excerpt":"","text":"说明JavaScript 中，变量采用的是词法作用域。 词法作用域&#x2F;静态作用域作用域在变量定义时就确定。 动态作用域作用域在变量使用时才确定。 验证123456789101112var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar(); 这里 bar 中 foo 的 value 输出为 1，说明变量在函数定义时就确定了，属于词法作用域。如果是动态作用域，bar 中 foo 的 value 值就应当等于 2。 问题问：this 是动态作用域吗？答：不是。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"http://cencuansen.github.com/tags/Function/"}]},{"title":"JavaScript 闭包","slug":"JavaScript-closure","date":"2023-02-13T13:15:30.000Z","updated":"2023-02-14T10:51:00.613Z","comments":true,"path":"/2023/02/13/JavaScript-closure/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-closure/","excerpt":"","text":"定义闭包是一个特殊的函数，能够记录自己词法作用域内变量的状态，可以读取该作用域内的变量，在函数或语句块结束后，变量仍然对引用它的函数有效。在一个函数中返回函数或者作为回调，这样创建了闭包。当基于参数创建回调，参数必须在闭包中存储（比如：形参存储），否则就会创建一个闭包指向封闭环境中的变量，而这个变量可能会变。 场景一，返回函数123456var add = (function () &#123; var counter = 0; return function () &#123; return counter += 1; &#125;&#125;)();add(); 场景二，作为回调123456for (var i = 0; i &lt; 5; i++) &#123; (function clo(ii) &#123; // 形参 ii 对 i 进行了存储 setTimeout(function() &#123; console.log(ii); &#125;, 20); &#125;)(i);&#125; 或者 1234567// 需要浏览器版本 &gt; IE9for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function(ii) &#123; // 形参 ii 对 i 进行了存储 console.log(ii); &#125;, 20, i);&#125; 用途封装变量：闭包可以隐藏内部变量，使得代码变得更加简洁；模拟私有变量：闭包可以模拟私有变量，使得变量不被外部访问；实现回调函数：闭包可以作为回调函数传递给其他函数，以实现延迟执行；实现单例模式：闭包可以保证一个类型仅有一个实例；构建命名空间：闭包可以构建命名空间，使得变量名不冲突； 注意参数未在闭包中存储，就会创建一个闭包指向封闭环境中的变量，这变量会变。 123456for(var i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; // 未对变量 i 进行存储 console.log(&#x27;i is &#x27; + i); &#125;, 10);&#125; 这里参数未在闭包中存储，运行中 i 会变，最终 i 变成 10，输出 10 次 i is 10。类似的有 setTimeout、setInterval、eval() 等。 问题问：闭包一定需要 return 吗答：不一定，上面所示的场景二也是闭包，就不涉及 return。 参考https://creeperyang.github.io/2015/01/JavaScript-dynamic-scope-vs-static-scope/","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Closure","slug":"Closure","permalink":"http://cencuansen.github.com/tags/Closure/"}]},{"title":"JavaScript apply、bind、call","slug":"JavaScript-apply-bind-call","date":"2023-02-13T12:53:10.000Z","updated":"2023-02-14T10:51:00.613Z","comments":true,"path":"/2023/02/13/JavaScript-apply-bind-call/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-apply-bind-call/","excerpt":"","text":"用途apply、bind、call 用来改变函数内 this 指向 用法123func.apply(this, [arg1, arg2 [,...]])func.bind(this, arg1, arg2 [,...])func.call(this, arg1, arg2 [,...]) 区别 分类 说明 apply 参数数组形式传，并调用对应函数 bind 参数一个一个传，返回一个函数 call 参数一个一个传，并调用对应函数 问题问：一个方法连续 bind 多次，结果如何？答：只有第一次 bind 有效果。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"http://cencuansen.github.com/tags/Function/"}]},{"title":"JavaScript 防抖和节流","slug":"JavaScript-debouncing-and-throttling","date":"2023-02-13T12:35:59.000Z","updated":"2023-02-14T10:51:00.614Z","comments":true,"path":"/2023/02/13/JavaScript-debouncing-and-throttling/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-debouncing-and-throttling/","excerpt":"","text":"意义节流和防抖是 JavaScript 中常用的性能优化手段，用途主要是在高频率的事件触发时，如鼠标移动、滚动事件、输入事件等，避免因频繁调用而导致性能下降。 应用页面滚动时需要请求数据，可以使用节流限制请求频率。验证用户输入是否合法，此时可以使用防抖避免频繁验证。 节流节流（throttling）是指在一段时间内，只让一个函数有限次执行。它通常用来限制函数在一段时间内的最大调用次数，从而防止对性能造成过大的影响。 1234567891011function throttle(fn, interval) &#123; let canRun = true; return function () &#123; if (!canRun) return; canRun = false; setTimeout(() =&gt; &#123; fn.apply(this, arguments); canRun = true; &#125;, interval); &#125;;&#125; 防抖防抖（debouncing）是指在一段时间内，等待事件停止触发后才执行一次函数。它通常用来限制事件触发的频率，从而防止对性能造成过大的影响。 123456789function debounce(fn, interval) &#123; let timeout; return function () &#123; clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, interval); &#125;;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Closure","slug":"Closure","permalink":"http://cencuansen.github.com/tags/Closure/"},{"name":"Performance Optimization","slug":"Performance-Optimization","permalink":"http://cencuansen.github.com/tags/Performance-Optimization/"}]},{"title":"JavaScript 函数","slug":"JavaScript-function","date":"2023-02-13T12:00:45.000Z","updated":"2023-02-14T10:51:00.614Z","comments":true,"path":"/2023/02/13/JavaScript-function/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-function/","excerpt":"","text":"函数定义一般形式1function functionName(parameters) &#123; &#125; 表达式形式1var functionName = function (parameters) &#123; &#125;; 箭头函数形式1(parameters) =&gt; &#123; &#125; 提升（Hoisting）提升特性让函数可以在声明之前调用，使用表达式定义函数时，无法提升。 12myFunction(5);function myFunction(y) &#123; return y * y; &#125; 自调用函数12(function()&#123; &#125;)();(()=&gt;&#123; &#125;)(); 箭头函数特点 不能做构造函数，不能 new 没有 arguments，可用剩余参数代替 没有自己的 this，this 取决于箭头函数所在上下文 apply、bind、call 无法影响 this 指向 没有原型属性 不能作为 Generator 函数，不能使用 yield","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"http://cencuansen.github.com/tags/Function/"}]},{"title":"JavaScript this","slug":"JavaScript-this","date":"2023-02-13T11:54:25.000Z","updated":"2023-02-14T10:51:00.616Z","comments":true,"path":"/2023/02/13/JavaScript-this/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-this/","excerpt":"","text":"普通函数普通函数中的 this 是根据运行时上下文动态确定的，this 指向函数运行时所在上下文。 123456let obj = &#123; name: &quot;san&quot;, func: function () &#123; console.log(`name is $&#123;this.name&#125;`); // name is san &#125;&#125;; 箭头函数箭头函数的中 this 在非运行期间就确定了，箭头函数的 this 和外层函数的 this 一致。 1234567891011let name = &#x27;win&#x27;;let obj = &#123; name: &#x27;san&#x27;, funcA: function () &#123; (() =&gt; console.log(`name is $&#123;this.name&#125;`))(); // name is san &#125;, funcB: () =&gt; &#123; // 这里箭头函数是 obj 下定义的，外层没有函数包裹，就会找到最外层的 window 对象上 console.log(`name is $&#123;this.name&#125;`); // name is win &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"http://cencuansen.github.com/tags/Function/"}]},{"title":"JavaScript 事件循环","slug":"JavaScript-event-loop","date":"2023-02-13T08:30:17.000Z","updated":"2023-02-14T10:51:00.614Z","comments":true,"path":"/2023/02/13/JavaScript-event-loop/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-event-loop/","excerpt":"","text":"关键词宏任务 &amp; 微任务 意义让 JavaScript 在单线程环境中处理异步操作，不阻塞主线程，保证程序的流畅性，如：用户输入、网络请求、动画等。 细分宏任务：IO、setTimeout、setInterval；微任务：Promise、process.nextTick、MutationObserver； 浏览器环境 同步代码 一个宏任务 全部微任务 + 新产生的微任务 一个宏任务 全部微任务 + 新产生的微任务 … Node.js 环境 阶段 说明 timers 这个阶段执行 timer(setTimeout、setInterval) 的回调 I&#x2F;O callbacks 处理一些上一轮循环中的少数未执行的 I&#x2F;O 回调 idle, prepare 仅 node 内部使用 poll 重要且复杂的阶段，几乎所有 I&#x2F;O 相关的回调，都在这个阶段执行 check 执行 setImmediate() 的回调 close callbacks 执行 socket 的 close 事件回调 环境差异 浏览器中，微任务在宏任务之后执行； Node.js 中，微任务在各阶段之间执行：一个阶段执行完毕，就去执行微任务。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Event Loop","slug":"Event-Loop","permalink":"http://cencuansen.github.com/tags/Event-Loop/"}]},{"title":"ECMAScript 版本与特性","slug":"ECMAScript-features","date":"2023-02-13T06:44:00.000Z","updated":"2023-02-14T10:51:00.612Z","comments":true,"path":"/2023/02/13/ECMAScript-features/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/ECMAScript-features/","excerpt":"","text":"ES6&#x2F;ES2015 类 Set Map Proxy 模块化 Promise 箭头函数 解构赋值 模板字符串 展开操作符 let 与 const 对象属性简写 函数参数默认值 ES7&#x2F;ES2016 指数运算符(**) Array.prototype.includes() ES8&#x2F;ES2017 async &amp; await Object.values() Object.entries() padStart() &amp; padEnd() 函数参数列表结尾允许逗号 Object.getOwnPropertyDescriptors() ShareArrayBuffer &amp; Atomics 共享内存读写 ES9&#x2F;ES2018 异步迭代 Promise.finally() Rest &amp; Spread 属性 正则表达式 dotAll 模式 正则表达式 Unicode 转义 非转义序列的模板字符串 正则表达式反向断言(lookbehind) 正则表达式命名捕获组(Regular ExpressionNamed Capture Groups) ES10&#x2F;ES2019 可选的 catch 参数 Object.fromEntries() JSON.stringify() 优化 私有的实例方法和访问器 Symbol.prototype.description Array.flat() &amp; Array.flatMap() Array.Sort 中 QuickSort 换成 TimSort String.trimStart() &amp; String.trimEnd() Function.toString() 会保留空格、换行、注释等 ES11&#x2F;ES2020 BigInt import() globalThis nullish: ?? for-in 顺序标准化 String.matchAll() optional chaining: ? ES12&#x2F;ES2021 WeakRef 数字分隔符 Promise.any() ??=, &amp;&amp;=, ||= AggregateError String.replaceAll() FinalizationRegistry 优化 Array.prototype.sort ES13&#x2F;ES2022 top-level await Object.hasOwn public &amp; private(#fieldname) 成员修饰符","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"http://cencuansen.github.com/tags/ECMAScript/"},{"name":"Features","slug":"Features","permalink":"http://cencuansen.github.com/tags/Features/"}]},{"title":"JavaScript 数据类型","slug":"JavaScript-data-types","date":"2023-02-08T05:52:29.000Z","updated":"2023-02-14T10:51:00.613Z","comments":true,"path":"/2023/02/08/JavaScript-data-types/","link":"","permalink":"http://cencuansen.github.com/2023/02/08/JavaScript-data-types/","excerpt":"","text":"JavaScript 中： 数据类型：number、string、boolean、null、undefined、symbol、bigint、object 基本数据类型：number、string、boolean、null、undefined、symbol、bigint 引用数据类型：object 基本数据类型的特性是值无法修改，比如：修改字符串会得到一个新的字符串。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Data Types","slug":"Data-Types","permalink":"http://cencuansen.github.com/tags/Data-Types/"}]}],"categories":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/categories/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/tags/CSS/"},{"name":"Selector","slug":"Selector","permalink":"http://cencuansen.github.com/tags/Selector/"},{"name":"CSS Tricks","slug":"CSS-Tricks","permalink":"http://cencuansen.github.com/tags/CSS-Tricks/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Deep Clone","slug":"Deep-Clone","permalink":"http://cencuansen.github.com/tags/Deep-Clone/"},{"name":"Module","slug":"Module","permalink":"http://cencuansen.github.com/tags/Module/"},{"name":"Inherit","slug":"Inherit","permalink":"http://cencuansen.github.com/tags/Inherit/"},{"name":"Function","slug":"Function","permalink":"http://cencuansen.github.com/tags/Function/"},{"name":"Closure","slug":"Closure","permalink":"http://cencuansen.github.com/tags/Closure/"},{"name":"Performance Optimization","slug":"Performance-Optimization","permalink":"http://cencuansen.github.com/tags/Performance-Optimization/"},{"name":"Event Loop","slug":"Event-Loop","permalink":"http://cencuansen.github.com/tags/Event-Loop/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"http://cencuansen.github.com/tags/ECMAScript/"},{"name":"Features","slug":"Features","permalink":"http://cencuansen.github.com/tags/Features/"},{"name":"Data Types","slug":"Data-Types","permalink":"http://cencuansen.github.com/tags/Data-Types/"}]}