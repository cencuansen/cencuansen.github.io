{"meta":{"title":"San Huo","subtitle":"纤凝翠薇巅，扶光入沧渊，扶摇惊砂起，山弄望舒远","description":"","author":"San Huo","url":"http://cencuansen.github.com","root":"/"},"pages":[{"title":"关于","date":"2023-02-13T11:13:06.775Z","updated":"2023-02-13T11:13:06.775Z","comments":false,"path":"about/index.html","permalink":"http://cencuansen.github.com/about/","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2023-02-13T11:13:06.776Z","updated":"2023-02-13T11:13:06.776Z","comments":false,"path":"books/index.html","permalink":"http://cencuansen.github.com/books/","excerpt":"","text":""},{"title":"category","date":"2023-02-13T06:19:11.000Z","updated":"2023-02-13T11:13:06.776Z","comments":true,"path":"category/index.html","permalink":"http://cencuansen.github.com/category/","excerpt":"","text":""},{"title":"分类","date":"2023-02-13T11:13:06.776Z","updated":"2023-02-13T11:13:06.776Z","comments":false,"path":"categories/index.html","permalink":"http://cencuansen.github.com/categories/","excerpt":"","text":""},{"title":"Repositories","date":"2023-02-13T11:13:06.776Z","updated":"2023-02-13T11:13:06.776Z","comments":false,"path":"repository/index.html","permalink":"http://cencuansen.github.com/repository/","excerpt":"","text":""},{"title":"标签","date":"2023-02-13T11:13:06.777Z","updated":"2023-02-13T11:13:06.777Z","comments":false,"path":"tags/index.html","permalink":"http://cencuansen.github.com/tags/","excerpt":"","text":""},{"title":"tag","date":"2023-02-13T06:19:03.000Z","updated":"2023-02-13T11:13:06.777Z","comments":true,"path":"tag/index.html","permalink":"http://cencuansen.github.com/tag/","excerpt":"","text":""}],"posts":[{"title":"CSharp dispose","slug":"CSharp-dispose","date":"2023-02-14T15:37:48.000Z","updated":"2023-02-14T15:40:56.269Z","comments":true,"path":"/2023/02/14/CSharp-dispose/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/CSharp-dispose/","excerpt":"","text":"IDisposable.Dispose对于非托管资源建立和释放，C# 约定由 Dispose 方法来处理。当类库中涉及到非托管资源，就应实现 Dispose 方法，来定义资源释放逻辑。using 用来管理实现了 Dispose 方法的类，编译器会在作用域结束时调用 Dispose 方法。非托管资源包括：网络请求，数据库连接，句柄等。 标准 dispose 模式 析构函数中调用 dispose 方法，托底防忘记调用； dispose 中最后要调用 GC.SuppressFinaliza 方法，通知 CLR 无需执行析构函数，因为清除工作已完成； 多次调用 dispose 应该是安全的，dispose 方法调用后，后续再调用都不会执行额外的工作； dispose 方法有 2 个重载：public 和 protected，protected 真实清除，public 调用 protected； 析构函数调用 protected； protected 的 bool 参数区分是被析构函数调用（false）还是被 public 调用（true）； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071using System;using System.Runtime.InteropServices;namespace MyConsole.DisposeDemo&#123; /// &lt;summary&gt; /// 用于模拟一个托管资源 /// &lt;/summary&gt; public class SomeManagedResource &#123; public SomeManagedResource(string name) &#123; Name = name; &#125; public string Name &#123; get; &#125; &#125; /// &lt;summary&gt; /// 用于模拟一个非托管资源 /// &lt;/summary&gt; public class MyUnmanagedResource : IDisposable &#123; // 模拟一个非托管资源 private IntPtr someUnmanagedResource = Marshal.AllocHGlobal(100); // 模拟一个托管资源 private SomeManagedResource managedResource = new SomeManagedResource(&quot;这是托管资源&quot;); // 是否被清理过的标识 protected bool baseDisposed = false; public void Dispose() &#123; Dispose(true); GC.SuppressFinalize(this); &#125; protected virtual void Dispose(bool isDisposing) &#123; // 确保多次执行的安全性 if (baseDisposed) &#123; return; &#125; // 被 public 调用，需要额外清理托管资源 if (isDisposing) &#123; // 要调用 SuppressFinaliza，需手动清理托管资源, 否则无法释放。 if (managedResource != null) &#123; managedResource = null; &#125; &#125; // 清理非托管资源 if (someUnmanagedResource != IntPtr.Zero) &#123; Marshal.FreeHGlobal(someUnmanagedResource); someUnmanagedResource = IntPtr.Zero; &#125; baseDisposed = true; &#125; ///&lt;summary&gt; /// 必须，以防忘记调用 Dispose 方法的托底方法 ///&lt;/summary&gt; ~MyUnmanagedResource() &#123; // 必须为false Dispose(false); &#125; &#125;&#125; Finalize 无法显式的重写 Finalize 方法，只能通过析构函数语法形式来实现。 struct 中不允许定义析构函数，只有 class 中才可以，并且只能有一个。 Finalize 方法不能被继承或重载。 执行垃圾回收之前系统会自动执行 Finalize 操作。 Finalize 方法会极大地损伤性能。","categories":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/tags/CSharp/"},{"name":"Dispose","slug":"Dispose","permalink":"http://cencuansen.github.com/tags/Dispose/"}]},{"title":"CSharp 简单应用","slug":"CSharp-usage","date":"2023-02-14T15:27:46.000Z","updated":"2023-02-14T15:37:00.383Z","comments":true,"path":"/2023/02/14/CSharp-usage/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/CSharp-usage/","excerpt":"","text":"生成二维码1234567891011public Stream QRCodeStream(string contents)&#123; QRCodeGenerator qrGenerator = new QRCodeGenerator(); QRCodeData qrCodeData = qrGenerator.CreateQrCode(contents, QRCodeGenerator.ECCLevel.L); QRCode qrCode = new QRCode(qrCodeData); Bitmap bigMap = qrCode.GetGraphic(20, Color.Black, Color.White, true); MemoryStream stream = new MemoryStream(); bigMap.Save(stream, System.Drawing.Imaging.ImageFormat.Png); stream.Position = 0; return stream;&#125; 拼接图片123456789101112131415string file1 = @&quot;C:\\Users\\Admin\\Desktop\\images\\1.png&quot;;string file2 = @&quot;C:\\Users\\Admin\\Desktop\\images\\2.png&quot;;Image image1 = Image.FromStream(new MemoryStream(File.ReadAllBytes(file1)));Image image2 = Image.FromStream(new MemoryStream(File.ReadAllBytes(file2)));var image1Width = image1.Width;var image1Height = image1.Height;var image2Width = image2.Height;var image2Height = image2.Height;var stream = new MemoryStream();using Bitmap map = new Bitmap(image1Width, image1Height);//定义画布Graphics g = Graphics.FromImage(map);//定义画笔g.Clear(Color.White);//把画布更改为白色g.DrawImage(image1, new Point(0, 0));g.DrawImage(image2, new Point(image1Width - image2Width, image1Height - image2Height));map.Save(stream, ImageFormat.Jpeg); 端口占用检查1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465while (true)&#123; Console.WriteLine(&quot;请输入需要检测的端口号(如：80), 输入exit退出此程序&quot;); var inPortString = Console.ReadLine(); Process process = new Process(); if (inPortString == &quot;exit&quot;) &#123; process.Close(); break; &#125; int port = 80; try &#123; if (string.IsNullOrWhiteSpace(inPortString)) &#123; Console.WriteLine(&quot;输入端口号非法，将查询默认端口号：80&quot;); &#125; else &#123; port = Convert.ToInt32(inPortString); &#125; &#125; catch (Exception e) &#123; Console.WriteLine(&quot;输入端口号非法，将查询默认端口号：80&quot;); port = 80; &#125; process.StartInfo.FileName = &quot;cmd.exe&quot;; process.StartInfo.UseShellExecute = false; process.StartInfo.RedirectStandardInput = true; process.StartInfo.RedirectStandardOutput = true; process.StartInfo.RedirectStandardError = true; process.StartInfo.CreateNoWindow = true; process.Start(); process.StandardInput.WriteLine(&quot;netstat -ano&quot;); process.StandardInput.WriteLine(&quot;exit&quot;); Regex reg = new Regex(&quot;\\\\s+&quot;, RegexOptions.Compiled); bool found = false; string line = string.Empty; while ((line = process.StandardOutput.ReadLine()) != null) &#123; line = line.Trim(); if (line.StartsWith(&quot;TCP&quot;, StringComparison.OrdinalIgnoreCase)) &#123; line = reg.Replace(line, &quot;,&quot;); string[] arr = line.Split(&#x27;,&#x27;); if (arr[1].EndsWith($&quot;:&#123;port&#125;&quot;)) &#123; found = true; int pid = int.Parse(arr[4]); Process foundProcess = Process.GetProcessById(pid); Console.WriteLine($&quot;&#123;port&#125;端口. pid：&#123;pid&#125;, 进程名：&#123;foundProcess.ProcessName&#125;\\n&quot;); break; &#125; &#125; &#125; if (!found) &#123; Console.WriteLine($&quot;未找到&#123;port&#125;端口上的进程\\n&quot;); &#125; process.Close();&#125; byte[]、string、stream 间转换stream -&gt; string12using StreamReader reader = new StreamReader(stream);string result = reader.ReadToEnd(); string -&gt; stream12345string test = &quot;This is string&quot;;using MemoryStream stream = new MemoryStream();using StreamWriter writer = new StreamWriter( stream );writer.Write( test );writer.Flush(); byte[] -&gt; string1string str = System.Text.Encoding.Default.GetString( byteArray ); string -&gt; byte[]1byte[] byteArray = System.Text.Encoding.Default.GetBytes( str ); stream -&gt; byte[]12byte[] bytes = new byte[stream.Length];stream.Read(bytes, 0, bytes.Length); byte[] -&gt; stream1using Stream stream = new MemoryStream(bytes); 文本长度12345678string strTmp = &quot;a1某某某&quot;;// 10，Unicode下中英文每个字2字节。int len1 = System.Text.Encoding.Unicode.GetBytes(strTmp).Length;// 11，Default 等价与 UTF8，中文3个字节，英文1个字节int len2 = System.Text.Encoding.Default.GetBytes(strTmp).Length;int len3 = System.Text.Encoding.UTF8.GetBytes(strTmp).Length;// 5，就是个数int len4 = System.Text.Encoding.Default.GetBytes(strTmp).Length; WebSocket 应用Startup.Configure1app.UseWebSockets(); Controller.cs123456789101112131415161718192021222324252627282930313233[HttpGet(&quot;receive-message&quot;)]public async Task GetMessage()&#123; if (HttpContext.WebSockets.IsWebSocketRequest) &#123; using (var webSocket = await HttpContext.WebSockets.AcceptWebSocketAsync()) &#123; Console.WriteLine(&quot;WebSocket connection established&quot;); await Echo(webSocket); &#125; &#125; else &#123; HttpContext.Response.StatusCode = 400; &#125;&#125;private async Task Echo(WebSocket webSocket)&#123; var buffer = new byte[1024 * 4]; var result = await webSocket.ReceiveAsync(new ArraySegment&lt;byte&gt;(buffer), CancellationToken.None); Console.WriteLine(&quot;Message received from Client&quot;); while (!result.CloseStatus.HasValue) &#123; var serverMsg = Encoding.UTF8.GetBytes($&quot;Server: Hello. You said: &#123;Encoding.UTF8.GetString(buffer)&#125;&quot;); await webSocket.SendAsync(new ArraySegment&lt;byte&gt;(serverMsg, 0, serverMsg.Length), result.MessageType, result.EndOfMessage, CancellationToken.None); Console.WriteLine(&quot;Message sent to Client&quot;); result = await webSocket.ReceiveAsync(new ArraySegment&lt;byte&gt;(buffer), CancellationToken.None); Console.WriteLine(&quot;Message received from Client&quot;); &#125; await webSocket.CloseAsync(result.CloseStatus.Value, result.CloseStatusDescription, CancellationToken.None); Console.WriteLine(&quot;WebSocket connection closed&quot;);&#125; index.html12var socket = new WebSocket(&#x27;wss://localhost:6666/receive-message&#x27;);socket.send(&#x27;前端消息&#x27;); HTTP 网络请求HttpWebRequest：最早，不阻塞 ui，细节控制；WebClient：对 HttpWebRequest 的简化和封装；HttpClient：.NET 4.5 开始，预热机制，适合发送多次请求； HttpClient1234567var httpClientHandler = new HttpClientHandler&#123; Proxy = new WebProxy(&quot;http://127.0.0.1:1080&quot;, false),// 设置代理&#125;;var httpClient = new HttpClient(httpClientHandler);var response = await httpClient.GetAsync(&quot;http://www.baidu.com&quot;);var responseText = await response.Content.ReadAsStringAsync(); HttpClient 存在 Dispose 后不能立即释放对应套接字问题，默认需要 4 分钟去释放。可以创建一个 HttpClient 实例，把它存储在一个静态字段中，或者使用 HttpClientFactory，相关文章。","categories":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/tags/CSharp/"}]},{"title":"CSharp .NET 和 C#","slug":"CSharp-dotnet-and-csharp","date":"2023-02-14T15:21:07.000Z","updated":"2023-02-14T15:25:54.127Z","comments":true,"path":"/2023/02/14/CSharp-dotnet-and-csharp/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/CSharp-dotnet-and-csharp/","excerpt":"","text":"C# 和 .NET 语言版本 发布时间 .NET Framework 要求 Visual Studio 版本 C# 1.0 2002.1 .NET Framework 1.0 Visual Studio .NET 2002 C# 1.1&#x2F;1.2 2003.4 .NET Framework 1.1 Visual Studio .NET 2003 C# 2.0 2005.11 .NET Framework 2.0 Visual Studio 2005 C# 3.0 2007.11 .NET Framework 2.0&#x2F;3.0&#x2F;3.5 Visual Studio 2008 C# 4.0 2010.4 .NET Framework 4.0 Visual Studio 2010 C# 5.0 2012.8 .NET Framework 4.5 Visual Studio 2012&#x2F;2013 C# 6.0 2015.7 .NET Framework 4.6 Visual Studio 2015 C# 7.0 2017.3 .NET Framework 4.6.2 Visual Studio 2017 C# 7.1 2017.6 .NET Framework 4.7 Visual Studio 2017 v15.3 预览版 C# 7.2 2017.11 .NET Framework 4.7.1 Visual Studio 2017 v15.5 C# 7.3 2018.5 .NET Framework 4.7.2 Visual Studion 2017 v15.7 C# 8.0 2019.04.18 .NET Framework 4.8&#x2F;.NET Core 3&#x2F;3.1 Visual Studion 2019 C# 9 2020.09.04 .NET 5 Visual Studion 2019 C# 10.0 2021.11.09 .NET 6 Visual Studion 2022 C# 11 2022.11.8 .NET 7 Visual Studion 2022 C# 版本及其语言特性C# 1.0 [2002 年 01 月]类、结构、接口、事件、属性、委托，运算符和表达式、语句、特性 C# 2.0 [2005 年 11 月]泛型、Partial 类型、匿名方法、迭代器、可空类型、私有 setters、方法组转化(delegates)、协变和逆变、静态类 C# 3.0 [2007 年 11 月]隐式类型的局部变量(var)、对象与集合初始化器、自动实现属性(get;set;)、Partial 方法、匿名类、扩展方法、LINQ、Lambda 表达式、表达式树https://msdn.microsoft.com/en-us/library/bb308966.aspx C# 4.0 [2010 年 04 月]动态绑定(dynamic)、命名参数和可选参数、泛型协变和逆变、嵌入式互操作类型https://msdn.microsoft.com/en-us/magazine/ff796223.aspx C# 5.0 [2012 年 08 月]异步特性(async &amp; await)、调用者信息https://learn.microsoft.com/zh-cn/archive/blogs/mvpawardprogram/an-introduction-to-new-features-in-c-5-0 C# 6.0 [2015 年 07 月]表达式为主体的成员方法和只读属性、属性初始化赋值、nameof 表达式、Await in catch block、异常过滤器(when)、字符串插值https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6 C# 7.0 [2017 年 03 月]out variables、Tuples、Discards、Pattern Matching、局部方法、Generalized async return typeshttps://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7 C# 8.0 [2019 年 04 月]Readonly members、默认接口方法、Using declarations、静态局部方法、Disposable ref structs、可空引用类型https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8 C# 9.0 [2020 年 09 月]Records、Init-only properties、Top-level statements、Init accessors and readonly fields、With 表达式、Value-based equality、Primary constructorhttps://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9 C# 10.0 [2021 年 11 月]Record structs、Global using directives、File-scoped namespace declaration、Extended Proptery Patterns、Null Parameter Checking、Constant interpolated stringshttps://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10 C# 11.0 [2022 年 11 月]原生字符串字面量、Generic math support、泛型 attributes、UTF-8 字符串字面量、Newlines in string interpolation expressions、List patterns、file 类修饰符、Required members、Auto-default structs、Pattern match Span on a constant string、Extended nameof scope、Numeric IntPtr、ref fields and scoped ref、Improved method group conversion to delegate、Warning wave 7https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11综合https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history","categories":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/tags/CSharp/"},{"name":".NET","slug":"NET","permalink":"http://cencuansen.github.com/tags/NET/"},{"name":"Features","slug":"Features","permalink":"http://cencuansen.github.com/tags/Features/"}]},{"title":"CSharp 基础知识","slug":"CSharp-basic-concepts","date":"2023-02-14T14:49:07.000Z","updated":"2023-02-14T15:19:05.326Z","comments":true,"path":"/2023/02/14/CSharp-basic-concepts/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/CSharp-basic-concepts/","excerpt":"","text":"string.Empty、&quot;&quot;、 null。Empty 是 string 类中的一个静态的只读字段。string.Empty 和&quot;&quot;是一样的。string str &#x3D; null 表示 str 未指向任何对象。 string 和 StringBuilderstring 是不可变对象，string 是 String 的别名，string 是 c#中的类，String 是 Framework 的类，编译器会把 string 编译成 String。StringBuilder 为动态字符串。StringBuilder 当达到容量时，将自动分配新的空间且容量翻倍。 扩展方法向现有类型“添加”方法，无需派生、重新编译或修改原始类型。扩展方法是一种静态类中的静态方法。扩展方法第一个参数是 this 修饰的被扩展的类。 装箱和拆箱装箱：值类型 -&gt; 引用类型 。拆箱：引用类型 -&gt; 值类型。一次装箱要分配内存（托管堆）和拷贝数据（从栈到托管堆）。拆箱就是装箱的相反操作。 更改已装箱的对象已装箱的对象，无法直接调用其指定方法。让类对象继承一个接口，借助接口方式来更改已装箱的对象中的数据。 123456789101112131415161718public interface ISomeClass &#123; void Change(int x);&#125;public class SomeClass : ISomeClass&#123; public int x &#123; get; set; &#125; public void Change(int x) &#123; this.x = x; &#125;&#125;SomeClass some = new SomeClass();some.x = 100;Object o = some; // 装箱((SomeClass)o).Change(200); // 没改掉。((ISomeClass)o).Change(200); // 改掉了。 new 关键字 运算符：创建对象实例。 修饰符：在派生类定义一个重名的方法，隐藏基类方法。 约束：泛型约束，表示泛型类型要有 public 修饰的无参构造。 12public class ItemFactory&lt;T&gt; where T : IComparable, new()&#123; &#125; new 和 overridenew 和 override 都可用覆盖基类同名方法；new 覆盖基类不完全，父类引用子类实例时，能调用到基类方法，override 覆盖基类是彻底的，一旦子类 override 基类方法后，就无法再调用基类同名方法。 123456789101112131415161718192021222324252627282930313233class Parent&#123; public virtual string Say () &#123; return &quot;I am parent&quot;; &#125;&#125;class Child1 : Parent&#123; public override string Say () &#123; return &quot;I am child1&quot;; &#125;&#125;class Child2 : Parent&#123; public new string Say () &#123; return &quot;I am child2&quot;; &#125;&#125;// 父类引用子类实例Parent instance1 = new Child1();// I am child1string who1 = instance1.Say();// 父类引用子类实例Parent instance2 = new Child2();// 注意，这里就能调用到基类方法，结果为：I am parentstring who1 = instance2.Say(); int? 和 int可空类型，默认值可以是 null。int? 是通过 int 装箱为引用类型实现。Nullable.GetUnderlyingType(typeof(int?)) != null 用来判断类型是否是可空类型 委托约定方法签名，来对方法进行引用，类似指针，方法能当参数传递给形参，用于事件、回调等。 const 和 readonlyreadonly 运行时常量。const 编译时常量。readonly 常量只能声明为类字段。const 除了类字段，还可以声明为方法中的局部常量，默认为静态类型，不能用 static 修饰。 CTS、CLS、CLRCTS：通用类型系统；CLS：通用语言规范；CLR：公共语言运行库； using 引用命名空间。 using 一个非托管资源（IDisposiable），用来释放资源。 托管资源、非托管资源托管资源指的是.NET 可以自动进行回收的资源，主要是指托管堆上分配的内存资源。非托管资源指的是.NET 不知道如何回收的资源，最常见的是包装操作系统资源的对象，例如文件，窗口，网络连接，数据库连接，画刷，图标等。建议通过调用 IDisposable.Dispose()方法来回收非托管资源。 ref、out、in相同：都是按引用传递，形参成为实参的别名；不同：ref 在方法外需初始化；out 需在方法内赋值；in 在方法内是只读的。 123456789101112131415static void Main(string[] args)&#123; //初始化 int number = 50; Console.WriteLine(&quot;调用方法前 number 值：&quot; + number); RefFunction(ref number); Console.WriteLine(&quot;调用方法后 number 值：&quot; + number); Console.Read();&#125;// 传入的参数值是 50 ，方法中使用的 num 值也是 50static void RefFunction(ref int num)&#123; num = num / 2;&#125; 12345678910111213141516static void Main(string[] args)&#123; int number = 50; Console.WriteLine(&quot;调用方法前 number 值：&quot; + number); OutFunction(out number); Console.WriteLine(&quot;调用方法后 number 值：&quot; + number); Console.Read();&#125;// 无法将的参数值 50 传入 ，但是必须在方法中初始化static void OutFunction(out int num)&#123; //初始化 num = 120; num = num / 2;&#125; in 的意义结构体实例数据分配在栈上，当需要将大数据量的结构体作为方法参数时，会复制一份该大结构体，成本有点高，使用 in 来按引用传递该大结构体，就能避免复制问题。 ref、out、in 使用限制async 修饰的异步方法中无法使用；迭代器方法（含有 yield return 或 yield break 的方法）中无法使用；扩展方法的第一个参数不能有 in 修饰符，除非该参数是结构体；扩展方法的第一个参数，其中该参数是泛型类型（即使该类型被约束为结构体）； Equals 和 &#x3D;&#x3D;&#x3D;&#x3D; 值类型数据比较的是值，引用类型比较的是引用地址。Equals 引用类型比较的是最终数据。 as 和 isis 判断对象是否兼容于某类型，返回 bool 值，永远不会抛出异常。as 用于在兼容的引用类型之间执行转换。无法转换则为 null。is 需要做两次对象的类型检查，而 as 需要做一次对象类型检查。 访问修饰符public：共有的，访问不受限制；private：私有的，只能在当前类中访问；internal：内部的，只能在当前程序集中访问；protected：受保护的，只能在当前类或其派生类中访问；file：当前文件范围，C# 11 新增；protected internal：受保护的内部成员，当前程序集或派生自包含类的类型可访问；private protected：私有受保护的成员，当前程序集中的包含类或从包含类派生的类型可访问；class 默认 internal，class member 默认 private。 class 成员、interface 成员class 成员：字段、常量、属性、方法、事件、运算符、索引器、构造函数、终结器、嵌套类型。interface 成员：方法、属性、索引器和事件 类的执行顺序父类，子类，静态块，静态字段，非静态块，非静态字段，构造器，方法 数据类型和内存占用1 byte bool、byte2 byte char、short4 byte int、float8 byte long、double16 byte decimal 多态编译时多态和运行时多态。 编译时多态重载编译时多态。根据签名不同分为不同的方法，编译后就成两个不同名函数。 运行时多态虚方法是运行时多态，父类中有虚方法，子类覆盖实现虚方法。 浅拷贝和深拷贝在浅拷贝中，仅对顶级对象进行了复制，对低级别对象进行了引用。在深拷贝中，会复制所有对象。 浅拷贝继承 ICloneable，实现 Clone()方法，方法中调用 MemberwiseClone()；如果字段是值类型，则执行字段的按位复制；如果字段是引用类型，引用将复制，但被引用的对象不会被复制。 协变和逆变in 逆变，out 协变。赋值的兼容性，用在委托或者接口上。需要返回数据，这种结构化的委托有效性之间的关系叫做协变，用 out 标记泛型类型。需要接受数据，期望传入基类时允许传入派生对象的特性叫逆变，用 in 标记泛型类型。协变： IEnumerable IEnumerator IQueryable IGrouping&lt;out TKey, out TElement&gt; 逆变： IComparer IEqualityComparer IComparable Action Predicate Comparison 协变 + 逆变： TOutput Converter&lt;in TInput, out TOutput&gt; object 和 dynamicobject 是一种引用类型，表示 .NET 框架中的任何类型。它是所有引用类型的基类，允许将任何类型的对象存储在这个变量中。dynamic 是 C# 中的一个关键字，在编译时将变量的类型指定为 dynamic ，对象的实际类型将在运行时确定，这在使用没有特定类型定义的 API 或库时非常有用。 总结object 是基类，可以存储任何引用类型；dynamic 是关键字，在编译时跳过类型检查，在运行时确定类型。 场景object 在我们不知道数据类型时很有用。dynamic 更多是用在反射，支持动态语言，COM 对象调用以及获取 LINQ 的查询结果。 12345object a = &quot;Rohatash Kumar&quot;;string a1 = a.ToString();dynamic a = &quot;Rohatash Kumar&quot;;string a1 = a; 抽象类和接口 都能有默认实现； 都不能直接实例化； 抽象类单继承，接口多继承； 抽象类中可以有字段、属性、方法，接口中可以有属性、方法、索引器、事件，没有字段；","categories":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/tags/CSharp/"}]},{"title":"HTML src 和 href","slug":"HTML-src-and-href","date":"2023-02-14T14:27:46.000Z","updated":"2023-02-14T14:44:15.804Z","comments":true,"path":"/2023/02/14/HTML-src-and-href/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/HTML-src-and-href/","excerpt":"","text":"作用结果不同href 用于在当前文档和引用资源之间建立联系。src 加载资源，嵌入相应元素中。 浏览器解析方式不同href 浏览器会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。src 会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，如图片(img)和框架(iframe)等，类似于将资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。 请求资源类型不同href（Hypertext Reference，超文本引用）用来建立当前元素和文档之间的链接。如：link、a。src 的资源，会将资源下载并应用到文档中，常用的有 script，img 、iframe。 使用1234567&lt;link href=&quot;./style.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;a href=&quot;http://example.com&quot; target=&quot;_blank&quot;&gt;click here&lt;/a&gt;&lt;script src=&quot;http://example.com/foo.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;img src=&quot;http://example.com/bar.png&quot;&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"http://cencuansen.github.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://cencuansen.github.com/tags/HTML/"}]},{"title":"Web 浏览器中网络请求过程","slug":"Web-request-process-in-browser","date":"2023-02-14T14:21:06.000Z","updated":"2023-02-14T14:25:05.163Z","comments":true,"path":"/2023/02/14/Web-request-process-in-browser/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/Web-request-process-in-browser/","excerpt":"","text":"地址解析，提取出协议、域名、端口等信息等 通过 DNS 获取到 IP 地址 进行 TCP 连接(三次握手)a. 第一次握手：建立连接时，客户端发送 syn(建立联机)包到服务器，并进入 syn_send 状态，等待服务器确认；b. 第二次握手：服务器收到 syn 包，确认包信息，同时自己也发送一个 syn + ack(确认)包并进入 syn_recv 状态;c. 第三次握手：客户端收到 syn+ack 包，向服务器发送 ack 包，发送完后，客户端和服务器都进入 established 状态，完成三次握手； HTTP 请求 服务器响应请求 DOM 解析和渲染","categories":[{"name":"Web","slug":"Web","permalink":"http://cencuansen.github.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://cencuansen.github.com/tags/Web/"},{"name":"Request","slug":"Request","permalink":"http://cencuansen.github.com/tags/Request/"}]},{"title":"Web DOM 的解析和渲染","slug":"Web-dom-parsing-and-rendering","date":"2023-02-14T14:12:08.000Z","updated":"2023-02-14T14:19:38.110Z","comments":true,"path":"/2023/02/14/Web-dom-parsing-and-rendering/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/Web-dom-parsing-and-rendering/","excerpt":"","text":"解析流程 解析 html，构建 DOM Tree 解析 CSS，构建 CSS Rule Tree 由 DOM Tree 和 CSS Rule Tree 生成 Render Tree 利用 Render Tree 进行布局 Layout，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置 painting 绘制 按照算出来的规则将内容绘制到屏幕上 相关问题问：DOM 树的构建是文档加载完成开始的？答：不是，为更好用户体验，渲染引擎会尽快将内容进行显示，加载部分后就尝试解析、构建、布局、渲染。问：Render 树是 DOM 树和 CSSOM 树构建完毕才开始构建的吗？答：不是。三者交叉进行，一边加载，一边解析，一边渲染。问：CSS 解析顺序？答：选择器从右往左，DOM 树从下向上的解析顺序。嵌套标签越多解析越慢。问：repaint 重绘？答：改变元素背景色、前景色、边框色等，不影响文档中周边元素布局位置。问：reflow 回流？答：影响元素布局位置变更的操作，会导致回流，从根向下重新计算全部元素节点尺寸和位置，比如：元素显隐、元素尺寸变更、定位方式等，都会引起内部、周围、整个页面的重新渲染。通常无法预估页面哪部分会回流，它们都彼此相互影响着。频繁回流会影响性能。","categories":[{"name":"Web","slug":"Web","permalink":"http://cencuansen.github.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://cencuansen.github.com/tags/Web/"},{"name":"Dom","slug":"Dom","permalink":"http://cencuansen.github.com/tags/Dom/"},{"name":"Dom Parsing","slug":"Dom-Parsing","permalink":"http://cencuansen.github.com/tags/Dom-Parsing/"},{"name":"Dom Rendering","slug":"Dom-Rendering","permalink":"http://cencuansen.github.com/tags/Dom-Rendering/"}]},{"title":"HTML 块级格式化上下文","slug":"HTML-block-formatting-context","date":"2023-02-14T11:53:32.000Z","updated":"2023-02-14T12:01:21.600Z","comments":true,"path":"/2023/02/14/HTML-block-formatting-context/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/HTML-block-formatting-context/","excerpt":"","text":"概念一个块级格式化上下文（Block Formatting Context），包含该上下文元素的所有直接子元素，但是不包括子元素的子元素。 案例123456&lt;div class=&quot;box-a&quot; id=&quot;bfc1&quot;&gt; &lt;div class=&quot;box-b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box-c&quot; id=&quot;bfc2&quot;&gt; &lt;div class=&quot;box-d&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; #bfc1 的 BFC 指的是 .box-b 和 .box-c；#bfc2 的 BFC 指的是 .box-d； 特点 每一个 BFC 区域只包括其子元素，不包括其子元素的子元素； 每一个 BFC 区域都是独立隔绝的，互不影响！ 三种布局 标准流（normal） 浮动流（float） 定位流（position） 触发 BFC body 根元素； 设置 float，不包括 none； 设置 position，包括 absoulte、fixed； 设置 display 为 inline-block； 设置 overflow，包括 hidden、auto、scroll； 表格单元格，table-cell； 弹性布局，flex； BFC 实际应用兄弟 div margin 重叠问题描述：文档中相邻 div 元素，上下分布，但两者 margin 默认会重叠。解决思路：将相邻兄弟变成非相邻同级：把这两兄弟元素各用 div 包裹，触发包裹元素的 bfc。 父子 div margin 重叠问题描述：文档中父子 div 元素，子 div margin-top 会让父子 div 同时下移。解决思路：触发父级 bfc、父级设置边框。 清除浮动影响问题描述：父元素没设置高度，包含一个子元素，子元素设置浮动，父元素会高度塌陷。","categories":[{"name":"HTML","slug":"HTML","permalink":"http://cencuansen.github.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://cencuansen.github.com/tags/HTML/"},{"name":"BFC","slug":"BFC","permalink":"http://cencuansen.github.com/tags/BFC/"}]},{"title":"CSS transform、transition、animation","slug":"CSS-transform-transition-animation","date":"2023-02-14T11:41:16.000Z","updated":"2023-02-14T11:51:24.136Z","comments":true,"path":"/2023/02/14/CSS-transform-transition-animation/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/CSS-transform-transition-animation/","excerpt":"","text":"transformtransform: [转换函数];转换函数：translate、scale、rotate、skew。transform 只影响当前元素，不影响文档流。 12transform: translateX(1px);transform: translateY(2px); 特性参考：https://www.bilibili.com/video/BV1L3411C76T 变换后盒子模型占据的尺寸和位置不会变换； 变换后会创建层叠上下文； 对内联元素无效； 不同顺序效果不同； 锯齿或虚化问题； transition改变目标元素的样式：颜色、外观、尺寸，一般搭配伪类。transition 尺寸变更会对文档流产生影响。 12345678.box &#123; width: 10px; transition: width 0.4s ease;&#125;.box:hover &#123; width: 50px;&#125; 或者用 JavaScript 改变元素属性触发 transition 12345678910.box &#123; width: 100px; height: 100px; background-color: blueviolet; transition: width 1s linear 0.5s;&#125;.box1 &#123; width: 400px;&#125; 1document.querySelector(&#x27;.box&#x27;).classList.add(&#x27;box1&#x27;); 局限性 transition 需要触发，没法在网页加载时自动发生。 transition 是一次性的，不能重复发生，除非一再触发。 transition 只能定义开始状态和结束状态，不能定义中间状态。 一条 transition 规则，只能定义一个属性的变化，不能涉及多个属性。 animationtransition 不够用的时候，可以使用 animation。animation 搭配 @keyframes 使用，无需搭配伪类，页面加载 animation 就自动开始了。 123456789101112131415161718192021.animation1 &#123; /* forwards：动画结束时，就停在最终状态 */ animation: changeAnimation 1s ease forwards;&#125;.animation2 &#123; /* infinite alternate：无限循环 + 往复 */ animation: changeAnimation 1s ease infinite alternate;&#125;@keyframes changeAnimation &#123; 0% &#123; width: 110px; &#125; 50% &#123; width: 140px; &#125; 100% &#123; width: 200px; &#125;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/tags/CSS/"},{"name":"transform","slug":"transform","permalink":"http://cencuansen.github.com/tags/transform/"},{"name":"transition","slug":"transition","permalink":"http://cencuansen.github.com/tags/transition/"},{"name":"animation","slug":"animation","permalink":"http://cencuansen.github.com/tags/animation/"}]},{"title":"CSS 伪类和伪元素","slug":"CSS-pseudo-classes-and-pseudo-elements","date":"2023-02-14T09:35:15.000Z","updated":"2023-02-14T10:51:00.612Z","comments":true,"path":"/2023/02/14/CSS-pseudo-classes-and-pseudo-elements/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/CSS-pseudo-classes-and-pseudo-elements/","excerpt":"","text":"伪类功能和 class 有些类似，但它是基于文档之外的抽象，所以叫伪类。 :link、:visited、:hover、:active、:focus、:right、:left、:first、:lang、:first-child 伪元素伪元素是 DOM 树没有定义的虚拟元素。 ::before、::after、::selection","categories":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/tags/CSS/"}]},{"title":"CSS 选择第二个以及后续元素","slug":"CSS-select-children-between-2nd-and-last","date":"2023-02-14T09:28:47.000Z","updated":"2023-02-14T10:51:00.612Z","comments":true,"path":"/2023/02/14/CSS-select-children-between-2nd-and-last/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/CSS-select-children-between-2nd-and-last/","excerpt":"","text":"元素如下，希望除了第一个子 div 不选择，其他子 div 都选择。 123456&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item item-1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item item-2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item item-3&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;item item-4&quot;&gt;4&lt;/div&gt;&lt;/div&gt; 方式一 12.item:nth-of-type(n + 2) &#123;&#125; 方式二 12.item:nth-child(n + 2) &#123;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/tags/CSS/"},{"name":"Selector","slug":"Selector","permalink":"http://cencuansen.github.com/tags/Selector/"}]},{"title":"CSS 1像素线","slug":"CSS-1px-line","date":"2023-02-14T09:21:43.000Z","updated":"2023-02-14T10:51:00.612Z","comments":true,"path":"/2023/02/14/CSS-1px-line/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/CSS-1px-line/","excerpt":"","text":"场景移动端开发线条的 1 像素线绘制。 方式 用 0.5px transform scale box-shadow 模拟 图片 scale123456div &#123; height: 1px; display: block; transform: scale(1, 0.5); background-color: #000;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/tags/CSS/"},{"name":"CSS Tricks","slug":"CSS-Tricks","permalink":"http://cencuansen.github.com/tags/CSS-Tricks/"}]},{"title":"JavaScript 深拷贝和浅拷贝","slug":"JavaScript-deep-clone-and-shallow-clone","date":"2023-02-14T09:08:52.000Z","updated":"2023-02-14T10:51:00.614Z","comments":true,"path":"/2023/02/14/JavaScript-deep-clone-and-shallow-clone/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/JavaScript-deep-clone-and-shallow-clone/","excerpt":"","text":"定义浅拷贝：复制一层数据，基本类型直接复制，对象类型复制引用。深拷贝：会递归复制。 浅拷贝 扩展运算符(...) Object.assign 深拷贝 JSON.parse(JSON.stringify()) 遍历递归 JSON 化问题 正则变成空对象(&#123;&#125;)； 函数直接丢； 日期变成时间字符串(无解)； 构造函数丢失，变成 Object； 循环引用无法正确处理； 遍历深拷贝版本一 12345678910111213141516171819202122function deepClone(obj, hash = new WeakMap()) &#123; // 处理null或者undefined if (obj === null) return obj; // 处理日期类型 if (obj instanceof Date) return new Date(obj); // 处理正则类型 if (obj instanceof RegExp) return new RegExp(obj); // 普通值或函数不需要深拷贝 if (typeof obj !== &quot;object&quot;) return obj; // 对象进行深拷贝 if (hash.get(obj)) return hash.get(obj); let cloneObj = new obj.constructor(); // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身 hash.set(obj, cloneObj); for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; // 实现一个递归拷贝 cloneObj[key] = deepClone(obj[key], hash); &#125; &#125; return cloneObj;&#125; 版本二 1234567891011121314151617181920212223242526272829303132const isComplexDataType = obj =&gt; (typeof obj === &#x27;object&#x27; || typeof obj === &#x27;function&#x27;) &amp;&amp; (obj !== null)const deepClone = function (obj, hash = new WeakMap()) &#123; if (obj.constructor === Date) &#123; // 日期对象直接返回一个新的日期对象 return new Date(obj); &#125; if (obj.constructor === RegExp) &#123; // 正则对象直接返回一个新的正则对象 return new RegExp(obj); &#125; if (hash.has(obj)) &#123; // 如果循环引用了就用 weakMap 来解决 return hash.get(obj); &#125; let allDescriptors = Object.getOwnPropertyDescriptors(obj); // 遍历传入参数所有键的特性 let cloneObj = Object.create(Object.getPrototypeOf(obj), allDescriptors); // 继承原型链 hash.set(obj, cloneObj) for (let key of Reflect.ownKeys(obj)) &#123; cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; typeof obj[key] !== &#x27;function&#x27;) ? deepClone(obj[key], hash) : obj[key]; &#125; return cloneObj&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Deep Clone","slug":"Deep-Clone","permalink":"http://cencuansen.github.com/tags/Deep-Clone/"}]},{"title":"JavaScript 模块化","slug":"JavaScript-module","date":"2023-02-14T08:57:11.000Z","updated":"2023-02-14T10:51:00.615Z","comments":true,"path":"/2023/02/14/JavaScript-module/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/JavaScript-module/","excerpt":"","text":"种类 AMD&#x2F;CMD CommonJS(适用于服务端) UMD ESM(EcmaScript Module) AMD&#x2F;CMDAMD：Asynchronous Module Definition，异步模块定义。CMD：Common Module Definition，通用模块定义。相对于 CommonJS，定义了适用于浏览器端的规范。AMD 中有 requirejs，CMD 中有 seajs。用 define 方法来定义一个模块，通过前置依赖列表导入外部模块数据。 CommonJSnodejs 模块化采用的是 CommonJS。module.exports 或 exports 导出，require 导入。CommonJS 规范一些特性：文件系统，同步加载等，不适用于浏览器端，适用于服务端。 UMDUMD：Universal Module Definition，通用模块定义不属于一套模块规范，主要用来处理 CommonJS、AMD、CMD 的差异兼容，使模块代码能在前面不同的模块环境下都能正常运行。 ESMJavaScript 在 ES6 开始引入模块概念：ES Module。export default 或 export 导出，import 导入。动态导入 import() 返回 promise。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Module","slug":"Module","permalink":"http://cencuansen.github.com/tags/Module/"}]},{"title":"JavaScript 继承","slug":"JavaScript-inherit","date":"2023-02-14T08:44:17.000Z","updated":"2023-02-14T10:51:00.614Z","comments":true,"path":"/2023/02/14/JavaScript-inherit/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/JavaScript-inherit/","excerpt":"","text":"ES6 继承12class Parent &#123; &#125;class Child extends Parent &#123; &#125; 寄生组合式继承123456789101112131415161718192021222324function clone(parent, child) &#123; // 该操作将 Parent 原型中属性方法等带到 Child child.prototype = Object.create(parent.prototype); child.prototype.constructor = child;&#125;function Parent() &#123; this.name = &quot;parent&quot;; this.play = [1, 2, 3];&#125;Parent.prototype.getName = function() &#123; return this.name; &#125;;function Child() &#123; // 该 call 操作会将 Parent 自身的属性字段带到 Child Parent.call(this); this.friends = &quot;child&quot;;&#125;clone(Parent, Child);Child.prototype.getFriends = function() &#123; return this.friends;&#125;;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Inherit","slug":"Inherit","permalink":"http://cencuansen.github.com/tags/Inherit/"}]},{"title":"JavaScript 词法作用域和动态作用域","slug":"JavaScript-lexical-scope-and-dynamic-scope","date":"2023-02-13T13:40:43.000Z","updated":"2023-02-14T10:51:00.615Z","comments":true,"path":"/2023/02/13/JavaScript-lexical-scope-and-dynamic-scope/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-lexical-scope-and-dynamic-scope/","excerpt":"","text":"说明JavaScript 中，变量采用的是词法作用域。 词法作用域&#x2F;静态作用域作用域在变量定义时就确定。 动态作用域作用域在变量使用时才确定。 验证123456789101112var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar(); 这里 bar 中 foo 的 value 输出为 1，说明变量在函数定义时就确定了，属于词法作用域。如果是动态作用域，bar 中 foo 的 value 值就应当等于 2。 问题问：this 是动态作用域吗？答：不是。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"http://cencuansen.github.com/tags/Function/"}]},{"title":"JavaScript 闭包","slug":"JavaScript-closure","date":"2023-02-13T13:15:30.000Z","updated":"2023-02-14T10:51:00.613Z","comments":true,"path":"/2023/02/13/JavaScript-closure/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-closure/","excerpt":"","text":"定义闭包是一个特殊的函数，能够记录自己词法作用域内变量的状态，可以读取该作用域内的变量，在函数或语句块结束后，变量仍然对引用它的函数有效。在一个函数中返回函数或者作为回调，这样创建了闭包。当基于参数创建回调，参数必须在闭包中存储（比如：形参存储），否则就会创建一个闭包指向封闭环境中的变量，而这个变量可能会变。 场景一，返回函数123456var add = (function () &#123; var counter = 0; return function () &#123; return counter += 1; &#125;&#125;)();add(); 场景二，作为回调123456for (var i = 0; i &lt; 5; i++) &#123; (function clo(ii) &#123; // 形参 ii 对 i 进行了存储 setTimeout(function() &#123; console.log(ii); &#125;, 20); &#125;)(i);&#125; 或者 1234567// 需要浏览器版本 &gt; IE9for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function(ii) &#123; // 形参 ii 对 i 进行了存储 console.log(ii); &#125;, 20, i);&#125; 用途封装变量：闭包可以隐藏内部变量，使得代码变得更加简洁；模拟私有变量：闭包可以模拟私有变量，使得变量不被外部访问；实现回调函数：闭包可以作为回调函数传递给其他函数，以实现延迟执行；实现单例模式：闭包可以保证一个类型仅有一个实例；构建命名空间：闭包可以构建命名空间，使得变量名不冲突； 注意参数未在闭包中存储，就会创建一个闭包指向封闭环境中的变量，这变量会变。 123456for(var i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; // 未对变量 i 进行存储 console.log(&#x27;i is &#x27; + i); &#125;, 10);&#125; 这里参数未在闭包中存储，运行中 i 会变，最终 i 变成 10，输出 10 次 i is 10。类似的有 setTimeout、setInterval、eval() 等。 问题问：闭包一定需要 return 吗答：不一定，上面所示的场景二也是闭包，就不涉及 return。 参考https://creeperyang.github.io/2015/01/JavaScript-dynamic-scope-vs-static-scope/","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Closure","slug":"Closure","permalink":"http://cencuansen.github.com/tags/Closure/"}]},{"title":"JavaScript apply、bind、call","slug":"JavaScript-apply-bind-call","date":"2023-02-13T12:53:10.000Z","updated":"2023-02-14T10:51:00.613Z","comments":true,"path":"/2023/02/13/JavaScript-apply-bind-call/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-apply-bind-call/","excerpt":"","text":"用途apply、bind、call 用来改变函数内 this 指向 用法123func.apply(this, [arg1, arg2 [,...]])func.bind(this, arg1, arg2 [,...])func.call(this, arg1, arg2 [,...]) 区别 分类 说明 apply 参数数组形式传，并调用对应函数 bind 参数一个一个传，返回一个函数 call 参数一个一个传，并调用对应函数 问题问：一个方法连续 bind 多次，结果如何？答：只有第一次 bind 有效果。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"http://cencuansen.github.com/tags/Function/"}]},{"title":"JavaScript 防抖和节流","slug":"JavaScript-debouncing-and-throttling","date":"2023-02-13T12:35:59.000Z","updated":"2023-02-14T10:51:00.614Z","comments":true,"path":"/2023/02/13/JavaScript-debouncing-and-throttling/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-debouncing-and-throttling/","excerpt":"","text":"意义节流和防抖是 JavaScript 中常用的性能优化手段，用途主要是在高频率的事件触发时，如鼠标移动、滚动事件、输入事件等，避免因频繁调用而导致性能下降。 应用页面滚动时需要请求数据，可以使用节流限制请求频率。验证用户输入是否合法，此时可以使用防抖避免频繁验证。 节流节流（throttling）是指在一段时间内，只让一个函数有限次执行。它通常用来限制函数在一段时间内的最大调用次数，从而防止对性能造成过大的影响。 1234567891011function throttle(fn, interval) &#123; let canRun = true; return function () &#123; if (!canRun) return; canRun = false; setTimeout(() =&gt; &#123; fn.apply(this, arguments); canRun = true; &#125;, interval); &#125;;&#125; 防抖防抖（debouncing）是指在一段时间内，等待事件停止触发后才执行一次函数。它通常用来限制事件触发的频率，从而防止对性能造成过大的影响。 123456789function debounce(fn, interval) &#123; let timeout; return function () &#123; clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, interval); &#125;;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Closure","slug":"Closure","permalink":"http://cencuansen.github.com/tags/Closure/"},{"name":"Performance Optimization","slug":"Performance-Optimization","permalink":"http://cencuansen.github.com/tags/Performance-Optimization/"}]},{"title":"JavaScript 函数","slug":"JavaScript-function","date":"2023-02-13T12:00:45.000Z","updated":"2023-02-14T10:51:00.614Z","comments":true,"path":"/2023/02/13/JavaScript-function/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-function/","excerpt":"","text":"函数定义一般形式1function functionName(parameters) &#123; &#125; 表达式形式1var functionName = function (parameters) &#123; &#125;; 箭头函数形式1(parameters) =&gt; &#123; &#125; 提升（Hoisting）提升特性让函数可以在声明之前调用，使用表达式定义函数时，无法提升。 12myFunction(5);function myFunction(y) &#123; return y * y; &#125; 自调用函数12(function()&#123; &#125;)();(()=&gt;&#123; &#125;)(); 箭头函数特点 不能做构造函数，不能 new 没有 arguments，可用剩余参数代替 没有自己的 this，this 取决于箭头函数所在上下文 apply、bind、call 无法影响 this 指向 没有原型属性 不能作为 Generator 函数，不能使用 yield","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"http://cencuansen.github.com/tags/Function/"}]},{"title":"JavaScript this","slug":"JavaScript-this","date":"2023-02-13T11:54:25.000Z","updated":"2023-02-14T10:51:00.616Z","comments":true,"path":"/2023/02/13/JavaScript-this/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-this/","excerpt":"","text":"普通函数普通函数中的 this 是根据运行时上下文动态确定的，this 指向函数运行时所在上下文。 123456let obj = &#123; name: &quot;san&quot;, func: function () &#123; console.log(`name is $&#123;this.name&#125;`); // name is san &#125;&#125;; 箭头函数箭头函数的中 this 在非运行期间就确定了，箭头函数的 this 和外层函数的 this 一致。 1234567891011let name = &#x27;win&#x27;;let obj = &#123; name: &#x27;san&#x27;, funcA: function () &#123; (() =&gt; console.log(`name is $&#123;this.name&#125;`))(); // name is san &#125;, funcB: () =&gt; &#123; // 这里箭头函数是 obj 下定义的，外层没有函数包裹，就会找到最外层的 window 对象上 console.log(`name is $&#123;this.name&#125;`); // name is win &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"http://cencuansen.github.com/tags/Function/"}]},{"title":"JavaScript 事件循环","slug":"JavaScript-event-loop","date":"2023-02-13T08:30:17.000Z","updated":"2023-02-14T10:51:00.614Z","comments":true,"path":"/2023/02/13/JavaScript-event-loop/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-event-loop/","excerpt":"","text":"关键词宏任务 &amp; 微任务 意义让 JavaScript 在单线程环境中处理异步操作，不阻塞主线程，保证程序的流畅性，如：用户输入、网络请求、动画等。 细分宏任务：IO、setTimeout、setInterval；微任务：Promise、process.nextTick、MutationObserver； 浏览器环境 同步代码 一个宏任务 全部微任务 + 新产生的微任务 一个宏任务 全部微任务 + 新产生的微任务 … Node.js 环境 阶段 说明 timers 这个阶段执行 timer(setTimeout、setInterval) 的回调 I&#x2F;O callbacks 处理一些上一轮循环中的少数未执行的 I&#x2F;O 回调 idle, prepare 仅 node 内部使用 poll 重要且复杂的阶段，几乎所有 I&#x2F;O 相关的回调，都在这个阶段执行 check 执行 setImmediate() 的回调 close callbacks 执行 socket 的 close 事件回调 环境差异 浏览器中，微任务在宏任务之后执行； Node.js 中，微任务在各阶段之间执行：一个阶段执行完毕，就去执行微任务。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Event Loop","slug":"Event-Loop","permalink":"http://cencuansen.github.com/tags/Event-Loop/"}]},{"title":"ECMAScript 版本与特性","slug":"ECMAScript-features","date":"2023-02-13T06:44:00.000Z","updated":"2023-02-14T10:51:00.612Z","comments":true,"path":"/2023/02/13/ECMAScript-features/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/ECMAScript-features/","excerpt":"","text":"ES6&#x2F;ES2015 类 Set Map Proxy 模块化 Promise 箭头函数 解构赋值 模板字符串 展开操作符 let 与 const 对象属性简写 函数参数默认值 ES7&#x2F;ES2016 指数运算符(**) Array.prototype.includes() ES8&#x2F;ES2017 async &amp; await Object.values() Object.entries() padStart() &amp; padEnd() 函数参数列表结尾允许逗号 Object.getOwnPropertyDescriptors() ShareArrayBuffer &amp; Atomics 共享内存读写 ES9&#x2F;ES2018 异步迭代 Promise.finally() Rest &amp; Spread 属性 正则表达式 dotAll 模式 正则表达式 Unicode 转义 非转义序列的模板字符串 正则表达式反向断言(lookbehind) 正则表达式命名捕获组(Regular ExpressionNamed Capture Groups) ES10&#x2F;ES2019 可选的 catch 参数 Object.fromEntries() JSON.stringify() 优化 私有的实例方法和访问器 Symbol.prototype.description Array.flat() &amp; Array.flatMap() Array.Sort 中 QuickSort 换成 TimSort String.trimStart() &amp; String.trimEnd() Function.toString() 会保留空格、换行、注释等 ES11&#x2F;ES2020 BigInt import() globalThis nullish: ?? for-in 顺序标准化 String.matchAll() optional chaining: ? ES12&#x2F;ES2021 WeakRef 数字分隔符 Promise.any() ??=, &amp;&amp;=, ||= AggregateError String.replaceAll() FinalizationRegistry 优化 Array.prototype.sort ES13&#x2F;ES2022 top-level await Object.hasOwn public &amp; private(#fieldname) 成员修饰符","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"Features","slug":"Features","permalink":"http://cencuansen.github.com/tags/Features/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"http://cencuansen.github.com/tags/ECMAScript/"}]},{"title":"JavaScript 数据类型","slug":"JavaScript-data-types","date":"2023-02-08T05:52:29.000Z","updated":"2023-02-14T10:51:00.613Z","comments":true,"path":"/2023/02/08/JavaScript-data-types/","link":"","permalink":"http://cencuansen.github.com/2023/02/08/JavaScript-data-types/","excerpt":"","text":"JavaScript 中： 数据类型：number、string、boolean、null、undefined、symbol、bigint、object 基本数据类型：number、string、boolean、null、undefined、symbol、bigint 引用数据类型：object 基本数据类型的特性是值无法修改，比如：修改字符串会得到一个新的字符串。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Data Types","slug":"Data-Types","permalink":"http://cencuansen.github.com/tags/Data-Types/"}]}],"categories":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/categories/CSharp/"},{"name":"HTML","slug":"HTML","permalink":"http://cencuansen.github.com/categories/HTML/"},{"name":"Web","slug":"Web","permalink":"http://cencuansen.github.com/categories/Web/"},{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/categories/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/tags/CSharp/"},{"name":"Dispose","slug":"Dispose","permalink":"http://cencuansen.github.com/tags/Dispose/"},{"name":".NET","slug":"NET","permalink":"http://cencuansen.github.com/tags/NET/"},{"name":"Features","slug":"Features","permalink":"http://cencuansen.github.com/tags/Features/"},{"name":"HTML","slug":"HTML","permalink":"http://cencuansen.github.com/tags/HTML/"},{"name":"Web","slug":"Web","permalink":"http://cencuansen.github.com/tags/Web/"},{"name":"Request","slug":"Request","permalink":"http://cencuansen.github.com/tags/Request/"},{"name":"Dom","slug":"Dom","permalink":"http://cencuansen.github.com/tags/Dom/"},{"name":"Dom Parsing","slug":"Dom-Parsing","permalink":"http://cencuansen.github.com/tags/Dom-Parsing/"},{"name":"Dom Rendering","slug":"Dom-Rendering","permalink":"http://cencuansen.github.com/tags/Dom-Rendering/"},{"name":"BFC","slug":"BFC","permalink":"http://cencuansen.github.com/tags/BFC/"},{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/tags/CSS/"},{"name":"transform","slug":"transform","permalink":"http://cencuansen.github.com/tags/transform/"},{"name":"transition","slug":"transition","permalink":"http://cencuansen.github.com/tags/transition/"},{"name":"animation","slug":"animation","permalink":"http://cencuansen.github.com/tags/animation/"},{"name":"Selector","slug":"Selector","permalink":"http://cencuansen.github.com/tags/Selector/"},{"name":"CSS Tricks","slug":"CSS-Tricks","permalink":"http://cencuansen.github.com/tags/CSS-Tricks/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Deep Clone","slug":"Deep-Clone","permalink":"http://cencuansen.github.com/tags/Deep-Clone/"},{"name":"Module","slug":"Module","permalink":"http://cencuansen.github.com/tags/Module/"},{"name":"Inherit","slug":"Inherit","permalink":"http://cencuansen.github.com/tags/Inherit/"},{"name":"Function","slug":"Function","permalink":"http://cencuansen.github.com/tags/Function/"},{"name":"Closure","slug":"Closure","permalink":"http://cencuansen.github.com/tags/Closure/"},{"name":"Performance Optimization","slug":"Performance-Optimization","permalink":"http://cencuansen.github.com/tags/Performance-Optimization/"},{"name":"Event Loop","slug":"Event-Loop","permalink":"http://cencuansen.github.com/tags/Event-Loop/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"http://cencuansen.github.com/tags/ECMAScript/"},{"name":"Data Types","slug":"Data-Types","permalink":"http://cencuansen.github.com/tags/Data-Types/"}]}