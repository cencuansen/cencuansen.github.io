{"meta":{"title":"📚","subtitle":"纤凝翠薇巅，扶光入苍渊，扶摇惊砂起，山弄望舒远","description":"","author":"sanhuo","url":"http://cencuansen.github.com","root":"/"},"pages":[{"title":"分类","date":"2023-02-13T11:13:06.776Z","updated":"2023-02-13T11:13:06.776Z","comments":false,"path":"categories/index.html","permalink":"http://cencuansen.github.com/categories/","excerpt":"","text":""},{"title":"关于","date":"2023-02-13T11:13:06.775Z","updated":"2023-02-13T11:13:06.775Z","comments":false,"path":"about/index.html","permalink":"http://cencuansen.github.com/about/","excerpt":"","text":"个人详细介绍"},{"title":"category","date":"2023-02-13T06:19:11.000Z","updated":"2023-02-13T11:13:06.776Z","comments":true,"path":"category/index.html","permalink":"http://cencuansen.github.com/category/","excerpt":"","text":""},{"title":"书单","date":"2023-02-13T11:13:06.776Z","updated":"2023-02-13T11:13:06.776Z","comments":false,"path":"books/index.html","permalink":"http://cencuansen.github.com/books/","excerpt":"","text":""},{"title":"Repositories","date":"2023-02-13T11:13:06.776Z","updated":"2023-02-13T11:13:06.776Z","comments":false,"path":"repository/index.html","permalink":"http://cencuansen.github.com/repository/","excerpt":"","text":""},{"title":"tag","date":"2023-02-13T06:19:03.000Z","updated":"2023-02-13T11:13:06.777Z","comments":true,"path":"tag/index.html","permalink":"http://cencuansen.github.com/tag/","excerpt":"","text":""},{"title":"标签","date":"2023-02-13T11:13:06.777Z","updated":"2023-02-13T11:13:06.777Z","comments":false,"path":"tags/index.html","permalink":"http://cencuansen.github.com/tags/","excerpt":"","text":""}],"posts":[{"title":"JavaScript 词法作用域和动态作用域","slug":"JavaScript-lexical-scope-and-dynamic-scope","date":"2023-02-13T13:40:43.000Z","updated":"2023-02-13T14:31:29.657Z","comments":true,"path":"/2023/02/13/JavaScript-lexical-scope-and-dynamic-scope/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-lexical-scope-and-dynamic-scope/","excerpt":"","text":"说明JavaScript 中，变量采用的是词法作用域。 词法作用域&#x2F;静态作用域作用域在变量定义时就确定。 动态作用域作用域在变量使用时才确定。 验证123456789101112var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar(); 这里 bar 中 foo 的 value 输出为 1，说明变量在函数定义时就确定了，属于词法作用域。如果是动态作用域，bar 中 foo 的 value 值就应当等于 2。 问题问：this 是动态作用域吗？答：不是。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"}]},{"title":"JavaScript 闭包","slug":"JavaScript-closure","date":"2023-02-13T13:15:30.000Z","updated":"2023-02-13T14:54:06.668Z","comments":true,"path":"/2023/02/13/JavaScript-closure/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-closure/","excerpt":"","text":"定义闭包是一个特殊的函数，能够记录自己词法作用域内变量的状态，可以读取该作用域内的变量，在函数或语句块结束后，变量仍然对引用它的函数有效。在一个函数中返回函数或者作为回调，这样创建了闭包。当基于参数创建回调，参数必须在闭包中存储（比如：形参存储），否则就会创建一个闭包指向封闭环境中的变量，而这个变量可能会变。 场景一，返回函数123456var add = (function () &#123; var counter = 0; return function () &#123; return counter += 1; &#125;&#125;)();add(); 场景二，作为回调123456for (var i = 0; i &lt; 5; i++) &#123; (function clo(ii) &#123; // 形参 ii 对 i 进行了存储 setTimeout(function() &#123; console.log(ii); &#125;, 20); &#125;)(i);&#125; 或者 1234567// 需要浏览器版本 &gt; IE9for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function(ii) &#123; // 形参 ii 对 i 进行了存储 console.log(ii); &#125;, 20, i);&#125; 用途封装变量：闭包可以隐藏内部变量，使得代码变得更加简洁；模拟私有变量：闭包可以模拟私有变量，使得变量不被外部访问；实现回调函数：闭包可以作为回调函数传递给其他函数，以实现延迟执行；实现单例模式：闭包可以保证一个类型仅有一个实例；构建命名空间：闭包可以构建命名空间，使得变量名不冲突； 注意参数未在闭包中存储，就会创建一个闭包指向封闭环境中的变量，这变量会变。 123456for(var i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; // 未对变量 i 进行存储 console.log(&#x27;i is &#x27; + i); &#125;, 10);&#125; 这里参数未在闭包中存储，运行中 i 会变，最终 i 变成 10，输出 10 次 i is 10。类似的有 setTimeout、setInterval、eval() 等。 问题问：闭包一定需要 return 吗答：不一定，上面所示的场景二也是闭包，就不涉及 return。 参考https://creeperyang.github.io/2015/01/JavaScript-dynamic-scope-vs-static-scope/","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"}]},{"title":"JavaScript apply、bind、call","slug":"JavaScript-apply-bind-call","date":"2023-02-13T12:53:10.000Z","updated":"2023-02-13T13:01:58.995Z","comments":true,"path":"/2023/02/13/JavaScript-apply-bind-call/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-apply-bind-call/","excerpt":"","text":"用途apply、bind、call 用来改变函数内 this 指向 用法123func.apply(this, [arg1, arg2 [,...]])func.bind(this, arg1, arg2 [,...])func.call(this, arg1, arg2 [,...]) 区别 分类 说明 apply 参数数组形式传，并调用对应函数 bind 参数一个一个传，返回一个函数 call 参数一个一个传，并调用对应函数 问题问：一个方法连续 bind 多次，结果如何？答：只有第一次 bind 有效果。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"}]},{"title":"JavaScript 防抖和节流","slug":"JavaScript-debouncing-and-throttling","date":"2023-02-13T12:35:59.000Z","updated":"2023-02-13T12:46:12.796Z","comments":true,"path":"/2023/02/13/JavaScript-debouncing-and-throttling/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-debouncing-and-throttling/","excerpt":"","text":"意义节流和防抖是 JavaScript 中常用的性能优化手段，用途主要是在高频率的事件触发时，如鼠标移动、滚动事件、输入事件等，避免因频繁调用而导致性能下降。 应用页面滚动时需要请求数据，可以使用节流限制请求频率。验证用户输入是否合法，此时可以使用防抖避免频繁验证。 节流节流（throttling）是指在一段时间内，只让一个函数有限次执行。它通常用来限制函数在一段时间内的最大调用次数，从而防止对性能造成过大的影响。 1234567891011function throttle(fn, interval) &#123; let canRun = true; return function () &#123; if (!canRun) return; canRun = false; setTimeout(() =&gt; &#123; fn.apply(this, arguments); canRun = true; &#125;, interval); &#125;;&#125; 防抖防抖（debouncing）是指在一段时间内，等待事件停止触发后才执行一次函数。它通常用来限制事件触发的频率，从而防止对性能造成过大的影响。 123456789function debounce(fn, interval) &#123; let timeout; return function () &#123; clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, interval); &#125;;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"}]},{"title":"JavaScript 函数","slug":"JavaScript-function","date":"2023-02-13T12:00:45.000Z","updated":"2023-02-13T12:25:40.509Z","comments":true,"path":"/2023/02/13/JavaScript-function/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-function/","excerpt":"","text":"函数定义一般形式1function functionName(parameters) &#123; &#125; 表达式形式1var functionName = function (parameters) &#123; &#125;; 箭头函数形式1(parameters) =&gt; &#123; &#125; 提升（Hoisting）提升特性让函数可以在声明之前调用，使用表达式定义函数时，无法提升。 12myFunction(5);function myFunction(y) &#123; return y * y; &#125; 自调用函数12(function()&#123; &#125;)();(()=&gt;&#123; &#125;)(); 箭头函数特点 不能做构造函数，不能 new 没有 arguments，可用剩余参数代替 没有自己的 this，this 取决于箭头函数所在上下文 apply、bind、call 无法影响 this 指向 没有原型属性 不能作为 Generator 函数，不能使用 yield","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"}]},{"title":"JavaScript this","slug":"JavaScript-this","date":"2023-02-13T11:54:25.000Z","updated":"2023-02-13T11:59:06.576Z","comments":true,"path":"/2023/02/13/JavaScript-this/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-this/","excerpt":"","text":"普通函数普通函数中的 this 是根据运行时上下文动态确定的，this 指向函数运行时所在上下文。 123456let obj = &#123; name: &quot;san&quot;, func: function () &#123; console.log(`name is $&#123;this.name&#125;`); // name is san &#125;&#125;; 箭头函数箭头函数的中 this 在非运行期间就确定了，箭头函数的 this 和外层函数的 this 一致。 1234567891011let name = &#x27;win&#x27;;let obj = &#123; name: &#x27;san&#x27;, funcA: function () &#123; (() =&gt; console.log(`name is $&#123;this.name&#125;`))(); // name is san &#125;, funcB: () =&gt; &#123; // 这里箭头函数是 obj 下定义的，外层没有函数包裹，就会找到最外层的 window 对象上 console.log(`name is $&#123;this.name&#125;`); // name is win &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"}]},{"title":"JavaScript 事件循环","slug":"JavaScript-event-loop","date":"2023-02-13T08:30:17.000Z","updated":"2023-02-13T11:50:17.099Z","comments":true,"path":"/2023/02/13/JavaScript-event-loop/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/JavaScript-event-loop/","excerpt":"","text":"关键词宏任务 &amp; 微任务 意义让 JavaScript 在单线程环境中处理异步操作，不阻塞主线程，保证程序的流畅性，如：用户输入、网络请求、动画等。 细分宏任务：IO、setTimeout、setInterval；微任务：Promise、process.nextTick、MutationObserver； 浏览器环境 同步代码 一个宏任务 全部微任务 + 新产生的微任务 一个宏任务 全部微任务 + 新产生的微任务 … Node.js 环境 阶段 说明 timers 阶段 这个阶段执行 timer(setTimeout、setInterval) 的回调 I&#x2F;O callbacks 阶段 处理一些上一轮循环中的少数未执行的 I&#x2F;O 回调 idle, prepare 阶段 仅 node 内部使用 poll 阶段 重要且复杂的阶段，几乎所有 I&#x2F;O 相关的回调，都在这个阶段执行 check 阶段 执行 setImmediate() 的回调 close callbacks 阶段 执行 socket 的 close 事件回调 环境差异 浏览器中，微任务在宏任务之后执行； Node.js 中，微任务在各阶段之间执行：一个阶段执行完毕，就去执行微任务。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"}]},{"title":"ECMAScript 版本与特性","slug":"ECMAScript-features","date":"2023-02-13T06:44:00.000Z","updated":"2023-02-13T11:25:11.786Z","comments":true,"path":"/2023/02/13/ECMAScript-features/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/ECMAScript-features/","excerpt":"","text":"ES6&#x2F;ES2015 类 Set Map Proxy 模块化 Promise 箭头函数 解构赋值 模板字符串 展开操作符 let 与 const 对象属性简写 函数参数默认值 ES7&#x2F;ES2016 指数运算符(**) Array.prototype.includes() ES8&#x2F;ES2017 async &amp; await Object.values() Object.entries() padStart() &amp; padEnd() 函数参数列表结尾允许逗号 Object.getOwnPropertyDescriptors() ShareArrayBuffer &amp; Atomics 共享内存读写 ES9&#x2F;ES2018 异步迭代 Promise.finally() Rest &amp; Spread 属性 正则表达式 dotAll 模式 正则表达式 Unicode 转义 非转义序列的模板字符串 正则表达式反向断言(lookbehind) 正则表达式命名捕获组(Regular ExpressionNamed Capture Groups) ES10&#x2F;ES2019 可选的 catch 参数 Object.fromEntries() JSON.stringify() 优化 私有的实例方法和访问器 Symbol.prototype.description Array.flat() &amp; Array.flatMap() Array.Sort 中 QuickSort 换成 TimSort String.trimStart() &amp; String.trimEnd() Function.toString() 会保留空格、换行、注释等 ES11&#x2F;ES2020 BigInt import() globalThis nullish: ?? for-in 顺序标准化 String.matchAll() optional chaining: ? ES12&#x2F;ES2021 WeakRef 数字分隔符 Promise.any() ??=, &amp;&amp;=, ||= AggregateError String.replaceAll() FinalizationRegistry 优化 Array.prototype.sort ES13&#x2F;ES2022 top-level await Object.hasOwn public &amp; private(#fieldname) 成员修饰符","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"}]},{"title":"JavaScript 数据类型","slug":"JavaScript-data-types","date":"2023-02-08T05:52:29.000Z","updated":"2023-02-13T11:26:06.698Z","comments":true,"path":"/2023/02/08/JavaScript-data-types/","link":"","permalink":"http://cencuansen.github.com/2023/02/08/JavaScript-data-types/","excerpt":"","text":"JavaScript 中： 数据类型：number、string、boolean、null、undefined、symbol、bigint、object 基本数据类型：number、string、boolean、null、undefined、symbol、bigint 引用数据类型：object 基本数据类型的特性是值无法修改，比如：修改字符串会得到一个新的字符串。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"}]}],"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"}]}