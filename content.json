{"meta":{"title":"San Huo","subtitle":"纤凝翠薇巅，扶光入沧渊，扶摇惊砂起，山弄望舒远","description":"","author":"San Huo","url":"http://cencuansen.github.com","root":"/"},"pages":[{"title":"书单","date":"2023-02-13T11:13:06.776Z","updated":"2023-02-13T11:13:06.776Z","comments":false,"path":"books/index.html","permalink":"http://cencuansen.github.com/books/","excerpt":"","text":""},{"title":"category","date":"2023-02-13T06:19:11.000Z","updated":"2023-02-13T11:13:06.776Z","comments":true,"path":"category/index.html","permalink":"http://cencuansen.github.com/category/","excerpt":"","text":""},{"title":"分类","date":"2023-02-13T11:13:06.776Z","updated":"2023-02-13T11:13:06.776Z","comments":false,"path":"categories/index.html","permalink":"http://cencuansen.github.com/categories/","excerpt":"","text":""},{"title":"Repositories","date":"2023-02-13T11:13:06.776Z","updated":"2023-02-13T11:13:06.776Z","comments":false,"path":"repository/index.html","permalink":"http://cencuansen.github.com/repository/","excerpt":"","text":""},{"title":"关于","date":"2023-02-13T11:13:06.775Z","updated":"2023-02-13T11:13:06.775Z","comments":false,"path":"about/index.html","permalink":"http://cencuansen.github.com/about/","excerpt":"","text":"个人详细介绍"},{"title":"tag","date":"2023-02-13T06:19:03.000Z","updated":"2023-02-13T11:13:06.777Z","comments":true,"path":"tag/index.html","permalink":"http://cencuansen.github.com/tag/","excerpt":"","text":""},{"title":"标签","date":"2023-02-13T11:13:06.777Z","updated":"2023-02-13T11:13:06.777Z","comments":false,"path":"tags/index.html","permalink":"http://cencuansen.github.com/tags/","excerpt":"","text":""}],"posts":[{"title":"CLR GC","slug":"csharp/CLR-GC","date":"2023-02-15T05:12:19.000Z","updated":"2023-02-15T11:53:42.710Z","comments":true,"path":"/2023/02/15/csharp/CLR-GC/","link":"","permalink":"http://cencuansen.github.com/2023/02/15/csharp/CLR-GC/","excerpt":"","text":"算法分类 引用计数 引用跟踪 引用计数：每个对象维护一个内存字段来统计程序中有多少部分正在使用该对象，处理不好循环引用。引用跟踪：标记可达对象，清除不可达对象。 CLR 采用引用跟踪算法，托管堆维护着一个指针 NextObjPtr，它指向下一个对象在堆中的分配位置。GC 时，会暂停进程中所有线程，防止 CLR 检查期间对象状态变更。一旦根离开作用域，它的引用对象就会变得不可达，GC 会回收其内存。 标记清除标记 通过活动根标记它引用的堆对象，然后递归标记堆对象中引用的对象； 如果对象被标记过，就停止递归标记，避免死循环； 清除 清除无标记的对象：普通对象直接回收内存，有终结器的对象单独回收，清除之后内存占用会变得不连续。 压缩 挪动幸存的对象，使它们占用连续内存空间； 更新活动根引用的对象地址； 代特点 对象越新，生存期越短； 对象越老，生存期越长； 堆的部分回收快于整堆回收； 工作原理 初始添加的对象为 0 代，同时给 gen0 一个预估的内存大小阈值； 当初始申请的堆内存不足以分配给新对象时，就会触发 GC； 回收和压缩完，幸存的对象会被看成 gen1 对象，此时 gen0 被认为是空的； 新对象会被分配到 gen0； 如果又遇到 gen0 空间不足时，发现 gen1 老数据空间占用低于阈值，就转而针对 gen0 对象进行垃圾回收处理； 对于老对象中字段引用新对象情况，垃圾回收器利用 JIT 编译器内部机制，在对象引用字段发生变化时，设置一个标志位，表明老对象在上一轮垃圾回收后更新过，只有发生变化的老对象才需要检查是否引用了 gen0 对象； 根据假设，老对象中可能不值得去进行垃圾回收，所以就算 1 代存在垃圾对象，也可能会保留下来； 一顿操作后，gen0 对象也会被认为是 gen1 对象了，gen0 再次被认为是空的； gen1 缓慢增长，当某次 0 代空间又不足，触发 GC，发现 gen1 也超出容量阈值，就对 gen0 和 gen1 的对象都进行垃圾回收； gen1 变 gen2，gen0 变 gen1，gen0 被认为是空的； 默认托管堆只支持 3 代(MaxGeneration() 返回 2)； 补充说明 如果垃圾回收 0 代存活对象很少，可能会减少 0 代容量预算； 如果垃圾回收 0 代发现没多少内存被回收，就会增加 0 代容量预算； 如果没有回收到足够内存，垃圾回收器会执行一次完整回收； 如果还不够，会抛出 OOM(OutOfMemoryException)异常； 触发 GC 0 代内存不足； 显式 GC.Collect()； Windows 报告低内存情况； CLR 正在卸载 AppDomain； CLR 正在关闭； 大对象：大于等于 85000 字节，被认为是大对象。对于大对象来说，又称为 gen3。大对象堆：存放大对象，称为 gen3。第 3 代和第 2 代一起参与垃圾回收。 GC 模式 工作站，默认，适合客户端应用程序。GC 时延低，防 UI 线程明显假死； 服务器，服务器端应用程序，优化吞吐量和资源利用能力； GC 子模式 并发，默认，后台线程在应用程序运行时并发标记对象。 非并发。 延迟模式GC 时会暂停应用程序中正在运行的线程，线程被暂停的时间称为延迟。 模式 说明 Batch 服务器模式默认值 禁后台 GC（并发 GC）。用于服务器端或无 UI 的应用程序。会替代 gcConcurrent 设置。 Interactive 工作站模式默认值 用于有 UI 的大多数应用程序。如果托管了某个应用，则会优先考虑托管进程的垃圾回收器设置。 LowLatency （短期）低延迟模式 禁止 2 代回收，允许 0 代 1 代回收，只能在短时间内使用，仅工作站可用。 SustainedLowLatency 长期低延迟模式 禁止 2 代前台回收，允许 0 代 1 代回收和 2 代后台回收，可以长时间使用，工作站和服务器都可用。 NoGCRegion 在程序执行关键路径时将 GC 线程挂起 不能将该值直接赋值给 GCLatencyMode 属性，通过调用 GC.TryStartGCRegion 方法开始，调用 GC.EndGCRegion 方法结束。 内存泄露 不正确的使用静态字段，导致大量数据无法被 GC 释放； 没有正确执行 Dispose()，非托管资源没有得到释放； 不正确的使用终结器 Finalize()，导致无法正常释放资源； 其他不正确的引用，导致大量托管对象无法被 GC 释放； 托管和非托管资源托管资源指的是 .NET 可以自动进行回收的资源，主要是指托管堆上分配的内存资源。 非托管资源指的是 .NET 不知道如何回收的资源，最常见的是包装操作系统资源的对象。例如：文件，窗口，网络连接，数据库连接，图标等。通过调用 IDisposable.Dispose 方法来回收非托管资源。","categories":[{"name":"CLR","slug":"CLR","permalink":"http://cencuansen.github.com/categories/CLR/"}],"tags":[{"name":"CLR","slug":"CLR","permalink":"http://cencuansen.github.com/tags/CLR/"},{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/tags/CSharp/"}]},{"title":"CLR 类型对象指针和同步块索引","slug":"csharp/CLR-TOP-and-SBI","date":"2023-02-15T05:03:10.000Z","updated":"2023-02-15T11:53:42.710Z","comments":true,"path":"/2023/02/15/csharp/CLR-TOP-and-SBI/","link":"","permalink":"http://cencuansen.github.com/2023/02/15/csharp/CLR-TOP-and-SBI/","excerpt":"","text":"类型对象指针又称为方法表指针(MT)；32 位系统占 4 字节，64 位系统占 8 字节；实例化对象时，CLR 自动初始化类型对象指针这个成员，它指向类型对象。用 System.Object.GetType() 方法返回这个成员值，用来知道对象（包括类型对象本身）的类型。 同步块索引32 位系统占 4 字节，64 位系统占 8 字节； 同步块索引用途 线程同步 lock； GetHashCode，要用到同步块索引的后 26 位； GC 时标记对象； 线程同步当 CLR 初始化的时候，CLR 会初始化一个同步块数组，线程遇到 lock，去检查对象的同步块索引的值，如果值指向同步块数组的项，说明已加锁，等待；否则，就去同步索引数组中找个空闲位置，记录下标值到 lock 对象的同步块索引上。负责为对象分配同步块并且赋值同步块索引的线程本身是线程安全的。","categories":[{"name":"CLR","slug":"CLR","permalink":"http://cencuansen.github.com/categories/CLR/"}],"tags":[{"name":"CLR","slug":"CLR","permalink":"http://cencuansen.github.com/tags/CLR/"},{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/tags/CSharp/"}]},{"title":"CLR new","slug":"csharp/CLR-instance-by-new","date":"2023-02-15T04:52:56.000Z","updated":"2023-02-15T11:53:42.710Z","comments":true,"path":"/2023/02/15/csharp/CLR-instance-by-new/","link":"","permalink":"http://cencuansen.github.com/2023/02/15/csharp/CLR-instance-by-new/","excerpt":"","text":"CLR 要求对象都用 new 创建。 new 实例化对象： 计算类和基类中所有实例字段的总字节数，外加类型对象指针、同步块索引字节数； 从托管堆中分配所需空间，空间数据都置为 0； 初始化对象的类型对象指针、同步块索引成员； 如果实现了 Finalize 方法，对象地址会被放到终结器队列； 调用类的实例构造函数，传递必要的参数； 类型对象指针又叫做方法表指针(MT)；","categories":[{"name":"CLR","slug":"CLR","permalink":"http://cencuansen.github.com/categories/CLR/"}],"tags":[{"name":"CLR","slug":"CLR","permalink":"http://cencuansen.github.com/tags/CLR/"},{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/tags/CSharp/"}]},{"title":"CLR 基本概念","slug":"csharp/CLR-basic-concepts","date":"2023-02-15T04:43:00.000Z","updated":"2023-02-15T11:53:42.710Z","comments":true,"path":"/2023/02/15/csharp/CLR-basic-concepts/","link":"","permalink":"http://cencuansen.github.com/2023/02/15/csharp/CLR-basic-concepts/","excerpt":"","text":"CLRCommon Language Runtime，公共语言运行时，一种可被多种编程语言使用的运行时。 核心功能内存管理、程序集加载、异常处理、线程同步、安全性。 托管模块无论哪种语言(C++、C#、VB、F#等)，最后通过编译的结果都是托管模块。托管模块是 PE32 文件或 PE32+ 文件，都需要 CLR 才能执行。 IL源代码经语言编译器编译生成.exe 或.dll 是 IL(Intermediate Language，中间语言)代码，CPU 不能直接执行。通过 IL 代码可以了解程序执行的底层通用逻辑。 JITJust In Time，即时编译，以方法为单位，将 IL 编译成本机 CPU 指令。JIT 是按需编译的，来最小化启动开销，未被使用的方法 JIT 不编译，小而多的方法优于大而少的方法。JIT 对小而简单(局部变量少，控制分支简单)的方法进行登记(enregistration)，将局部变量存到寄存器中，访问效率比堆栈更高。 CTSCommon Type System，通用类型系统，描述类定义和行为，让不同编程语言能互通。 类的成员：字段、属性、方法、事件等； 类和成员的可见性： public internal protected private 类只能单继承。一个类型只能从一个基类派生； 所有类都继承自 System.Object。 CLSCommon Language Specification，公共语言规范。有的语言不区分大小写，有的语言不支持无符号整数、操作符重载。为了不同语言程序可以进行相互通信，CLS 去定义最小可通用功能集合，让不同语言编译器去支持这些规范，生成的程序彼此间达到兼容目的。","categories":[{"name":"CLR","slug":"CLR","permalink":"http://cencuansen.github.com/categories/CLR/"}],"tags":[{"name":"CLR","slug":"CLR","permalink":"http://cencuansen.github.com/tags/CLR/"},{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/tags/CSharp/"}]},{"title":"CSharp 线程同步","slug":"csharp/CSharp-thread-synchronization","date":"2023-02-15T02:27:06.000Z","updated":"2023-02-15T11:53:42.712Z","comments":true,"path":"/2023/02/15/csharp/CSharp-thread-synchronization/","link":"","permalink":"http://cencuansen.github.com/2023/02/15/csharp/CSharp-thread-synchronization/","excerpt":"","text":"概念线程同步指的是线程之间的协调，以确保它们不会同时执行并彼此冲突。目标是保持数据完整性，避免多个线程同时访问共享资源时可能出现的竞争。 分类 内核模式 用户模式 混合模式 内核模式涉及上下文切换（线程或进程切换），比较消耗操作系统资源。 Mutex Event Semaphore ReaderWriterLock 用户模式轮询 CPU，避免上下文切换，合适短时操作。 Volatile SpinLock SpinWait Interlocked 混合模式用户模式 + 内核模式。 Barrier Monitor&#x2F;lock SemaphoreSlim CountDownEvent ManualResetEventSlim ReaderWriterLockSlim 详细Mutex互斥量，支持线程互斥和进程互斥线程互斥：mutex.WaitOne、mutex.ReleaseMutex进程互斥：new Mutex(true, “test”, out flag) 参数 1：给调用线程赋予初始所有权限 参数 2：给互斥体取个名字 参数 3：如果赋予调用线程初始权限成功就返回 true，失败就返回 false。 Event有 AutoResetEvent、ManualResetEvent 等。使用：event.WaitOne、event.SetAutoResetEvent 只激活一个线程，ManualResetEvent 激活全部线程。应用：两个线程交互输出数字 SemaphoreSemaphore 信号量，支持线程同步和进程同步。使用：semaphore.Wait、semaphore.ReleaseSemaphoreSlim 轻量级信号量，用于线程同步。new SemaphoreSlim(int) 设定信号总数，限制总数，比如：限制数据库连接数。 Volatilevolatile 修饰字段，用来告诉编译器，该字段会被多线程修改，不要对该字段进行访问优化（缓存优化），确保该字段值的多线程可见性。 123456789public class Example&#123; public int x; public void DoWork() &#123; x = 5; var y = x + 10; &#125;&#125; 编译器第一次发现 y &#x3D; 15，就尝试缓存这个结果，避免每次计算 y &#x3D; x + 10，但 x 有可能被其他线程修改，不该缓存 y &#x3D; 15。解决方法：public volatile int x，表明 x 可能会被多线程修改。 SpinLock自旋锁，一个线程获取该锁，其他线程自旋等待，浪费 CPU，但避免上下文切换，功能与 lock 一样。 Monitor&#x2F;lock混合锁，可重入，lock 是 Monitor 语法糖，lock 无法设置超时。获得锁失败，线程会由运行转为阻塞，会出现上下文切换。Monitor 可超时，避免无限等待出现死锁。lock 原则： 只读私有； 禁用 this、typeof(type)、string； 避免 MethodImplAttribute 同步； 同步构造选择逻辑 避免使用同步构造 优先选择混合模式，其次同步模式，最次内核模式 异步锁 SemaphoreSlim.WaitAsync 问题为什么 lock 引用类型同步块索引。CLR 为堆内的对象分配同步索引，一个引用类型的同步索引不指向任何同步块数组中的同步块，说明没加锁，否则说明该对象被加锁了。值类型没同步块索引，所以 lock 的只能是引用类型。 lock 值类型会如何值类型会被装箱，每次装箱后的对象都不一样，会导致锁定无效。 lock 注意项别 lock this，无意义的 object 更好；别 lock 类型对象，类型对象是全局的；别 lock 字符串，因为字符串可能被驻留，不同字符对象可能指向同一个字符串；别用 MethodImplAttribute(MethodImplOptions.Synchronized)，它相当于去 lock 一个方法，实例方法 lock 的是 this，静态方法 lock 的是类型对象； 可超时线程同步 Mutex：mutex.WaitOne(int) Monitor：Monitor.TryEnter(object, int) Semaphore：semaphore .WaitOne(int) AutoResetEvent：resetEvent.WaitOne(int) 示例两个线程交互输出数字1234567891011121314151617181920212223242526272829303132var some = new SomeClass();var t1 = new Thread(some.PrintEven) &#123; Name = &quot;even&quot; &#125;;var t2 = new Thread(some.PrintOdd) &#123; Name = &quot;odd&quot; &#125;;t1.Start();t2.Start();class SomeClass&#123; // 偶数 AutoResetEvent even = new AutoResetEvent(false); // 奇数 AutoResetEvent odd = new AutoResetEvent(false); volatile int number = 0; internal void PrintEven() &#123; while (number &lt;= 100) &#123; $&quot;&#123;Thread.CurrentThread.Name&#125; - &#123;number++&#125;&quot;.Dump(); odd.Set(); even.WaitOne(); &#125; &#125; internal void PrintOdd() &#123; odd.WaitOne(); while (number &lt;= 100) &#123; $&quot;&#123;Thread.CurrentThread.Name&#125; - &#123;number++&#125;&quot;.Dump(); even.Set(); odd.WaitOne(); &#125; &#125;&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/categories/CSharp/"}],"tags":[{"name":"CLR","slug":"CLR","permalink":"http://cencuansen.github.com/tags/CLR/"},{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/tags/CSharp/"},{"name":"Thread Synchronization","slug":"Thread-Synchronization","permalink":"http://cencuansen.github.com/tags/Thread-Synchronization/"}]},{"title":"CSharp LINQ","slug":"csharp/CSharp-linq","date":"2023-02-15T02:18:03.000Z","updated":"2023-02-15T11:53:42.712Z","comments":true,"path":"/2023/02/15/csharp/CSharp-linq/","link":"","permalink":"http://cencuansen.github.com/2023/02/15/csharp/CSharp-linq/","excerpt":"","text":"说明LINQ 意为集成查询语言，将查询功能集成到 C# 语言的技术统称，借助 LINQ，查询成为了最高级的语言构造，就像类、方法和事件一样。支持数据对象 (LINQ to Objects)、关系数据库 (LINQ to SQL) 和 XML (LINQ to XML) 等。查询表达式必须以 from 子句开头，必须以 group 子句或 select 子句结尾。into 存储分组结果，let 存储临时变量。 惰性计算(lazy computation)是指延迟执行查询，直到实际需要时再执行查询。当查询定义完成后，将创建一个查询表达式树，该树描述查询的结构和要执行的操作。当枚举查询结果或使用查询结果时，才会执行查询表达式树上的操作。每个操作只在该操作对应的结果需要时才被执行，并且结果仅在需要时存储。因此，在数据量很大的情况下，可以避免加载整个数据集到内存中的性能损失。","categories":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/tags/CSharp/"},{"name":"LINQ","slug":"LINQ","permalink":"http://cencuansen.github.com/tags/LINQ/"}]},{"title":"CSharp 异步","slug":"csharp/CSharp-asynchronous","date":"2023-02-15T01:30:32.000Z","updated":"2023-02-15T11:53:42.710Z","comments":true,"path":"/2023/02/15/csharp/CSharp-asynchronous/","link":"","permalink":"http://cencuansen.github.com/2023/02/15/csharp/CSharp-asynchronous/","excerpt":"","text":"同步同步编程中代码逻辑按顺序执行，处理长时间运行的操作（如：IO 操作）时会导致性能问题：软件速度缓慢且无响应。 异步异步编程对于长时间运行或 I&#x2F;O 密集型的操作，会释放主线程以执行其他任务，效率更高。C# 中，异步编程是使用 Task 和 async&#x2F;await 关键字等来实现的。 Thread线程是最基本的工作单元，有自己的栈和内核资源，共用进程资源。 ThreadPool线程池是一堆线程的包装器，由 CLR 维护，当有任务需要处理，先用已创建的空闲线程来执行任务，如果没有空闲线程，可能会创建新线程，也可能会等待。线程池适合不需要结果的短时操作。 Task .NET 4 推出 Task，.NET 4.5 推出 async&#x2F;await； Task 基于池线程，不是全局线程池，而是本地线程池，避免线程资源竞争； Task 提供了丰富的 API 来管理线程、控制； Task 依赖于 CPU，对于多核的 CPU，性能更佳； 创建一个 task 也有 3 种方式：前面 2 种是一样的，不需要用 start 来开始执行，后面一种需要 start 来执行。 Task.Factory.StartNew() Task.Run() new Task() 对比 Thread、ThreadPool ，Task 原生支持延续、取消、失败通知； Task 不应该用于执行长时任务; 123Task&lt;string&gt; task1 = Task.Run&lt;string&gt;(() =&gt; &quot;something to do&quot;);// 在获取Result结果时会阻塞线程var result = task1.Result; async&#x2F;awaitasync&#x2F;await 用于简化异步代码的编写和理解，以更加自然的方式编写异步代码，避免回调地狱和复杂的状态机。async 修饰的方法表示这是一个异步方法，而 await 表示等待异步方法执行完成。使用 await 等待一个异步方法时，程序将暂停执行当前方法，等待异步方法完成，然后继续执行后续代码。async&#x2F;await 更适合处理 I/O 密集型 操作，或 UI 事件响应；","categories":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/tags/CSharp/"},{"name":"Asynchronous","slug":"Asynchronous","permalink":"http://cencuansen.github.com/tags/Asynchronous/"},{"name":"Synchronous","slug":"Synchronous","permalink":"http://cencuansen.github.com/tags/Synchronous/"},{"name":"Task","slug":"Task","permalink":"http://cencuansen.github.com/tags/Task/"},{"name":"async/await","slug":"async-await","permalink":"http://cencuansen.github.com/tags/async-await/"}]},{"title":"CSharp 委托和事件","slug":"csharp/CSharp-delegate-and-event","date":"2023-02-15T01:29:35.000Z","updated":"2023-02-15T11:53:42.711Z","comments":true,"path":"/2023/02/15/csharp/CSharp-delegate-and-event/","link":"","permalink":"http://cencuansen.github.com/2023/02/15/csharp/CSharp-delegate-and-event/","excerpt":"","text":"委托委托约定方法签名，引用一个或多个方法，调用委托就是调用委托引用的全部方法。 事件类或对象通过事件向其他类或对象通知发生的相关事情。事件只能在定义的类内部调用； 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;namespace SimpleTest&#123; internal class Program &#123; private static void Main(string[] args) &#123; Publisher publisher = new Publisher(); Subscriber subscriber = new Subscriber(publisher); // 触发事件 publisher.Trigger(); Console.ReadLine(); &#125; &#125; /// &lt;summary&gt; /// 发布者 /// &lt;/summary&gt; public class Publisher &#123; public delegate void NoticeHandler(string message); public event NoticeHandler OnNotice; public void Trigger() &#123; // 传递事件及参数 OnNotice?.Invoke(&quot;警告！警告！警告！警告&quot;); &#125; &#125; /// &lt;summary&gt; /// 订阅者 /// &lt;/summary&gt; public class Subscriber &#123; public Subscriber(Publisher pub) &#123; //订阅事件 pub.OnNotice += NoticeHandler; &#125; /// &lt;summary&gt; /// 订阅事件后的响应函数 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt; private void NoticeHandler(string message) &#123; Console.WriteLine($&quot;Notice Handler Got Message: &#123;message&#125;&quot;); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System;namespace MyConsole&#123; public delegate string DelegateFun(string word); public class Test &#123; public event DelegateFun EventSay; public DelegateFun DelegateSay; public void DoEventSay(string str) &#123; if (EventSay != null) &#123; EventSay(str); &#125; &#125; &#125; internal static class Program &#123; private static void Main(string[] args) &#123; Test t = new Test(); t.EventSay += Say1; t.DelegateSay += Say1; t.DelegateSay += Say2; // 错误 事件不能在外部直接调用 // t.eventSay(&quot;eventSay&quot;); // 正确 事件只能在声明的类内部调用 t.DoEventSay(&quot;eventSay&quot;); // 正确。委托可以在外部直接调用，内部调用也行，还能有返回值，返回最后一个注册的方法的返回值 string str = t.DelegateSay(&quot;deleSay&quot;); Console.Read(); &#125; private static string Say1(string word) &#123; Console.WriteLine(word); return &quot;return &quot; + word; &#125; private static string Say2(string word) &#123; Console.WriteLine(word); return &quot;return &quot; + word + &quot; 2&quot;; &#125; &#125;&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/tags/CSharp/"},{"name":"Delegate","slug":"Delegate","permalink":"http://cencuansen.github.com/tags/Delegate/"},{"name":"Event","slug":"Event","permalink":"http://cencuansen.github.com/tags/Event/"}]},{"title":"CSharp dispose","slug":"csharp/CSharp-dispose","date":"2023-02-14T15:37:48.000Z","updated":"2023-02-15T11:53:42.712Z","comments":true,"path":"/2023/02/14/csharp/CSharp-dispose/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/csharp/CSharp-dispose/","excerpt":"","text":"IDisposable.Dispose对于非托管资源建立和释放，C# 约定由 Dispose 方法来处理。当类库中涉及到非托管资源，就应实现 Dispose 方法，来定义资源释放逻辑。using 用来管理实现了 Dispose 方法的类，编译器会在作用域结束时调用 Dispose 方法。非托管资源包括：网络请求，数据库连接，句柄等。 标准 dispose 模式 析构函数中调用 dispose 方法，托底防忘记调用； dispose 中最后要调用 GC.SuppressFinaliza 方法，通知 CLR 无需执行析构函数，因为清除工作已完成； 多次调用 dispose 应该是安全的，dispose 方法调用后，后续再调用都不会执行额外的工作； dispose 方法有 2 个重载：public 和 protected，protected 真实清除，public 调用 protected； 析构函数调用 protected； protected 的 bool 参数区分是被析构函数调用（false）还是被 public 调用（true）； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071using System;using System.Runtime.InteropServices;namespace MyConsole.DisposeDemo&#123; /// &lt;summary&gt; /// 用于模拟一个托管资源 /// &lt;/summary&gt; public class SomeManagedResource &#123; public SomeManagedResource(string name) &#123; Name = name; &#125; public string Name &#123; get; &#125; &#125; /// &lt;summary&gt; /// 用于模拟一个非托管资源 /// &lt;/summary&gt; public class MyUnmanagedResource : IDisposable &#123; // 模拟一个非托管资源 private IntPtr someUnmanagedResource = Marshal.AllocHGlobal(100); // 模拟一个托管资源 private SomeManagedResource managedResource = new SomeManagedResource(&quot;这是托管资源&quot;); // 是否被清理过的标识 protected bool baseDisposed = false; public void Dispose() &#123; Dispose(true); GC.SuppressFinalize(this); &#125; protected virtual void Dispose(bool isDisposing) &#123; // 确保多次执行的安全性 if (baseDisposed) &#123; return; &#125; // 被 public 调用，需要额外清理托管资源 if (isDisposing) &#123; // 要调用 SuppressFinaliza，需手动清理托管资源, 否则无法释放。 if (managedResource != null) &#123; managedResource = null; &#125; &#125; // 清理非托管资源 if (someUnmanagedResource != IntPtr.Zero) &#123; Marshal.FreeHGlobal(someUnmanagedResource); someUnmanagedResource = IntPtr.Zero; &#125; baseDisposed = true; &#125; ///&lt;summary&gt; /// 必须，以防忘记调用 Dispose 方法的托底方法 ///&lt;/summary&gt; ~MyUnmanagedResource() &#123; // 必须为false Dispose(false); &#125; &#125;&#125; Finalize 无法显式的重写 Finalize 方法，只能通过析构函数语法形式来实现。 struct 中不允许定义析构函数，只有 class 中才可以，并且只能有一个。 Finalize 方法不能被继承或重载。 执行垃圾回收之前系统会自动执行 Finalize 操作。 Finalize 方法会极大地损伤性能。","categories":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/tags/CSharp/"},{"name":"Dispose","slug":"Dispose","permalink":"http://cencuansen.github.com/tags/Dispose/"}]},{"title":"CSharp 简单应用","slug":"csharp/CSharp-usage","date":"2023-02-14T15:27:46.000Z","updated":"2023-02-15T11:53:42.713Z","comments":true,"path":"/2023/02/14/csharp/CSharp-usage/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/csharp/CSharp-usage/","excerpt":"","text":"生成二维码1234567891011public Stream QRCodeStream(string contents)&#123; QRCodeGenerator qrGenerator = new QRCodeGenerator(); QRCodeData qrCodeData = qrGenerator.CreateQrCode(contents, QRCodeGenerator.ECCLevel.L); QRCode qrCode = new QRCode(qrCodeData); Bitmap bigMap = qrCode.GetGraphic(20, Color.Black, Color.White, true); MemoryStream stream = new MemoryStream(); bigMap.Save(stream, System.Drawing.Imaging.ImageFormat.Png); stream.Position = 0; return stream;&#125; 拼接图片123456789101112131415string file1 = @&quot;C:\\Users\\Admin\\Desktop\\images\\1.png&quot;;string file2 = @&quot;C:\\Users\\Admin\\Desktop\\images\\2.png&quot;;Image image1 = Image.FromStream(new MemoryStream(File.ReadAllBytes(file1)));Image image2 = Image.FromStream(new MemoryStream(File.ReadAllBytes(file2)));var image1Width = image1.Width;var image1Height = image1.Height;var image2Width = image2.Height;var image2Height = image2.Height;var stream = new MemoryStream();using Bitmap map = new Bitmap(image1Width, image1Height);//定义画布Graphics g = Graphics.FromImage(map);//定义画笔g.Clear(Color.White);//把画布更改为白色g.DrawImage(image1, new Point(0, 0));g.DrawImage(image2, new Point(image1Width - image2Width, image1Height - image2Height));map.Save(stream, ImageFormat.Jpeg); 端口占用检查1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465while (true)&#123; Console.WriteLine(&quot;请输入需要检测的端口号(如：80), 输入exit退出此程序&quot;); var inPortString = Console.ReadLine(); Process process = new Process(); if (inPortString == &quot;exit&quot;) &#123; process.Close(); break; &#125; int port = 80; try &#123; if (string.IsNullOrWhiteSpace(inPortString)) &#123; Console.WriteLine(&quot;输入端口号非法，将查询默认端口号：80&quot;); &#125; else &#123; port = Convert.ToInt32(inPortString); &#125; &#125; catch (Exception e) &#123; Console.WriteLine(&quot;输入端口号非法，将查询默认端口号：80&quot;); port = 80; &#125; process.StartInfo.FileName = &quot;cmd.exe&quot;; process.StartInfo.UseShellExecute = false; process.StartInfo.RedirectStandardInput = true; process.StartInfo.RedirectStandardOutput = true; process.StartInfo.RedirectStandardError = true; process.StartInfo.CreateNoWindow = true; process.Start(); process.StandardInput.WriteLine(&quot;netstat -ano&quot;); process.StandardInput.WriteLine(&quot;exit&quot;); Regex reg = new Regex(&quot;\\\\s+&quot;, RegexOptions.Compiled); bool found = false; string line = string.Empty; while ((line = process.StandardOutput.ReadLine()) != null) &#123; line = line.Trim(); if (line.StartsWith(&quot;TCP&quot;, StringComparison.OrdinalIgnoreCase)) &#123; line = reg.Replace(line, &quot;,&quot;); string[] arr = line.Split(&#x27;,&#x27;); if (arr[1].EndsWith($&quot;:&#123;port&#125;&quot;)) &#123; found = true; int pid = int.Parse(arr[4]); Process foundProcess = Process.GetProcessById(pid); Console.WriteLine($&quot;&#123;port&#125;端口. pid：&#123;pid&#125;, 进程名：&#123;foundProcess.ProcessName&#125;\\n&quot;); break; &#125; &#125; &#125; if (!found) &#123; Console.WriteLine($&quot;未找到&#123;port&#125;端口上的进程\\n&quot;); &#125; process.Close();&#125; byte[]、string、stream 间转换stream -&gt; string12using StreamReader reader = new StreamReader(stream);string result = reader.ReadToEnd(); string -&gt; stream12345string test = &quot;This is string&quot;;using MemoryStream stream = new MemoryStream();using StreamWriter writer = new StreamWriter( stream );writer.Write( test );writer.Flush(); byte[] -&gt; string1string str = System.Text.Encoding.Default.GetString( byteArray ); string -&gt; byte[]1byte[] byteArray = System.Text.Encoding.Default.GetBytes( str ); stream -&gt; byte[]12byte[] bytes = new byte[stream.Length];stream.Read(bytes, 0, bytes.Length); byte[] -&gt; stream1using Stream stream = new MemoryStream(bytes); 文本长度12345678string strTmp = &quot;a1某某某&quot;;// 10，Unicode下中英文每个字2字节。int len1 = System.Text.Encoding.Unicode.GetBytes(strTmp).Length;// 11，Default 等价与 UTF8，中文3个字节，英文1个字节int len2 = System.Text.Encoding.Default.GetBytes(strTmp).Length;int len3 = System.Text.Encoding.UTF8.GetBytes(strTmp).Length;// 5，就是个数int len4 = System.Text.Encoding.Default.GetBytes(strTmp).Length; WebSocket 应用Startup.Configure1app.UseWebSockets(); Controller.cs123456789101112131415161718192021222324252627282930313233[HttpGet(&quot;receive-message&quot;)]public async Task GetMessage()&#123; if (HttpContext.WebSockets.IsWebSocketRequest) &#123; using (var webSocket = await HttpContext.WebSockets.AcceptWebSocketAsync()) &#123; Console.WriteLine(&quot;WebSocket connection established&quot;); await Echo(webSocket); &#125; &#125; else &#123; HttpContext.Response.StatusCode = 400; &#125;&#125;private async Task Echo(WebSocket webSocket)&#123; var buffer = new byte[1024 * 4]; var result = await webSocket.ReceiveAsync(new ArraySegment&lt;byte&gt;(buffer), CancellationToken.None); Console.WriteLine(&quot;Message received from Client&quot;); while (!result.CloseStatus.HasValue) &#123; var serverMsg = Encoding.UTF8.GetBytes($&quot;Server: Hello. You said: &#123;Encoding.UTF8.GetString(buffer)&#125;&quot;); await webSocket.SendAsync(new ArraySegment&lt;byte&gt;(serverMsg, 0, serverMsg.Length), result.MessageType, result.EndOfMessage, CancellationToken.None); Console.WriteLine(&quot;Message sent to Client&quot;); result = await webSocket.ReceiveAsync(new ArraySegment&lt;byte&gt;(buffer), CancellationToken.None); Console.WriteLine(&quot;Message received from Client&quot;); &#125; await webSocket.CloseAsync(result.CloseStatus.Value, result.CloseStatusDescription, CancellationToken.None); Console.WriteLine(&quot;WebSocket connection closed&quot;);&#125; index.html12var socket = new WebSocket(&#x27;wss://localhost:6666/receive-message&#x27;);socket.send(&#x27;前端消息&#x27;); HTTP 网络请求HttpWebRequest：最早，不阻塞 ui，细节控制；WebClient：对 HttpWebRequest 的简化和封装；HttpClient：.NET 4.5 开始，预热机制，适合发送多次请求； HttpClient1234567var httpClientHandler = new HttpClientHandler&#123; Proxy = new WebProxy(&quot;http://127.0.0.1:1080&quot;, false),// 设置代理&#125;;var httpClient = new HttpClient(httpClientHandler);var response = await httpClient.GetAsync(&quot;http://www.baidu.com&quot;);var responseText = await response.Content.ReadAsStringAsync(); HttpClient 存在 Dispose 后不能立即释放对应套接字问题，默认需要 4 分钟去释放。可以创建一个 HttpClient 实例，把它存储在一个静态字段中，或者使用 HttpClientFactory，相关文章。","categories":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/tags/CSharp/"}]},{"title":"CSharp .NET 和 C#","slug":"csharp/CSharp-dotnet-and-csharp","date":"2023-02-14T15:21:07.000Z","updated":"2023-02-15T11:53:42.712Z","comments":true,"path":"/2023/02/14/csharp/CSharp-dotnet-and-csharp/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/csharp/CSharp-dotnet-and-csharp/","excerpt":"","text":"C# 和 .NET 语言版本 发布时间 .NET Framework 要求 Visual Studio 版本 C# 1.0 2002.1 .NET Framework 1.0 Visual Studio .NET 2002 C# 1.1&#x2F;1.2 2003.4 .NET Framework 1.1 Visual Studio .NET 2003 C# 2.0 2005.11 .NET Framework 2.0 Visual Studio 2005 C# 3.0 2007.11 .NET Framework 2.0&#x2F;3.0&#x2F;3.5 Visual Studio 2008 C# 4.0 2010.4 .NET Framework 4.0 Visual Studio 2010 C# 5.0 2012.8 .NET Framework 4.5 Visual Studio 2012&#x2F;2013 C# 6.0 2015.7 .NET Framework 4.6 Visual Studio 2015 C# 7.0 2017.3 .NET Framework 4.6.2 Visual Studio 2017 C# 7.1 2017.6 .NET Framework 4.7 Visual Studio 2017 v15.3 预览版 C# 7.2 2017.11 .NET Framework 4.7.1 Visual Studio 2017 v15.5 C# 7.3 2018.5 .NET Framework 4.7.2 Visual Studion 2017 v15.7 C# 8.0 2019.04.18 .NET Framework 4.8&#x2F;.NET Core 3&#x2F;3.1 Visual Studion 2019 C# 9 2020.09.04 .NET 5 Visual Studion 2019 C# 10.0 2021.11.09 .NET 6 Visual Studion 2022 C# 11 2022.11.8 .NET 7 Visual Studion 2022 C# 版本及其语言特性C# 1.0 [2002 年 01 月]类、结构、接口、事件、属性、委托，运算符和表达式、语句、特性 C# 2.0 [2005 年 11 月]泛型、Partial 类型、匿名方法、迭代器、可空类型、私有 setters、方法组转化(delegates)、协变和逆变、静态类 C# 3.0 [2007 年 11 月]隐式类型的局部变量(var)、对象与集合初始化器、自动实现属性(get;set;)、Partial 方法、匿名类、扩展方法、LINQ、Lambda 表达式、表达式树https://msdn.microsoft.com/en-us/library/bb308966.aspx C# 4.0 [2010 年 04 月]动态绑定(dynamic)、命名参数和可选参数、泛型协变和逆变、嵌入式互操作类型https://msdn.microsoft.com/en-us/magazine/ff796223.aspx C# 5.0 [2012 年 08 月]异步特性(async &amp; await)、调用者信息https://learn.microsoft.com/zh-cn/archive/blogs/mvpawardprogram/an-introduction-to-new-features-in-c-5-0 C# 6.0 [2015 年 07 月]表达式为主体的成员方法和只读属性、属性初始化赋值、nameof 表达式、Await in catch block、异常过滤器(when)、字符串插值https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6 C# 7.0 [2017 年 03 月]out variables、Tuples、Discards、Pattern Matching、局部方法、Generalized async return typeshttps://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7 C# 8.0 [2019 年 04 月]Readonly members、默认接口方法、Using declarations、静态局部方法、Disposable ref structs、可空引用类型https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8 C# 9.0 [2020 年 09 月]Records、Init-only properties、Top-level statements、Init accessors and readonly fields、With 表达式、Value-based equality、Primary constructorhttps://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9 C# 10.0 [2021 年 11 月]Record structs、Global using directives、File-scoped namespace declaration、Extended Proptery Patterns、Null Parameter Checking、Constant interpolated stringshttps://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10 C# 11.0 [2022 年 11 月]原生字符串字面量、Generic math support、泛型 attributes、UTF-8 字符串字面量、Newlines in string interpolation expressions、List patterns、file 类修饰符、Required members、Auto-default structs、Pattern match Span on a constant string、Extended nameof scope、Numeric IntPtr、ref fields and scoped ref、Improved method group conversion to delegate、Warning wave 7https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11综合https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history","categories":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/tags/CSharp/"},{"name":".NET","slug":"NET","permalink":"http://cencuansen.github.com/tags/NET/"},{"name":"Features","slug":"Features","permalink":"http://cencuansen.github.com/tags/Features/"}]},{"title":"CSharp 基础知识","slug":"csharp/CSharp-basic-concepts","date":"2023-02-14T14:49:07.000Z","updated":"2023-02-15T11:53:42.711Z","comments":true,"path":"/2023/02/14/csharp/CSharp-basic-concepts/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/csharp/CSharp-basic-concepts/","excerpt":"","text":"string.Empty、 “” 、 null。Empty 是 string 类中的一个静态的只读字段。string.Empty 和 “” 是一样的。string str &#x3D; null 表示 str 未指向任何对象。 string 和 StringBuilderstring 是不可变对象，string 是 String 的别名，string 是 c#中的类，String 是 Framework 的类，编译器会把 string 编译成 String。StringBuilder 为动态字符串。StringBuilder 当达到容量时，将自动分配新的空间且容量翻倍。 扩展方法向现有类型“添加”方法，无需派生、重新编译或修改原始类型。扩展方法是一种静态类中的静态方法。扩展方法第一个参数是 this 修饰的被扩展的类。 装箱和拆箱装箱：值类型 -&gt; 引用类型 。拆箱：引用类型 -&gt; 值类型。一次装箱要分配内存（托管堆）和拷贝数据（从栈到托管堆）。拆箱就是装箱的相反操作。 更改已装箱的对象已装箱的对象，无法直接调用其指定方法。让类对象继承一个接口，借助接口方式来更改已装箱的对象中的数据。 123456789101112131415161718public interface ISomeClass &#123; void Change(int x);&#125;public class SomeClass : ISomeClass&#123; public int x &#123; get; set; &#125; public void Change(int x) &#123; this.x = x; &#125;&#125;SomeClass some = new SomeClass();some.x = 100;Object o = some; // 装箱((SomeClass)o).Change(200); // 没改掉。((ISomeClass)o).Change(200); // 改掉了。 new 关键字 运算符：创建对象实例。 修饰符：在派生类定义一个重名的方法，隐藏基类方法。 约束：泛型约束，表示泛型类型要有 public 修饰的无参构造。 12public class ItemFactory&lt;T&gt; where T : IComparable, new()&#123; &#125; new 和 overridenew 和 override 都可用覆盖基类同名方法；new 覆盖基类不完全，父类引用子类实例时，能调用到基类方法，override 覆盖基类是彻底的，一旦子类 override 基类方法后，就无法再调用基类同名方法。 123456789101112131415161718192021222324252627282930313233class Parent&#123; public virtual string Say () &#123; return &quot;I am parent&quot;; &#125;&#125;class Child1 : Parent&#123; public override string Say () &#123; return &quot;I am child1&quot;; &#125;&#125;class Child2 : Parent&#123; public new string Say () &#123; return &quot;I am child2&quot;; &#125;&#125;// 父类引用子类实例Parent instance1 = new Child1();// I am child1string who1 = instance1.Say();// 父类引用子类实例Parent instance2 = new Child2();// 注意，这里就能调用到基类方法，结果为：I am parentstring who1 = instance2.Say(); int? 和 int可空类型，默认值可以是 null。int? 是通过 int 装箱为引用类型实现。Nullable.GetUnderlyingType(typeof(int?)) != null 用来判断类型是否是可空类型 委托约定方法签名，来对方法进行引用，类似指针，方法能当参数传递给形参，用于事件、回调等。 const 和 readonlyreadonly 运行时常量。const 编译时常量。readonly 常量只能声明为类字段。const 除了类字段，还可以声明为方法中的局部常量，默认为静态类型，不能用 static 修饰。 CTS、CLS、CLRCTS：通用类型系统；CLS：通用语言规范；CLR：公共语言运行库； using 引用命名空间。 using 一个非托管资源（IDisposiable），用来释放资源。 托管资源、非托管资源托管资源指的是.NET 可以自动进行回收的资源，主要是指托管堆上分配的内存资源。非托管资源指的是.NET 不知道如何回收的资源，最常见的是包装操作系统资源的对象，例如文件，窗口，网络连接，数据库连接，画刷，图标等。建议通过调用 IDisposable.Dispose()方法来回收非托管资源。 ref、out、in相同：都是按引用传递，形参成为实参的别名；不同：ref 在方法外需初始化；out 需在方法内赋值；in 在方法内是只读的。 123456789101112131415static void Main(string[] args)&#123; //初始化 int number = 50; Console.WriteLine(&quot;调用方法前 number 值：&quot; + number); RefFunction(ref number); Console.WriteLine(&quot;调用方法后 number 值：&quot; + number); Console.Read();&#125;// 传入的参数值是 50 ，方法中使用的 num 值也是 50static void RefFunction(ref int num)&#123; num = num / 2;&#125; 12345678910111213141516static void Main(string[] args)&#123; int number = 50; Console.WriteLine(&quot;调用方法前 number 值：&quot; + number); OutFunction(out number); Console.WriteLine(&quot;调用方法后 number 值：&quot; + number); Console.Read();&#125;// 无法将的参数值 50 传入 ，但是必须在方法中初始化static void OutFunction(out int num)&#123; //初始化 num = 120; num = num / 2;&#125; in 的意义结构体实例数据分配在栈上，当需要将大数据量的结构体作为方法参数时，会复制一份该大结构体，成本有点高，使用 in 来按引用传递该大结构体，就能避免复制问题。 ref、out、in 使用限制async 修饰的异步方法中无法使用；迭代器方法（含有 yield return 或 yield break 的方法）中无法使用；扩展方法的第一个参数不能有 in 修饰符，除非该参数是结构体；扩展方法的第一个参数，其中该参数是泛型类型（即使该类型被约束为结构体）； Equals 和 &#x3D;&#x3D;&#x3D;&#x3D; 值类型数据比较的是值，引用类型比较的是引用地址。Equals 引用类型比较的是最终数据。 as 和 isis 判断对象是否兼容于某类型，返回 bool 值，永远不会抛出异常。as 用于在兼容的引用类型之间执行转换。无法转换则为 null。is 需要做两次对象的类型检查，而 as 需要做一次对象类型检查。 访问修饰符public：共有的，访问不受限制；private：私有的，只能在当前类中访问；internal：内部的，只能在当前程序集中访问；protected：受保护的，只能在当前类或其派生类中访问；file：当前文件范围，C# 11 新增；protected internal：受保护的内部成员，当前程序集或派生自包含类的类型可访问；private protected：私有受保护的成员，当前程序集中的包含类或从包含类派生的类型可访问；class 默认 internal，class member 默认 private。 class 成员、interface 成员class 成员：字段、常量、属性、方法、事件、运算符、索引器、构造函数、终结器、嵌套类型。interface 成员：方法、属性、索引器和事件 类的执行顺序父类，子类，静态块，静态字段，非静态块，非静态字段，构造器，方法 数据类型和内存占用1 byte bool、byte2 byte char、short4 byte int、float8 byte long、double16 byte decimal 多态编译时多态和运行时多态。 编译时多态重载编译时多态。根据签名不同分为不同的方法，编译后就成两个不同名函数。 运行时多态虚方法是运行时多态，父类中有虚方法，子类覆盖实现虚方法。 浅拷贝和深拷贝在浅拷贝中，仅对顶级对象进行了复制，对低级别对象进行了引用。在深拷贝中，会复制所有对象。 浅拷贝继承 ICloneable，实现 Clone()方法，方法中调用 MemberwiseClone()；如果字段是值类型，则执行字段的按位复制；如果字段是引用类型，引用将复制，但被引用的对象不会被复制。 协变和逆变in 逆变，out 协变。赋值的兼容性，用在委托或者接口上。需要返回数据，这种结构化的委托有效性之间的关系叫做协变，用 out 标记泛型类型。需要接受数据，期望传入基类时允许传入派生对象的特性叫逆变，用 in 标记泛型类型。协变： IEnumerable IEnumerator IQueryable IGrouping&lt;out TKey, out TElement&gt; 逆变： IComparer IEqualityComparer IComparable Action Predicate Comparison 协变 + 逆变： TOutput Converter&lt;in TInput, out TOutput&gt; object 和 dynamicobject 是一种引用类型，表示 .NET 框架中的任何类型。它是所有引用类型的基类，允许将任何类型的对象存储在这个变量中。dynamic 是 C# 中的一个关键字，在编译时将变量的类型指定为 dynamic ，对象的实际类型将在运行时确定，这在使用没有特定类型定义的 API 或库时非常有用。 总结object 是基类，可以存储任何引用类型；dynamic 是关键字，在编译时跳过类型检查，在运行时确定类型。 场景object 在我们不知道数据类型时很有用。dynamic 更多是用在反射，支持动态语言，COM 对象调用以及获取 LINQ 的查询结果。 12345object a = &quot;Rohatash Kumar&quot;;string a1 = a.ToString();dynamic a = &quot;Rohatash Kumar&quot;;string a1 = a; 抽象类和接口 都能有默认实现； 都不能直接实例化； 抽象类单继承，接口多继承； 抽象类中可以有字段、属性、方法，接口中可以有属性、方法、索引器、事件，没有字段；","categories":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/tags/CSharp/"}]},{"title":"HTML src 和 href","slug":"web/HTML-src-and-href","date":"2023-02-14T14:27:46.000Z","updated":"2023-02-15T11:53:42.715Z","comments":true,"path":"/2023/02/14/web/HTML-src-and-href/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/web/HTML-src-and-href/","excerpt":"","text":"作用结果不同href 用于在当前文档和引用资源之间建立联系。src 加载资源，嵌入相应元素中。 浏览器解析方式不同href 浏览器会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。src 会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，如图片(img)和框架(iframe)等，类似于将资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。 请求资源类型不同href（Hypertext Reference，超文本引用）用来建立当前元素和文档之间的链接。如：link、a。src 的资源，会将资源下载并应用到文档中，常用的有 script，img 、iframe。 使用1234567&lt;link href=&quot;./style.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;a href=&quot;http://example.com&quot; target=&quot;_blank&quot;&gt;click here&lt;/a&gt;&lt;script src=&quot;http://example.com/foo.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;img src=&quot;http://example.com/bar.png&quot;&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"http://cencuansen.github.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://cencuansen.github.com/tags/HTML/"}]},{"title":"Web 浏览器中网络请求过程","slug":"web/Web-request-process-in-browser","date":"2023-02-14T14:21:06.000Z","updated":"2023-02-15T11:53:42.716Z","comments":true,"path":"/2023/02/14/web/Web-request-process-in-browser/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/web/Web-request-process-in-browser/","excerpt":"","text":"地址解析，提取出协议、域名、端口等信息等 通过 DNS 获取到 IP 地址 进行 TCP 连接(三次握手)a. 第一次握手：建立连接时，客户端发送 syn(建立联机)包到服务器，并进入 syn_send 状态，等待服务器确认；b. 第二次握手：服务器收到 syn 包，确认包信息，同时自己也发送一个 syn + ack(确认)包并进入 syn_recv 状态;c. 第三次握手：客户端收到 syn+ack 包，向服务器发送 ack 包，发送完后，客户端和服务器都进入 established 状态，完成三次握手； HTTP 请求 服务器响应请求 DOM 解析和渲染","categories":[{"name":"Web","slug":"Web","permalink":"http://cencuansen.github.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://cencuansen.github.com/tags/Web/"},{"name":"Request","slug":"Request","permalink":"http://cencuansen.github.com/tags/Request/"}]},{"title":"Web DOM 的解析和渲染","slug":"web/Web-dom-parsing-and-rendering","date":"2023-02-14T14:12:08.000Z","updated":"2023-02-15T11:53:42.716Z","comments":true,"path":"/2023/02/14/web/Web-dom-parsing-and-rendering/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/web/Web-dom-parsing-and-rendering/","excerpt":"","text":"解析流程 解析 html，构建 DOM Tree 解析 CSS，构建 CSS Rule Tree 由 DOM Tree 和 CSS Rule Tree 生成 Render Tree 利用 Render Tree 进行布局 Layout，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置 painting 绘制 按照算出来的规则将内容绘制到屏幕上 相关问题问：DOM 树的构建是文档加载完成开始的？答：不是，为更好用户体验，渲染引擎会尽快将内容进行显示，加载部分后就尝试解析、构建、布局、渲染。问：Render 树是 DOM 树和 CSSOM 树构建完毕才开始构建的吗？答：不是。三者交叉进行，一边加载，一边解析，一边渲染。问：CSS 解析顺序？答：选择器从右往左，DOM 树从下向上的解析顺序。嵌套标签越多解析越慢。问：repaint 重绘？答：改变元素背景色、前景色、边框色等，不影响文档中周边元素布局位置。问：reflow 回流？答：影响元素布局位置变更的操作，会导致回流，从根向下重新计算全部元素节点尺寸和位置，比如：元素显隐、元素尺寸变更、定位方式等，都会引起内部、周围、整个页面的重新渲染。通常无法预估页面哪部分会回流，它们都彼此相互影响着。频繁回流会影响性能。","categories":[{"name":"Web","slug":"Web","permalink":"http://cencuansen.github.com/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://cencuansen.github.com/tags/Web/"},{"name":"Dom","slug":"Dom","permalink":"http://cencuansen.github.com/tags/Dom/"},{"name":"Dom Parsing","slug":"Dom-Parsing","permalink":"http://cencuansen.github.com/tags/Dom-Parsing/"},{"name":"Dom Rendering","slug":"Dom-Rendering","permalink":"http://cencuansen.github.com/tags/Dom-Rendering/"}]},{"title":"HTML 块级格式化上下文","slug":"web/HTML-block-formatting-context","date":"2023-02-14T11:53:32.000Z","updated":"2023-02-15T11:53:42.715Z","comments":true,"path":"/2023/02/14/web/HTML-block-formatting-context/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/web/HTML-block-formatting-context/","excerpt":"","text":"概念一个块级格式化上下文（Block Formatting Context），包含该上下文元素的所有直接子元素，但是不包括子元素的子元素。 案例123456&lt;div class=&quot;box-a&quot; id=&quot;bfc1&quot;&gt; &lt;div class=&quot;box-b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box-c&quot; id=&quot;bfc2&quot;&gt; &lt;div class=&quot;box-d&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; #bfc1 的 BFC 指的是 .box-b 和 .box-c；#bfc2 的 BFC 指的是 .box-d； 特点 每一个 BFC 区域只包括其子元素，不包括其子元素的子元素； 每一个 BFC 区域都是独立隔绝的，互不影响！ 三种布局 标准流（normal） 浮动流（float） 定位流（position） 触发 BFC body 根元素； 设置 float，不包括 none； 设置 position，包括 absoulte、fixed； 设置 display 为 inline-block； 设置 overflow，包括 hidden、auto、scroll； 表格单元格，table-cell； 弹性布局，flex； BFC 实际应用兄弟 div margin 重叠问题描述：文档中相邻 div 元素，上下分布，但两者 margin 默认会重叠。解决思路：将相邻兄弟变成非相邻同级：把这两兄弟元素各用 div 包裹，触发包裹元素的 bfc。 父子 div margin 重叠问题描述：文档中父子 div 元素，子 div margin-top 会让父子 div 同时下移。解决思路：触发父级 bfc、父级设置边框。 清除浮动影响问题描述：父元素没设置高度，包含一个子元素，子元素设置浮动，父元素会高度塌陷。","categories":[{"name":"HTML","slug":"HTML","permalink":"http://cencuansen.github.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://cencuansen.github.com/tags/HTML/"},{"name":"BFC","slug":"BFC","permalink":"http://cencuansen.github.com/tags/BFC/"}]},{"title":"CSS transform、transition、animation","slug":"css/CSS-transform-transition-animation","date":"2023-02-14T11:41:16.000Z","updated":"2023-02-15T11:53:42.714Z","comments":true,"path":"/2023/02/14/css/CSS-transform-transition-animation/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/css/CSS-transform-transition-animation/","excerpt":"","text":"transformtransform: [转换函数];转换函数：translate、scale、rotate、skew。transform 只影响当前元素，不影响文档流。 12transform: translateX(1px);transform: translateY(2px); 特性参考：https://www.bilibili.com/video/BV1L3411C76T 变换后盒子模型占据的尺寸和位置不会变换； 变换后会创建层叠上下文； 对内联元素无效； 不同顺序效果不同； 锯齿或虚化问题； transition改变目标元素的样式：颜色、外观、尺寸，一般搭配伪类。transition 尺寸变更会对文档流产生影响。 12345678.box &#123; width: 10px; transition: width 0.4s ease;&#125;.box:hover &#123; width: 50px;&#125; 或者用 JavaScript 改变元素属性触发 transition 12345678910.box &#123; width: 100px; height: 100px; background-color: blueviolet; transition: width 1s linear 0.5s;&#125;.box1 &#123; width: 400px;&#125; 1document.querySelector(&#x27;.box&#x27;).classList.add(&#x27;box1&#x27;); 局限性 transition 需要触发，没法在网页加载时自动发生。 transition 是一次性的，不能重复发生，除非一再触发。 transition 只能定义开始状态和结束状态，不能定义中间状态。 一条 transition 规则，只能定义一个属性的变化，不能涉及多个属性。 animationtransition 不够用的时候，可以使用 animation。animation 搭配 @keyframes 使用，无需搭配伪类，页面加载 animation 就自动开始了。 123456789101112131415161718192021.animation1 &#123; /* forwards：动画结束时，就停在最终状态 */ animation: changeAnimation 1s ease forwards;&#125;.animation2 &#123; /* infinite alternate：无限循环 + 往复 */ animation: changeAnimation 1s ease infinite alternate;&#125;@keyframes changeAnimation &#123; 0% &#123; width: 110px; &#125; 50% &#123; width: 140px; &#125; 100% &#123; width: 200px; &#125;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/tags/CSS/"},{"name":"transform","slug":"transform","permalink":"http://cencuansen.github.com/tags/transform/"},{"name":"transition","slug":"transition","permalink":"http://cencuansen.github.com/tags/transition/"},{"name":"animation","slug":"animation","permalink":"http://cencuansen.github.com/tags/animation/"}]},{"title":"CSS 伪类和伪元素","slug":"css/CSS-pseudo-classes-and-pseudo-elements","date":"2023-02-14T09:35:15.000Z","updated":"2023-02-15T11:53:42.714Z","comments":true,"path":"/2023/02/14/css/CSS-pseudo-classes-and-pseudo-elements/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/css/CSS-pseudo-classes-and-pseudo-elements/","excerpt":"","text":"伪类功能和 class 有些类似，但它是基于文档之外的抽象，所以叫伪类。 :link、:visited、:hover、:active、:focus、:right、:left、:first、:lang、:first-child 伪元素伪元素是 DOM 树没有定义的虚拟元素。 ::before、::after、::selection","categories":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/tags/CSS/"}]},{"title":"CSS 选择第二个以及后续元素","slug":"css/CSS-select-children-between-2nd-and-last","date":"2023-02-14T09:28:47.000Z","updated":"2023-02-15T11:53:42.714Z","comments":true,"path":"/2023/02/14/css/CSS-select-children-between-2nd-and-last/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/css/CSS-select-children-between-2nd-and-last/","excerpt":"","text":"元素如下，希望除了第一个子 div 不选择，其他子 div 都选择。 123456&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item item-1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item item-2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item item-3&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;item item-4&quot;&gt;4&lt;/div&gt;&lt;/div&gt; 方式一 12.item:nth-of-type(n + 2) &#123;&#125; 方式二 12.item:nth-child(n + 2) &#123;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/tags/CSS/"},{"name":"Selector","slug":"Selector","permalink":"http://cencuansen.github.com/tags/Selector/"}]},{"title":"CSS 1像素线","slug":"css/CSS-1px-line","date":"2023-02-14T09:21:43.000Z","updated":"2023-02-15T11:53:42.713Z","comments":true,"path":"/2023/02/14/css/CSS-1px-line/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/css/CSS-1px-line/","excerpt":"","text":"场景移动端开发线条的 1 像素线绘制。 方式 用 0.5px transform scale box-shadow 模拟 图片 scale123456div &#123; height: 1px; display: block; transform: scale(1, 0.5); background-color: #000;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/tags/CSS/"},{"name":"CSS Tricks","slug":"CSS-Tricks","permalink":"http://cencuansen.github.com/tags/CSS-Tricks/"}]},{"title":"JavaScript 深拷贝和浅拷贝","slug":"web/javascript/JavaScript-deep-clone-and-shallow-clone","date":"2023-02-14T09:08:52.000Z","updated":"2023-02-15T11:53:42.719Z","comments":true,"path":"/2023/02/14/web/javascript/JavaScript-deep-clone-and-shallow-clone/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/web/javascript/JavaScript-deep-clone-and-shallow-clone/","excerpt":"","text":"定义浅拷贝：复制一层数据，基本类型直接复制，对象类型复制引用。深拷贝：会递归复制。 浅拷贝 扩展运算符(...) Object.assign 深拷贝 JSON.parse(JSON.stringify()) 遍历递归 JSON 化问题 正则变成空对象(&#123;&#125;)； 函数直接丢； 日期变成时间字符串(无解)； 构造函数丢失，变成 Object； 循环引用无法正确处理； 遍历深拷贝版本一 12345678910111213141516171819202122function deepClone(obj, hash = new WeakMap()) &#123; // 处理null或者undefined if (obj === null) return obj; // 处理日期类型 if (obj instanceof Date) return new Date(obj); // 处理正则类型 if (obj instanceof RegExp) return new RegExp(obj); // 普通值或函数不需要深拷贝 if (typeof obj !== &quot;object&quot;) return obj; // 对象进行深拷贝 if (hash.get(obj)) return hash.get(obj); let cloneObj = new obj.constructor(); // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身 hash.set(obj, cloneObj); for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; // 实现一个递归拷贝 cloneObj[key] = deepClone(obj[key], hash); &#125; &#125; return cloneObj;&#125; 版本二 1234567891011121314151617181920212223242526272829303132const isComplexDataType = obj =&gt; (typeof obj === &#x27;object&#x27; || typeof obj === &#x27;function&#x27;) &amp;&amp; (obj !== null)const deepClone = function (obj, hash = new WeakMap()) &#123; if (obj.constructor === Date) &#123; // 日期对象直接返回一个新的日期对象 return new Date(obj); &#125; if (obj.constructor === RegExp) &#123; // 正则对象直接返回一个新的正则对象 return new RegExp(obj); &#125; if (hash.has(obj)) &#123; // 如果循环引用了就用 weakMap 来解决 return hash.get(obj); &#125; let allDescriptors = Object.getOwnPropertyDescriptors(obj); // 遍历传入参数所有键的特性 let cloneObj = Object.create(Object.getPrototypeOf(obj), allDescriptors); // 继承原型链 hash.set(obj, cloneObj) for (let key of Reflect.ownKeys(obj)) &#123; cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; typeof obj[key] !== &#x27;function&#x27;) ? deepClone(obj[key], hash) : obj[key]; &#125; return cloneObj&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Deep Clone","slug":"Deep-Clone","permalink":"http://cencuansen.github.com/tags/Deep-Clone/"}]},{"title":"JavaScript 模块化","slug":"web/javascript/JavaScript-module","date":"2023-02-14T08:57:11.000Z","updated":"2023-02-15T11:53:42.721Z","comments":true,"path":"/2023/02/14/web/javascript/JavaScript-module/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/web/javascript/JavaScript-module/","excerpt":"","text":"种类 AMD&#x2F;CMD CommonJS(适用于服务端) UMD ESM(EcmaScript Module) AMD&#x2F;CMDAMD：Asynchronous Module Definition，异步模块定义。CMD：Common Module Definition，通用模块定义。相对于 CommonJS，定义了适用于浏览器端的规范。AMD 中有 requirejs，CMD 中有 seajs。用 define 方法来定义一个模块，通过前置依赖列表导入外部模块数据。 CommonJSnodejs 模块化采用的是 CommonJS。module.exports 或 exports 导出，require 导入。CommonJS 规范一些特性：文件系统，同步加载等，不适用于浏览器端，适用于服务端。 UMDUMD：Universal Module Definition，通用模块定义不属于一套模块规范，主要用来处理 CommonJS、AMD、CMD 的差异兼容，使模块代码能在前面不同的模块环境下都能正常运行。 ESMJavaScript 在 ES6 开始引入模块概念：ES Module。export default 或 export 导出，import 导入。动态导入 import() 返回 promise。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Module","slug":"Module","permalink":"http://cencuansen.github.com/tags/Module/"}]},{"title":"JavaScript 继承","slug":"web/javascript/JavaScript-inherit","date":"2023-02-14T08:44:17.000Z","updated":"2023-02-15T11:53:42.720Z","comments":true,"path":"/2023/02/14/web/javascript/JavaScript-inherit/","link":"","permalink":"http://cencuansen.github.com/2023/02/14/web/javascript/JavaScript-inherit/","excerpt":"","text":"ES6 继承12class Parent &#123; &#125;class Child extends Parent &#123; &#125; 寄生组合式继承123456789101112131415161718192021222324function clone(parent, child) &#123; // 该操作将 Parent 原型中属性方法等带到 Child child.prototype = Object.create(parent.prototype); child.prototype.constructor = child;&#125;function Parent() &#123; this.name = &quot;parent&quot;; this.play = [1, 2, 3];&#125;Parent.prototype.getName = function() &#123; return this.name; &#125;;function Child() &#123; // 该 call 操作会将 Parent 自身的属性字段带到 Child Parent.call(this); this.friends = &quot;child&quot;;&#125;clone(Parent, Child);Child.prototype.getFriends = function() &#123; return this.friends;&#125;;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Inherit","slug":"Inherit","permalink":"http://cencuansen.github.com/tags/Inherit/"}]},{"title":"JavaScript 词法作用域和动态作用域","slug":"web/javascript/JavaScript-lexical-scope-and-dynamic-scope","date":"2023-02-13T13:40:43.000Z","updated":"2023-02-15T11:53:42.720Z","comments":true,"path":"/2023/02/13/web/javascript/JavaScript-lexical-scope-and-dynamic-scope/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/web/javascript/JavaScript-lexical-scope-and-dynamic-scope/","excerpt":"","text":"说明JavaScript 中，变量采用的是词法作用域。 词法作用域&#x2F;静态作用域作用域在变量定义时就确定。 动态作用域作用域在变量使用时才确定。 验证123456789101112var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar(); 这里 bar 中 foo 的 value 输出为 1，说明变量在函数定义时就确定了，属于词法作用域。如果是动态作用域，bar 中 foo 的 value 值就应当等于 2。 问题问：this 是动态作用域吗？答：不是。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"http://cencuansen.github.com/tags/Function/"}]},{"title":"JavaScript 闭包","slug":"web/javascript/JavaScript-closure","date":"2023-02-13T13:15:30.000Z","updated":"2023-02-15T11:53:42.718Z","comments":true,"path":"/2023/02/13/web/javascript/JavaScript-closure/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/web/javascript/JavaScript-closure/","excerpt":"","text":"定义闭包是一个特殊的函数，能够记录自己词法作用域内变量的状态，可以读取该作用域内的变量，在函数或语句块结束后，变量仍然对引用它的函数有效。在一个函数中返回函数或者作为回调，这样创建了闭包。当基于参数创建回调，参数必须在闭包中存储（比如：形参存储），否则就会创建一个闭包指向封闭环境中的变量，而这个变量可能会变。 场景一，返回函数123456var add = (function () &#123; var counter = 0; return function () &#123; return counter += 1; &#125;&#125;)();add(); 场景二，作为回调123456for (var i = 0; i &lt; 5; i++) &#123; (function clo(ii) &#123; // 形参 ii 对 i 进行了存储 setTimeout(function() &#123; console.log(ii); &#125;, 20); &#125;)(i);&#125; 或者 1234567// 需要浏览器版本 &gt; IE9for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function(ii) &#123; // 形参 ii 对 i 进行了存储 console.log(ii); &#125;, 20, i);&#125; 用途封装变量：闭包可以隐藏内部变量，使得代码变得更加简洁；模拟私有变量：闭包可以模拟私有变量，使得变量不被外部访问；实现回调函数：闭包可以作为回调函数传递给其他函数，以实现延迟执行；实现单例模式：闭包可以保证一个类型仅有一个实例；构建命名空间：闭包可以构建命名空间，使得变量名不冲突； 注意参数未在闭包中存储，就会创建一个闭包指向封闭环境中的变量，这变量会变。 123456for(var i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; // 未对变量 i 进行存储 console.log(&#x27;i is &#x27; + i); &#125;, 10);&#125; 这里参数未在闭包中存储，运行中 i 会变，最终 i 变成 10，输出 10 次 i is 10。类似的有 setTimeout、setInterval、eval() 等。 问题问：闭包一定需要 return 吗答：不一定，上面所示的场景二也是闭包，就不涉及 return。 参考https://creeperyang.github.io/2015/01/JavaScript-dynamic-scope-vs-static-scope/","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Closure","slug":"Closure","permalink":"http://cencuansen.github.com/tags/Closure/"}]},{"title":"JavaScript apply、bind、call","slug":"web/javascript/JavaScript-apply-bind-call","date":"2023-02-13T12:53:10.000Z","updated":"2023-02-15T11:53:42.717Z","comments":true,"path":"/2023/02/13/web/javascript/JavaScript-apply-bind-call/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/web/javascript/JavaScript-apply-bind-call/","excerpt":"","text":"用途apply、bind、call 用来改变函数内 this 指向 用法123func.apply(this, [arg1, arg2 [,...]])func.bind(this, arg1, arg2 [,...])func.call(this, arg1, arg2 [,...]) 区别 分类 说明 apply 参数数组形式传，并调用对应函数 bind 参数一个一个传，返回一个函数 call 参数一个一个传，并调用对应函数 问题问：一个方法连续 bind 多次，结果如何？答：只有第一次 bind 有效果。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"http://cencuansen.github.com/tags/Function/"}]},{"title":"JavaScript 防抖和节流","slug":"web/javascript/JavaScript-debouncing-and-throttling","date":"2023-02-13T12:35:59.000Z","updated":"2023-02-15T11:53:42.718Z","comments":true,"path":"/2023/02/13/web/javascript/JavaScript-debouncing-and-throttling/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/web/javascript/JavaScript-debouncing-and-throttling/","excerpt":"","text":"意义节流和防抖是 JavaScript 中常用的性能优化手段，用途主要是在高频率的事件触发时，如鼠标移动、滚动事件、输入事件等，避免因频繁调用而导致性能下降。 应用页面滚动时需要请求数据，可以使用节流限制请求频率。验证用户输入是否合法，此时可以使用防抖避免频繁验证。 节流节流（throttling）是指在一段时间内，只让一个函数有限次执行。它通常用来限制函数在一段时间内的最大调用次数，从而防止对性能造成过大的影响。 1234567891011function throttle(fn, interval) &#123; let canRun = true; return function () &#123; if (!canRun) return; canRun = false; setTimeout(() =&gt; &#123; fn.apply(this, arguments); canRun = true; &#125;, interval); &#125;;&#125; 防抖防抖（debouncing）是指在一段时间内，等待事件停止触发后才执行一次函数。它通常用来限制事件触发的频率，从而防止对性能造成过大的影响。 123456789function debounce(fn, interval) &#123; let timeout; return function () &#123; clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, interval); &#125;;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Closure","slug":"Closure","permalink":"http://cencuansen.github.com/tags/Closure/"},{"name":"Performance Optimization","slug":"Performance-Optimization","permalink":"http://cencuansen.github.com/tags/Performance-Optimization/"}]},{"title":"JavaScript 函数","slug":"web/javascript/JavaScript-function","date":"2023-02-13T12:00:45.000Z","updated":"2023-02-15T11:53:42.720Z","comments":true,"path":"/2023/02/13/web/javascript/JavaScript-function/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/web/javascript/JavaScript-function/","excerpt":"","text":"函数定义一般形式1function functionName(parameters) &#123; &#125; 表达式形式1var functionName = function (parameters) &#123; &#125;; 箭头函数形式1(parameters) =&gt; &#123; &#125; 提升（Hoisting）提升特性让函数可以在声明之前调用，使用表达式定义函数时，无法提升。 12myFunction(5);function myFunction(y) &#123; return y * y; &#125; 自调用函数12(function()&#123; &#125;)();(()=&gt;&#123; &#125;)(); 箭头函数特点 不能做构造函数，不能 new 没有 arguments，可用剩余参数代替 没有自己的 this，this 取决于箭头函数所在上下文 apply、bind、call 无法影响 this 指向 没有原型属性 不能作为 Generator 函数，不能使用 yield","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"http://cencuansen.github.com/tags/Function/"}]},{"title":"JavaScript this","slug":"web/javascript/JavaScript-this","date":"2023-02-13T11:54:25.000Z","updated":"2023-02-15T11:53:42.721Z","comments":true,"path":"/2023/02/13/web/javascript/JavaScript-this/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/web/javascript/JavaScript-this/","excerpt":"","text":"普通函数普通函数中的 this 是根据运行时上下文动态确定的，this 指向函数运行时所在上下文。 123456let obj = &#123; name: &quot;san&quot;, func: function () &#123; console.log(`name is $&#123;this.name&#125;`); // name is san &#125;&#125;; 箭头函数箭头函数的中 this 在非运行期间就确定了，箭头函数的 this 和外层函数的 this 一致。 1234567891011let name = &#x27;win&#x27;;let obj = &#123; name: &#x27;san&#x27;, funcA: function () &#123; (() =&gt; console.log(`name is $&#123;this.name&#125;`))(); // name is san &#125;, funcB: () =&gt; &#123; // 这里箭头函数是 obj 下定义的，外层没有函数包裹，就会找到最外层的 window 对象上 console.log(`name is $&#123;this.name&#125;`); // name is win &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"http://cencuansen.github.com/tags/Function/"}]},{"title":"JavaScript 事件循环","slug":"web/javascript/JavaScript-event-loop","date":"2023-02-13T08:30:17.000Z","updated":"2023-02-15T11:53:42.719Z","comments":true,"path":"/2023/02/13/web/javascript/JavaScript-event-loop/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/web/javascript/JavaScript-event-loop/","excerpt":"","text":"关键词宏任务 &amp; 微任务 意义让 JavaScript 在单线程环境中处理异步操作，不阻塞主线程，保证程序的流畅性，如：用户输入、网络请求、动画等。 细分宏任务：IO、setTimeout、setInterval；微任务：Promise、process.nextTick、MutationObserver； 浏览器环境 同步代码 一个宏任务 全部微任务 + 新产生的微任务 一个宏任务 全部微任务 + 新产生的微任务 … Node.js 环境 阶段 说明 timers 这个阶段执行 timer(setTimeout、setInterval) 的回调 I&#x2F;O callbacks 处理一些上一轮循环中的少数未执行的 I&#x2F;O 回调 idle, prepare 仅 node 内部使用 poll 重要且复杂的阶段，几乎所有 I&#x2F;O 相关的回调，都在这个阶段执行 check 执行 setImmediate() 的回调 close callbacks 执行 socket 的 close 事件回调 环境差异 浏览器中，微任务在宏任务之后执行； Node.js 中，微任务在各阶段之间执行：一个阶段执行完毕，就去执行微任务。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Event Loop","slug":"Event-Loop","permalink":"http://cencuansen.github.com/tags/Event-Loop/"}]},{"title":"ECMAScript 版本与特性","slug":"web/javascript/ECMAScript-features","date":"2023-02-13T06:44:00.000Z","updated":"2023-02-15T11:53:42.717Z","comments":true,"path":"/2023/02/13/web/javascript/ECMAScript-features/","link":"","permalink":"http://cencuansen.github.com/2023/02/13/web/javascript/ECMAScript-features/","excerpt":"","text":"ES6&#x2F;ES2015 类 Set Map Proxy 模块化 Promise 箭头函数 解构赋值 模板字符串 展开操作符 let 与 const 对象属性简写 函数参数默认值 ES7&#x2F;ES2016 指数运算符(**) Array.prototype.includes() ES8&#x2F;ES2017 async &amp; await Object.values() Object.entries() padStart() &amp; padEnd() 函数参数列表结尾允许逗号 Object.getOwnPropertyDescriptors() ShareArrayBuffer &amp; Atomics 共享内存读写 ES9&#x2F;ES2018 异步迭代 Promise.finally() Rest &amp; Spread 属性 正则表达式 dotAll 模式 正则表达式 Unicode 转义 非转义序列的模板字符串 正则表达式反向断言(lookbehind) 正则表达式命名捕获组(Regular ExpressionNamed Capture Groups) ES10&#x2F;ES2019 可选的 catch 参数 Object.fromEntries() JSON.stringify() 优化 私有的实例方法和访问器 Symbol.prototype.description Array.flat() &amp; Array.flatMap() Array.Sort 中 QuickSort 换成 TimSort String.trimStart() &amp; String.trimEnd() Function.toString() 会保留空格、换行、注释等 ES11&#x2F;ES2020 BigInt import() globalThis nullish: ?? for-in 顺序标准化 String.matchAll() optional chaining: ? ES12&#x2F;ES2021 WeakRef 数字分隔符 Promise.any() ??=, &amp;&amp;=, ||= AggregateError String.replaceAll() FinalizationRegistry 优化 Array.prototype.sort ES13&#x2F;ES2022 top-level await Object.hasOwn public &amp; private(#fieldname) 成员修饰符","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"Features","slug":"Features","permalink":"http://cencuansen.github.com/tags/Features/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"http://cencuansen.github.com/tags/ECMAScript/"}]},{"title":"JavaScript 数据类型","slug":"web/javascript/JavaScript-data-types","date":"2023-02-08T05:52:29.000Z","updated":"2023-02-15T11:53:42.718Z","comments":true,"path":"/2023/02/08/web/javascript/JavaScript-data-types/","link":"","permalink":"http://cencuansen.github.com/2023/02/08/web/javascript/JavaScript-data-types/","excerpt":"","text":"JavaScript 中： 数据类型：number、string、boolean、null、undefined、symbol、bigint、object 基本数据类型：number、string、boolean、null、undefined、symbol、bigint 引用数据类型：object 基本数据类型的特性是值无法修改，比如：修改字符串会得到一个新的字符串。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Data Types","slug":"Data-Types","permalink":"http://cencuansen.github.com/tags/Data-Types/"}]}],"categories":[{"name":"CLR","slug":"CLR","permalink":"http://cencuansen.github.com/categories/CLR/"},{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/categories/CSharp/"},{"name":"HTML","slug":"HTML","permalink":"http://cencuansen.github.com/categories/HTML/"},{"name":"Web","slug":"Web","permalink":"http://cencuansen.github.com/categories/Web/"},{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/categories/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/categories/JavaScript/"}],"tags":[{"name":"CLR","slug":"CLR","permalink":"http://cencuansen.github.com/tags/CLR/"},{"name":"CSharp","slug":"CSharp","permalink":"http://cencuansen.github.com/tags/CSharp/"},{"name":"Thread Synchronization","slug":"Thread-Synchronization","permalink":"http://cencuansen.github.com/tags/Thread-Synchronization/"},{"name":"LINQ","slug":"LINQ","permalink":"http://cencuansen.github.com/tags/LINQ/"},{"name":"Asynchronous","slug":"Asynchronous","permalink":"http://cencuansen.github.com/tags/Asynchronous/"},{"name":"Synchronous","slug":"Synchronous","permalink":"http://cencuansen.github.com/tags/Synchronous/"},{"name":"Task","slug":"Task","permalink":"http://cencuansen.github.com/tags/Task/"},{"name":"async/await","slug":"async-await","permalink":"http://cencuansen.github.com/tags/async-await/"},{"name":"Delegate","slug":"Delegate","permalink":"http://cencuansen.github.com/tags/Delegate/"},{"name":"Event","slug":"Event","permalink":"http://cencuansen.github.com/tags/Event/"},{"name":"Dispose","slug":"Dispose","permalink":"http://cencuansen.github.com/tags/Dispose/"},{"name":".NET","slug":"NET","permalink":"http://cencuansen.github.com/tags/NET/"},{"name":"Features","slug":"Features","permalink":"http://cencuansen.github.com/tags/Features/"},{"name":"HTML","slug":"HTML","permalink":"http://cencuansen.github.com/tags/HTML/"},{"name":"Web","slug":"Web","permalink":"http://cencuansen.github.com/tags/Web/"},{"name":"Request","slug":"Request","permalink":"http://cencuansen.github.com/tags/Request/"},{"name":"Dom","slug":"Dom","permalink":"http://cencuansen.github.com/tags/Dom/"},{"name":"Dom Parsing","slug":"Dom-Parsing","permalink":"http://cencuansen.github.com/tags/Dom-Parsing/"},{"name":"Dom Rendering","slug":"Dom-Rendering","permalink":"http://cencuansen.github.com/tags/Dom-Rendering/"},{"name":"BFC","slug":"BFC","permalink":"http://cencuansen.github.com/tags/BFC/"},{"name":"CSS","slug":"CSS","permalink":"http://cencuansen.github.com/tags/CSS/"},{"name":"transform","slug":"transform","permalink":"http://cencuansen.github.com/tags/transform/"},{"name":"transition","slug":"transition","permalink":"http://cencuansen.github.com/tags/transition/"},{"name":"animation","slug":"animation","permalink":"http://cencuansen.github.com/tags/animation/"},{"name":"Selector","slug":"Selector","permalink":"http://cencuansen.github.com/tags/Selector/"},{"name":"CSS Tricks","slug":"CSS-Tricks","permalink":"http://cencuansen.github.com/tags/CSS-Tricks/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://cencuansen.github.com/tags/JavaScript/"},{"name":"Deep Clone","slug":"Deep-Clone","permalink":"http://cencuansen.github.com/tags/Deep-Clone/"},{"name":"Module","slug":"Module","permalink":"http://cencuansen.github.com/tags/Module/"},{"name":"Inherit","slug":"Inherit","permalink":"http://cencuansen.github.com/tags/Inherit/"},{"name":"Function","slug":"Function","permalink":"http://cencuansen.github.com/tags/Function/"},{"name":"Closure","slug":"Closure","permalink":"http://cencuansen.github.com/tags/Closure/"},{"name":"Performance Optimization","slug":"Performance-Optimization","permalink":"http://cencuansen.github.com/tags/Performance-Optimization/"},{"name":"Event Loop","slug":"Event-Loop","permalink":"http://cencuansen.github.com/tags/Event-Loop/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"http://cencuansen.github.com/tags/ECMAScript/"},{"name":"Data Types","slug":"Data-Types","permalink":"http://cencuansen.github.com/tags/Data-Types/"}]}