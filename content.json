{"meta":{"title":"SanHuo","subtitle":"纤凝翠薇巅，扶光入沧渊，扶摇惊砂起，山弄望舒远","description":"SanHuo的全栈藏经阁","author":"SanHuo","url":"https://chengshen.me","root":"/"},"pages":[{"title":"关于","date":"2023-02-13T11:13:06.775Z","updated":"2023-02-13T11:13:06.775Z","comments":false,"path":"about/index.html","permalink":"https://chengshen.me/about/","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2023-02-13T11:13:06.776Z","updated":"2023-02-13T11:13:06.776Z","comments":false,"path":"books/index.html","permalink":"https://chengshen.me/books/","excerpt":"","text":""},{"title":"分类","date":"2023-02-13T11:13:06.776Z","updated":"2023-02-13T11:13:06.776Z","comments":false,"path":"categories/index.html","permalink":"https://chengshen.me/categories/","excerpt":"","text":""},{"title":"category","date":"2023-02-13T06:19:11.000Z","updated":"2023-02-13T11:13:06.776Z","comments":true,"path":"category/index.html","permalink":"https://chengshen.me/category/","excerpt":"","text":""},{"title":"Repositories","date":"2023-02-13T11:13:06.776Z","updated":"2023-02-13T11:13:06.776Z","comments":false,"path":"repository/index.html","permalink":"https://chengshen.me/repository/","excerpt":"","text":""},{"title":"标签","date":"2023-02-13T11:13:06.777Z","updated":"2023-02-13T11:13:06.777Z","comments":false,"path":"tags/index.html","permalink":"https://chengshen.me/tags/","excerpt":"","text":""},{"title":"tag","date":"2023-02-13T06:19:03.000Z","updated":"2023-02-13T11:13:06.777Z","comments":true,"path":"tag/index.html","permalink":"https://chengshen.me/tag/","excerpt":"","text":""}],"posts":[{"title":"MySQL 慢查询排查","slug":"database/MySQL-slow-query-troubleshooting","date":"2023-02-16T09:04:39.000Z","updated":"2023-02-16T11:26:27.668Z","comments":true,"path":"/database/MySQL-slow-query-troubleshooting.html","link":"","permalink":"https://chengshen.me/database/MySQL-slow-query-troubleshooting","excerpt":"","text":"排查思路 查看“慢查询日志”找慢 SQL explain“执行计划”查询 profile 执行耗时分析 Optimizer Trace 慢查询日志该功能默认是关闭的。 12345678-- 查看慢查询日志功能是否开启，默认 OFFshow variables like &#x27;slow_query_log%&#x27;;-- 查询超时多久的查询才被记录日志show variables like &#x27;long_query_time&#x27;;-- 查看日志输出模式 FILE、TABLEshow variables LIKE &#x27;%log_output%&#x27;; 用配置开启慢查询日志，持久性。 12345678910111213[mysqld]# 开启慢查询日志slow_query_log = ON# 慢查询日志文件位置slow_query_log_file = dir\\filename# 大于 3 秒就记录日志long_query_time = 3# 将未使用索引的查询记录日志log_queries_not_using_indexes = ON 用命令开启慢查询日志，临时性 123SET GLOBAL slow_query_log=ON;SET GLOBAL long_query_time=3;SET GLOBAL slow_query_log_file=dir\\filename; 查看记录的慢查询日志 1SELECT * FROM mysql.slow_log; 执行计划执行计划是模拟执行 SQL 查询，来查看执行策略。 1explain select * from &#x27;stu&#x27; where gender=1; 执行耗时分析profile 根据最近执行的 SQL，显示执行耗时情况。 12select * from &#x27;stu&#x27; where gender=1;show profiles; 12select * from &#x27;stu&#x27; where gender=1;show profiles; Optimizer Traceoptimizer trace 跟踪 SQL 语句解析优化执行过程。 123set optimizer_trace=&#x27;enabled=on&#x27;;select * from &#x27;stu&#x27; where gender=1;select * from information_schema.optimizer_trace;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/tags/MySQL/"},{"name":"Slow Query","slug":"Slow-Query","permalink":"https://chengshen.me/tags/Slow-Query/"}]},{"title":"MySQL MVCC","slug":"database/MySQL-MVCC","date":"2023-02-16T09:02:31.000Z","updated":"2023-02-16T12:59:00.795Z","comments":true,"path":"/database/MySQL-MVCC.html","link":"","permalink":"https://chengshen.me/database/MySQL-MVCC","excerpt":"","text":"概念多版本并发控制(Multiversion Concurrency Control)，通过保存数据在某时刻的快照来实现并发控制，不管事务执行多长时间，事务内部看到的数据不受其它事务影响。InnoDB 用 Undo Log 保存数据的多个版本。 对比普通锁，只能串行执行；读写锁，可以实现读读并发；多版本并发控制，可以实现读写并发。 隔离级别要求MVCC 要求是已提交读或可重复读。未提交读总是读取最新的数据行，串行化会对读取的行加锁。 隐藏列 DB_ROW_ID，隐藏的行 ID，用来生成默认聚簇索引； DB_TRX_ID，事务 ID； DB_ROLL_PTR，回滚指针，指向行数据的 Undo Log； 事务 ID每开启一个事务，我们都会从数据库中获得一个事务 ID（事务版本号），这个事务 ID 是自增长的。 SELECT 事务 ID 早于当前事务 ID 的数据，确保数据已经存在或当前事务自身插入或者修改的； 删除版本未定义或大于当前事务 ID，确保在事务开始之前未被删除。 INSERT数据的事务 ID 列保存当前事务 ID。 DELETE数据的删除标识更新为当前事务 ID，删除被视为更新，行中的一个特殊位用来标记。 UPDATE插入新记录，数据的事务 ID 列保存当前事务 ID，原数据的删除标识更新为当前事务 ID。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/tags/MySQL/"},{"name":"MVCC","slug":"MVCC","permalink":"https://chengshen.me/tags/MVCC/"}]},{"title":"MySQL 存储过程","slug":"database/MySQL-procedure","date":"2023-02-16T08:56:23.000Z","updated":"2023-02-16T11:26:27.668Z","comments":true,"path":"/database/MySQL-procedure.html","link":"","permalink":"https://chengshen.me/database/MySQL-procedure","excerpt":"","text":"存储过程：SQL 语句集合。 好处： 在创建时进行编译，执行不再重新编译；一般 SQL 执行一次编译一次。 将此复杂操作用存储过程封装起来。 存储过程可以重复使用。 坏处： 不易调试。 可移植性差。 示例1234567DROP PROCEDURE IF EXISTS delete_data;DELIMITER $$CREATE PROCEDURE delete_data(IN idX INTEGER)BEGINDELETE FROM `source` WHERE id = idX;END$$DELIMITER ; 其他说法一存储过程没有版本控制，版本迭代的时候要更新很麻烦。存储过程如果和外部程序结合起来用，更新的时候很难无感升级，可能需要停服。存储过程不利于将来分库分表。存储过程的功能不一定够强大，业务扩展之后可能会发现无法继续用存储过程实现了。存储过程可能无法和许多中间件、ORM 库一起使用。某些特殊的兼容 MySQL 的实现可能根本就不支持存储过程，那就更不用说了。这也不绝对，在微软的时候就有项目是反过来的，所有业务都需要用存储过程写在 SQLServer 里面，查询全写成视图，业务代码只允许使用视图和存储过程，只要 SELECT 和 EXECUTE 权限就够了；修改业务只需要登服务器改存储过程。这属于思路不同。 其他说法二任何技术都要分使用场景，阿里这种互联网高并发的场景，很多数据都是分库分表的，而且要求高度可扩展，原则是对 db 的保护做到最大化，能减少 db 压力的就减少 db 压力，尽量把运算逻辑拉到代码里面。存储过程的优点在于封装性好，直接让 db 进行运算，但是缺点在于难以维护，而且大大增大 db 压力。所以开发过程中禁止使用存储过程也是阿里多年经验积累出来的。 存储过程几个优点存储过程消除不必要的网络 IO，所有事务型请求时延控制在 1ms 内，极大地提高了系统性能。存储过程在在数据库和后端应用之间提供了一个额外的接口层，当底层数据库发生模式变更时，可以对上层应用保持透明;提供了巨大的灵活性，并降低了系统复杂性。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/tags/MySQL/"},{"name":"Procedure","slug":"Procedure","permalink":"https://chengshen.me/tags/Procedure/"}]},{"title":"MySQL 执行计划","slug":"database/MySQL-explain","date":"2023-02-16T08:45:55.000Z","updated":"2023-02-16T11:26:27.667Z","comments":true,"path":"/database/MySQL-explain.html","link":"","permalink":"https://chengshen.me/database/MySQL-explain","excerpt":"","text":"使用explain &lt;sql 语句&gt;，模拟 MySQL 优化器执行 SQL，用来分析 SELECT 语句执行效率。 组成1id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | extra 说明 id：从大到小顺序执行，相等值的从上到下顺序执行，null 值的最后执行。 select_type： simple：表示不需要 union 操作或者不包含子查询的简单 select 查询。有连接查询时，外层的查询为 simple，且只有一个。 primary：一个需要 union 操作或者含有子查询的 select，位于最外层的单位查询的 select_type 即为 primary。且只有一个。 union：union 连接的两个 select 查询，第一个查询是 dervied 派生表，除了第一个表外，第二个以后的表 select_type 都是 union。 dependent union：与 union 一样，出现在 union 或 union all 语句中，但是这个查询要受到外部查询的影响。 union result：包含 union 的结果集，在 union 和 union all 语句中，因为它不需要参与查询，所以 id 字段为 null。 subquery：除了 from 字句中包含的子查询外，其他地方出现的子查询都可能是 subquery。 dependent subquery：与 dependent union 类似，表示这个 subquery 的查询要受到外部表查询的影响。 derived：from 字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套 select。 type：null &gt; system &gt; const &gt; eq_ref &gt; ref &gt; ref_or_null &gt; index_merge &gt; range &gt; index &gt; all，一般来说，得保证查询至少达到 range 级别，最好能达到 ref。 null MySQL 在优化阶段分解查询语句，在执行阶段不再需要访问表或索引 1explain select min(id) from &lt;table name&gt;; system 表中只有一行记录（等于系统表），const 类型的特例。 const 通过索引一次命中，匹配一行数据，常见于主键索引或唯一索引。比如：where id&#x3D;1 eq_ref 唯一索引扫描，对于每个索引键，表中只有一条记录匹配，常见于主键索引或唯一索引。 ref 非唯一索引扫描，返回匹配的所有结果。 range 检索给定范围的行。 index 遍历索引树。 all 全表扫描。 extra：using filesort，using index，using temporary，using where using filesort，mysql 对结果集合进行外部排序，说明没有通过索引顺序达到排序效果，需要优化。 using index，覆盖索引，说明索引树中就能找到所需要的数据，避免了回表，性能不错。 using temporary，使用了临时表，一般出现于排序，分组，多表 join 的情况下，需要优化。 using where，使用了 where 过滤，性能较高。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/tags/MySQL/"},{"name":"Explain","slug":"Explain","permalink":"https://chengshen.me/tags/Explain/"}]},{"title":"MySQL 隔离级别","slug":"database/MySQL-isolation-level","date":"2023-02-16T08:40:42.000Z","updated":"2023-02-16T11:26:27.667Z","comments":true,"path":"/database/MySQL-isolation-level.html","link":"","permalink":"https://chengshen.me/database/MySQL-isolation-level","excerpt":"","text":"隔离级别读未提交、读已提交、可重复读、串行化。 问题 脏读：A 事务读取到 B 事务正在修改还未提交的数据。 不可重复读：A 事务查询两次数据结果不一致，是因为 B 事务在 A 第一次查询后对数据做了修改。 幻读：A 事务条件匹配到若干行，B 事务进行了插入或删除，事务 A 再查询的结果与上次不一致。 脏读 不可重复读 幻读 读未提交 存在 存在 存在 读已提交 无 存在 存在 可重复读 无 无 存在 串行化 无 无 无","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/tags/MySQL/"},{"name":"Isolation Level","slug":"Isolation-Level","permalink":"https://chengshen.me/tags/Isolation-Level/"}]},{"title":"MySQL binlog","slug":"database/MySQL-binlog","date":"2023-02-16T08:36:09.000Z","updated":"2023-02-16T11:26:27.666Z","comments":true,"path":"/database/MySQL-binlog.html","link":"","permalink":"https://chengshen.me/database/MySQL-binlog","excerpt":"","text":"概述binlog 是 MySQLSever 层维护的一种二进制日志，与 InnoDB 引擎中的 redo log&#x2F;undo log 是完全不同的日志；其主要是用来记录对 MySQL 数据更新或潜在发生更新的 SQL 语句，并以事件的形式保存在磁盘中； 应用场景 MySQL 主从复制：MySQL Replication 在 Master 端开启 binlog，Master 把它的二进制日志传递给 Slaves 来达到 Master-Slave 数据一致的目的； 数据恢复：通过使用 mysqlbinlog 工具来使恢复数据； 配置和查看查询 12345678910show variables like &#x27;%log_bin%&#x27;;-- 查看 binlog 文件列表show binary logs;-- 查看 binlog 的状态show master status;-- 清空 binlog 日志文件reset master my.cnf 配置 12345678910[mysqld]# 开启二进制日志，设置 binlog 文件路径log-bin=mysql-bin# 设置server-idserver-id=1# 1073741824 Bytes == 1 GBmax_binlog_size=1073741824 当 binlog 日志写满，或者数据库重启才会产生新文件，也可人为切换生成新文件：flush logs；一个事务不能跨两个文件，因此也可能在 binlog 文件未满的情况下刷新文件； 日志文件格式三种格式：ROW，STATEMENT，MIXED。 修改格式方式 修改 my.cnf 配置文件； set global binlog_format &#x3D; ‘ROW&#x2F;STATEMENT&#x2F;MIXED’； 查看 binglog 格式：show variables like ‘binlog_format’; ROW记录的是行数据变化细节，多。保存记录被修改细节，不记录 sql 语句上下文相关信息。5.1.5 版本的 MySQL 才开始支持。优点： 能非常清晰的记录下每行数据的修改细节，不需要记录上下文相关信息，因此不会发生某些特定情况下的 procedure、function、trigger 的调用触发无法被正确复制的问题，任何情况都可以被复制，且能加快从库重放日志的效率，保证从库数据的一致性；缺点：由于所有的执行的语句在日志中都将以每行记录的修改细节来记录，因此，可能会产生大量的日志内容，干扰内容也较多。比如一条 update 语句，如修改多条记录，则 binlog 中每一条修改都会有记录，这样造成 binlog 日志量会很大，特别是当执行 alter table 之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中，实际等于重建了表。 STATEMENT记录的是会改变数据的 sql 语句，少。修改数据的 sql 都会记录在 binlog 中。优点：不需要记录每一行的变化，减少了 binlog 日志量，节约了 IO，提高了性能。缺点：由于记录的只是执行语句，为了这些语句能在 slave 上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在 slave 得到和在 master 端执行的时候相同的结果。另外 mysql 的复制，像一些特定函数的功能，slave 与 master 要保持一致会有很多相关问题。 MIXEDROW 和 STATEMENT 的结合。 复制复制是 MySQL 最重要的功能之一，MySQL 集群的高可用、负载均衡和读写分离都是基于复制来实现，MySQL 5.6 开始，复制有两种实现方式：binlog、GTID（全局事务标示符）。 主从分类binlog 主从、GTID 主从","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/tags/MySQL/"},{"name":"binlog","slug":"binlog","permalink":"https://chengshen.me/tags/binlog/"}]},{"title":"MySQL 事务","slug":"database/MySQL-transaction","date":"2023-02-16T08:34:07.000Z","updated":"2023-02-16T11:26:27.668Z","comments":true,"path":"/database/MySQL-transaction.html","link":"","permalink":"https://chengshen.me/database/MySQL-transaction","excerpt":"","text":"ACID 原子性：事务中包含的各操作要么都做，要么都不做。数据库通过 undo log 和 redo log 实现原子性：事务提交，redo log 写入到数据库，事务回滚，undo log 恢复到先前状态。 一致性：从一个一致性状态变到另一个一致性状态。 隔离性：一个事务的执行不受其它事务干扰。 持久性：一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。 redo log &amp; binlogredo log 属于 innoDB 层面，binlog 属于 MySQL Server 层面；redo log 是物理日志，记录该数据页更新的内容；binlog 是逻辑日志，记录的是更新语句的原始逻辑；redo log 是循环写，日志空间大小固定；binlog 是追加写，写到一定大小会写下一个文件，不覆盖；redo log 作为异常宕机、介质故障后的数据恢复使用；binlog 主从架构恢复数据； Innodb 事务过程 innodb 收到 update 语句后，根据条件去找到数据所在页，将该页缓存到 buffer pool； 执行 update，修改 buffer pool 中数据，也就是内存中数据； 生成 undo log，用于事务回滚； 生成 redo log，存入 log buffer； 如果事务提交，则将 redo log 持久化，后续会有其他机制将 buffer pool 中修改的数据持久化到磁盘； 如果事务回滚，利用 undo log 日志进行回滚； 例子假设有 X、Y 两个数据，值分别为 1，2： 事务开始 记录 X&#x3D;1 到 undo log 修改 X&#x3D;3 记录 X&#x3D;3 到 redo log 记录 Y&#x3D;2 到 undo log 修改 Y&#x3D;4 记录 Y&#x3D;4 到 redo log 将 redo log 写入磁盘 事务提交","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/tags/MySQL/"},{"name":"Transaction","slug":"Transaction","permalink":"https://chengshen.me/tags/Transaction/"}]},{"title":"MySQL 索引","slug":"database/MySQL-Index_","date":"2023-02-16T08:28:02.000Z","updated":"2023-02-16T12:53:19.909Z","comments":true,"path":"/database/MySQL-Index_.html","link":"","permalink":"https://chengshen.me/database/MySQL-Index_","excerpt":"","text":"B 树 &amp; B+树B 树：平衡的多叉查找树，每个节点都包含数据，在任意节点匹配上就返回数据，找不到就返回空指针。 B+树： 关键字全部存储在叶子节点上，且叶子节点本身根据关键字自小而大顺序连接。 非叶子节点可以看成索引部分，节点中仅含有其子树（根节点）中的最大（或最小）关键字。 有 n 棵子树的节点含有 n 个关键字（也有认为是 n-1 个关键字）。B+树的查找过程，在非叶子节点上的关键字等于给定值，并不终止，而是继续沿着指针直到叶子节点位置。因此在 B+树，不管查找成功与否，每次查找都是走了一条从根到叶子节点的路径。 B+树效率InnoDB 引擎存储数据的时候以页为单位，一页就是一节点。每个节点的默认大小是 16KB，一个指针的大小是 6 个字节，主键占用 8 个字节，一个节点大概有 (161024)&#x2F;(6+8)&#x3D;1170 个指针，当表中一条记录 1KB，单个叶子节点可以存储 16 条数据，即树高度为 2 时能关联 117016&#x3D;18720 条数据，当高度为 3，能关联 1170117016&#x3D;21902400 条数据。 索引索引是有结构的数据，这些数据结构以某种方式引用（指向）数据，MySQL 的索引使用 B+树的数据结构。 主键索引InnoDB 叶子节点存行数据；MyISAM 叶子节点是数据的地址指针。 普通索引InnoDB 叶子节点存主键值；MyISAM 叶子节点是数据的地址指针。普通索引查询到叶子节点主键值，用主键去主键索引查数据，这就是回表查询。 聚集索引索引顺序和数据的顺序一致，如果索引相邻，对应数据也相邻存放。InnoDB 主键索引就是聚集索引，聚集索引将数据与索引放一起，索引结构的叶子结点保存了行数据，聚集索引有且仅有一个。 有主键，主键索引就是聚集索引； 无主键，第一个唯一索引（UNIQUE）为聚集索引； 无主键、唯一键，InnoDB 会生成一个隐式主键（rowid）作为聚集索引列。 索引查询过程： where id &#x3D; 14：主键索引树中找到对应叶子节点，获得行数据； where Name &#x3D; ‘xx’： 辅助索引树中检索 Name，到达其叶子节点获取对应的主键。 再用主键在主键索引树找到对应叶子节点，获得行数据。 非聚集索引索引逻辑顺序和磁盘中数据的物理顺序不一致。 覆盖索引查数据时，select 的列刚好是复合索引中涉及的字段，这样能直接返回数据，避免回表，extra 中 Using Index 说明使用了覆盖索引。 最左匹配原则覆盖索引要求查询字段的顺序与复合索引从左到右的顺序一致才行。 索引条件下推当存在索引列条件判断时，将条件判断从 MySQL 服务器向下传递给存储引擎，减少 IO 次数，extra 中 Using index condition 说明使用了索引条件下推。 创建索引普通索引 12345678910111213141516171819-- 将 user 表 user_name 列设为索引create index idx_user_name on user(user_name);-- 创建email列的索引，索引可以截取length长度，只使用这一列的前几个字符create index idx_email on user(email(5));-- 该表方式创建索引alter table user add index idx_user_name(user_name);-- 建表时创建索引create table user ( id int, user_name varchar(20), gender varchar(1), index idx_user_name (name));-- 删除索引drop index idx_user_name on user; 唯一索引 1create unique index idx_user_name on user(user_name); 复合索引 1create index idx_user_composite_index on user(user_name, email(7)); 索引失效 用 OR 查询； 违背最左匹配原则； like 以 % 开头； 发生类型转换； where 中索引列有运算； where 中索引列使用了函数； 如果 MySQL 觉得全表扫描更快时（数据少）; OR 如果条件中有 OR，只要其中一个条件没有索引，其他字段有索引也不会使用。 如果条件中的字段都有索引，但是 OR 多个字段都需要全表扫描，因此还是会 走全表扫描 或者 全索引扫描；也就是说如果其他字段不符最左前缀原则，但是都是覆盖索引的值，因此走一次全索引扫描 案例 where c1&#x3D;1 OR c2&#x3D;2 改成 where c1&#x3D;1 UNION ALL where c2&#x3D;2 where id&#x3D;1 OR id&#x3D;2 改成 where id in (1,2)","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/tags/MySQL/"},{"name":"Database Index","slug":"Database-Index","permalink":"https://chengshen.me/tags/Database-Index/"}]},{"title":"MySQL 数据库引擎","slug":"database/MySQL-database-engine","date":"2023-02-16T08:25:21.000Z","updated":"2023-02-16T11:26:27.666Z","comments":true,"path":"/database/MySQL-database-engine.html","link":"","permalink":"https://chengshen.me/database/MySQL-database-engine","excerpt":"","text":"分类 MyISAM InnoDB Memory Archive Federated 查使用的引擎类型 1show variables like &#x27;default_storage_engine&#x27;; 对比MySQL 默认使用 innodb。innodb：支持事务，支持外键，聚集索引，锁最小行锁；myisam：不支持事务，不支持外键，非聚集索引，锁最小表锁；myisam 使用的场景：个人博客等文本内容为主的系统；","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/tags/MySQL/"},{"name":"Database Engine","slug":"Database-Engine","permalink":"https://chengshen.me/tags/Database-Engine/"}]},{"title":"EntityFramework ADO.NET","slug":"csharp/EntityFramework-ado-net-basic-concepts","date":"2023-02-16T08:12:29.000Z","updated":"2023-02-16T11:26:27.662Z","comments":true,"path":"/csharp/EntityFramework-ado-net-basic-concepts.html","link":"","permalink":"https://chengshen.me/csharp/EntityFramework-ado-net-basic-concepts","excerpt":"","text":"用于进行数据库访问的技术。 五个对象： Connection Command DataAdapter DataSet DataReader 使用示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using System.Data.SqlClient;private const string connectionString = &quot;&quot;;// 增删改public static int update(string sql)&#123; using SqlConnection connection = new SqlConnection(connectionString); connection.Open(); using SqlCommand cmd = new SqlCommand(sql, connection); // ExecuteNonQuery 用于执行增删改语句 int result = cmd.ExecuteNonQuery(); return result;&#125;// 查询单条数据public static int query(string sql)&#123; using SqlConnection connection = new SqlConnection(connectionString); connection.Open(); SqlCommand cmd = new SqlCommand(sql, connection); // ExecuteScalar 用于查询返回结果中的首行首列数据 int result = cmd.ExecuteScalar(); return result;&#125;// 查询数据public static void query(string sql)&#123; using SqlConnection connection = new SqlConnection(connectionString); connection.Open(); SqlCommand cmd = new SqlCommand(sql, connection); // ExecuteReader 读取的数据是行流，会跟数据库保存连接去读取数据，适合数据量小的情况 using SqlDataReader dataReader = cmd.ExecuteReader(); while (dataReader.Read()) &#123; // 一次while循环读一行数据 // 获得第0列数据 var col0 = dataReader.GetString(0); // 获得第1列数据 var col1 = Convert.ToInt32(dataReader[&quot;name&quot;]); // 获得第2列数据 var col2 = dataReader.GetString(2); &#125;&#125;// 查询数据public static DataTable query(string sql)&#123; using SqlConnection connection = new SqlConnection(connectionString); SqlDataAdapter adapter = new SqlDataAdapter(sql, connection); // DataSet 中含可以有多个 DataTable // DataSet dataSet = new DataSet(); DataTable dtable = new DataTable(); adapter.Fill(dtable); return dtable;&#125; 参数化查询防 SQL 注入12345678910111213141516171819202122232425using SqlConnection connection = new SqlConnection(connectionString);connection.Open();// @符号是必须的string querySql = &quot;select * from students where name=@name and age=@age and class=@class;&quot;;SqlCommand command = new SqlCommand(querySql, connection);// 单条参数处理SqlParameter sqlParameter1 = new ();sqlParameter.ParameterName = &quot;name&quot;;sqlParameter.Size = 64;sqlParameter.SqlDbType = SqlDbType.VarChar;sqlParameter.Value = &quot;李明&quot;;command.Parameters.Add(sqlParameter1);// 批量参数处理SqlParameter[] parameters =&#123; new SqlParameter(&quot;age&quot;, SqlDbType.Int), new SqlParameter(&quot;class&quot;, SqlDbType.VarChar),&#125;parameters[0].Value = 18;parameters[1].Value = &quot;精英班&quot;;command.Parameters.AddRange(parameters);int result = Convert.ToInt32(command.ExecuteScalar());","categories":[{"name":"EntityFramework","slug":"EntityFramework","permalink":"https://chengshen.me/categories/EntityFramework/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":"EntityFramework","slug":"EntityFramework","permalink":"https://chengshen.me/tags/EntityFramework/"},{"name":"ADO.NET","slug":"ADO-NET","permalink":"https://chengshen.me/tags/ADO-NET/"}]},{"title":"EntityFramework 拦截器","slug":"csharp/EntityFramework-interceptor","date":"2023-02-16T08:03:41.000Z","updated":"2023-02-16T11:26:27.663Z","comments":true,"path":"/csharp/EntityFramework-interceptor.html","link":"","permalink":"https://chengshen.me/csharp/EntityFramework-interceptor","excerpt":"","text":"用途改 SQL，缓存结果，审计日志，自动事务提交等。 类型 IDbCommandInterceptor：创建、执行、失败、释放 IDbConnectionInterceptor：打开和关闭连接、连接失败 IDbTransactionInterceptor：创建事务、使用事务、提交事务、回滚事务、创建和使用保存点、事务失败 ISaveChangesInterceptor：提交变更 基类 DbCommandInterceptor、 DbConnectionInterceptor、DbTransactionInterceptor、SaveChangesInterceptor 包含对应接口中每个方法的无操作实现，以避免实现不需要的方法。 DbCommandInterceptor在 SQL 发送到数据库之前，对 SQL 进行修改，通常结合 EF Core 查询标记来标记每个需要修改的查询。 1var blogs1 = context.Blogs.TagWith(&quot;Use hint: robust plan&quot;).ToList(); 12345678910111213141516public class TaggedQueryCommandInterceptor : DbCommandInterceptor&#123; public override ValueTask&lt;InterceptionResult&lt;DbDataReader&gt;&gt; ReaderExecutingAsync(DbCommand command, CommandEventData eventData, InterceptionResult&lt;DbDataReader&gt; result, CancellationToken cancellationToken = default) &#123; ManipulateCommand(command); return new ValueTask&lt;InterceptionResult&lt;DbDataReader&gt;&gt;(result); &#125; private static void ManipulateCommand(DbCommand command) &#123; if (command.CommandText.StartsWith(&quot;-- Use hint: robust plan&quot;, StringComparison.Ordinal)) &#123; command.CommandText += &quot; OPTION (ROBUST PLAN)&quot;; &#125; &#125;&#125; 结果 12-- Use hint: robust planSELECT [b].[Id], [b].[Name] FROM [Blogs] AS [b] OPTION (ROBUST PLAN) SaveChangesInterceptor 用于审计 1234567891011121314151617public async ValueTask&lt;InterceptionResult&lt;int&gt;&gt; SavingChangesAsync(DbContextEventData eventData, InterceptionResult&lt;int&gt; result, CancellationToken cancellationToken = default)&#123; _audit = CreateAudit(eventData.Context); using var auditContext = new AuditContext(_connectionString); auditContext.Add(_audit); await auditContext.SaveChangesAsync(); return result;&#125;public InterceptionResult&lt;int&gt; SavingChanges(DbContextEventData eventData, InterceptionResult&lt;int&gt; result)&#123; _audit = CreateAudit(eventData.Context); using var auditContext = new AuditContext(_connectionString); auditContext.Add(_audit); auditContext.SaveChanges(); return result;&#125; 同时重写同步和异步方法可确保在无论是否调用 SaveChanges 或 SaveChangesAsync 的情况下进行审计。 12345678910111213141516171819202122232425262728293031323334353637private static SaveChangesAudit CreateAudit(DbContext context)&#123; context.ChangeTracker.DetectChanges(); var audit = new SaveChangesAudit &#123; AuditId = Guid.NewGuid(), StartTime = DateTime.UtcNow &#125;; foreach (var entry in context.ChangeTracker.Entries()) &#123; var auditMessage = entry.State switch &#123; EntityState.Deleted =&gt; CreateDeletedMessage(entry), EntityState.Modified =&gt; CreateModifiedMessage(entry), EntityState.Added =&gt; CreateAddedMessage(entry), _ =&gt; null &#125;; if (auditMessage != null) &#123; audit.Entities.Add(new EntityAudit &#123; State = entry.State, AuditMessage = auditMessage &#125;); &#125; &#125; return audit; string CreateAddedMessage(EntityEntry entry) =&gt; entry.Properties.Aggregate( $&quot;Inserting &#123;entry.Metadata.DisplayName()&#125; with &quot;, (auditString, property) =&gt; auditString + $&quot;&#123;property.Metadata.Name&#125;: &#x27;&#123;property.CurrentValue&#125;&#x27; &quot;); string CreateModifiedMessage(EntityEntry entry) =&gt; entry.Properties.Where(property =&gt; property.IsModified || property.Metadata.IsPrimaryKey()).Aggregate( $&quot;Updating &#123;entry.Metadata.DisplayName()&#125; with &quot;, (auditString, property) =&gt; auditString + $&quot;&#123;property.Metadata.Name&#125;: &#x27;&#123;property.CurrentValue&#125;&#x27; &quot;); string CreateDeletedMessage(EntityEntry entry) =&gt; entry.Properties.Where(property =&gt; property.Metadata.IsPrimaryKey()).Aggregate( $&quot;Deleting &#123;entry.Metadata.DisplayName()&#125; with &quot;, (auditString, property) =&gt; auditString + $&quot;&#123;property.Metadata.Name&#125;: &#x27;&#123;property.CurrentValue&#125;&#x27; &quot;);&#125; 自动设置实体值，如 CreatedBy，CreatedDT 等 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class MySaveChangesInterceptor : SaveChangesInterceptor&#123; private readonly IAppUser _appUser; public MySaveChangesInterceptor (IAppUser appUser) &#123; _appUser = appUser; &#125; public async ValueTask&lt;InterceptionResult&lt;int&gt;&gt; SavingChangesAsync(DbContextEventData eventData, InterceptionResult&lt;int&gt; result, CancellationToken cancellationToken = default) &#123; foreach (var entry in eventData.Context.ChangeTracker.Entries()) &#123; switch (entry.State) &#123; case EntityState.Added: InterceptAddedOperation(entry); break; case EntityState.Modified: InterceptModifiedOperation(entry); break; case EntityState.Deleted: InterceptDeletedOperation(entry); break; &#125; &#125; return result; &#125; /// &lt;summary&gt; /// 拦截添加操作 /// &lt;/summary&gt; protected virtual void InterceptAddedOperation(EntityEntry entry) &#123; if (entry.Entity is IAuditedCreationEntity) &#123; (entry.Entity as IAuditedCreationEntity).CreatedBy = _appUser?.UserId ?? string.Empty; (entry.Entity as IAuditedCreationEntity).CreatedDT = DateTime.Now; &#125; &#125; /// &lt;summary&gt; /// 拦截修改操作 /// &lt;/summary&gt; protected virtual void InterceptModifiedOperation(EntityEntry entry) &#123; if (entry.Entity is IAuditedUpdateEntity) &#123; (entry.Entity as IAuditedUpdateEntity).ModifiedBy = _appUser?.UserId ?? string.Empty; (entry.Entity as IAuditedUpdateEntity).ModifiedDT = DateTime.Now; &#125; &#125; /// &lt;summary&gt; /// 拦截删除操作 /// &lt;/summary&gt; protected virtual void InterceptDeletedOperation(EntityEntry entry) &#123; &#125;&#125; 注册配置 DbContext 实例，在 DbContext.OnConfiguring 中完成注册。 12345public class ExampleContext : BlogsContext&#123; protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) =&gt; optionsBuilder.AddInterceptors(new TaggedQueryCommandInterceptor());&#125;","categories":[{"name":"EntityFramework","slug":"EntityFramework","permalink":"https://chengshen.me/categories/EntityFramework/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":"EntityFramework","slug":"EntityFramework","permalink":"https://chengshen.me/tags/EntityFramework/"},{"name":"Interceptor","slug":"Interceptor","permalink":"https://chengshen.me/tags/Interceptor/"}]},{"title":"EntityFramework 原生 SQL","slug":"csharp/EntityFramework-raw-sql","date":"2023-02-16T07:55:13.000Z","updated":"2023-02-16T11:26:27.664Z","comments":true,"path":"/csharp/EntityFramework-raw-sql.html","link":"","permalink":"https://chengshen.me/csharp/EntityFramework-raw-sql","excerpt":"","text":"FromSqlFromSql 只能直接在 DbSet 上使用。 不能在任意 LINQ 查询的基础上组合使用它。 1var blogs = context.Blogs.FromSql($&quot;SELECT * FROM dbo.Blogs&quot;).ToList(); FromSql 和 FromSqlInterpolated 方法可以防止 SQL 注入，FromSqlRaw 方法可能易受 SQL 注入攻击。 动态 SQL 和参数123var user = &quot;johndoe&quot;;var sqlString = $&quot;SELECT * FROM dbo.Blogs WHERE Name = &#123;user&#125;&quot;;var blogs = context.Blogs.FromSql(sqlString).ToList(); SqlQuery1var ids = context.Database.SqlQuery&lt;int&gt;($&quot;SELECT [BlogId] FROM [Blogs]&quot;).ToList(); Non-Query SQL非查询 SQL 通常指用于修改数据库中的数据或调用不返回任何结果集的存储过程。 ExecuteSqlEF Core 7.0 之前批量变更，比在查询所有匹配行后使用 SaveChanges 来修改它们要高效得多。 1var rowsModified = context.Database.ExecuteSql($&quot;UPDATE [Blogs] SET [Url] = NULL&quot;); ExecuteDeleteAsyncEF Core 7.0 新特性，借助 LINQ 更方便高效。 1await context.Tags.Where(t =&gt; t.Text.Contains(&quot;.NET&quot;)).ExecuteDeleteAsync(); ExecuteUpdateAsyncEF Core 7.0 新特性，借助 LINQ 更方便高效。 123await context.Blogs.ExecuteUpdateAsync(s =&gt; s.SetProperty(b =&gt; b.Name, b =&gt; $&quot;&#123;b.Name&#125;_new&quot;)) s.SetProperty(b =&gt; b.Author, b =&gt; $&quot;&#123;b.Author&#125;_new&quot;));","categories":[{"name":"EntityFramework","slug":"EntityFramework","permalink":"https://chengshen.me/categories/EntityFramework/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":"EntityFramework","slug":"EntityFramework","permalink":"https://chengshen.me/tags/EntityFramework/"},{"name":"SQL","slug":"SQL","permalink":"https://chengshen.me/tags/SQL/"}]},{"title":"EntityFramework 流式配置接口","slug":"csharp/EntityFramework-fluent-api","date":"2023-02-16T07:51:25.000Z","updated":"2023-02-16T11:26:27.663Z","comments":true,"path":"/csharp/EntityFramework-fluent-api.html","link":"","permalink":"https://chengshen.me/csharp/EntityFramework-fluent-api","excerpt":"","text":"fluent api 使得 ef 能链式配置。 123456789101112131415161718192021222324252627282930313233343536373839public class SchoolDBContext: DbContext&#123; public DbSet&lt;Student&gt; Students &#123; get; set; &#125; public DbSet&lt;Course&gt; Courses &#123; get; set; &#125; public DbSet&lt;StudentCourse&gt; StudentCourses &#123; get; set; &#125; public DbSet&lt;StudentAddress&gt; StudentAddress &#123; get; set; &#125; protected override void OnConfiguring(DbContextOptionsBuilder builder) &#123; &#125; protected override void OnModelCreating(ModelBuilder builder) &#123; // 字段 builder.Entity&lt;Student&gt;().Property(s =&gt; s.Id).HasColumnName(&quot;Id&quot;).HasDefaultValue(0).IsRequired(); // 索引 builder.Entity&lt;Student&gt;().HasIndex(x =&gt; x.Name); // 初始数据（data-seeding） builder.Entity&lt;Student&gt;().HasData(new Student &#123; Id = &quot;0&quot;, Name = &quot;小明&quot;, &#125;); // Student n : 1 Grade builder.Entity&lt;Student&gt;().HasOne&lt;Grade&gt;(s =&gt; s.Grade).WithMany(g =&gt; g.Students).HasForeignKey(s =&gt; s.GradeId); // Student 1 : 1 StudentAddress builder.Entity&lt;Student&gt;().HasOne&lt;StudentAddress&gt;(s =&gt; s.Address).WithOne(ad =&gt; ad.Student).HasForeignKey&lt;StudentAddress&gt;(ad =&gt; ad.StudentId); // n : n // Student 1 : n StudentCourse builder.Entity&lt;StudentCourse&gt;().HasOne&lt;Student&gt;(sc =&gt; sc.Student).WithMany(s =&gt; s.StudentCourses).HasForeignKey(sc =&gt; sc.StudentId); // Course 1 : n StudentCourse builder.Entity&lt;StudentCourse&gt;().HasOne&lt;Course&gt;(sc =&gt; sc.Course).WithMany(s =&gt; s.StudentCourses).HasForeignKey(sc =&gt; sc.CourseId); &#125;&#125;","categories":[{"name":"EntityFramework","slug":"EntityFramework","permalink":"https://chengshen.me/categories/EntityFramework/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":"EntityFramework","slug":"EntityFramework","permalink":"https://chengshen.me/tags/EntityFramework/"},{"name":"Fluent API","slug":"Fluent-API","permalink":"https://chengshen.me/tags/Fluent-API/"}]},{"title":"EntityFramework 复杂查询","slug":"csharp/EntityFramework-complex-query","date":"2023-02-16T07:48:44.000Z","updated":"2023-02-16T11:26:27.662Z","comments":true,"path":"/csharp/EntityFramework-complex-query.html","link":"","permalink":"https://chengshen.me/csharp/EntityFramework-complex-query","excerpt":"","text":"LINQ JoinLINQ Join 对应关系数据库中的 INNER JOIN。 LEFT JOIN1234from c in table0join o in table1 on c.sno equals o.sno into psfrom o in ps.DefaultIfEmpty()select new &#123; c.name, o.number&#125; 生成的 SQL： 123SELECT [t0].[name], [t1].[number] AS [number] FROM [table0] AS [t0]LEFT OUTER JOIN [table1] AS [t1]ON ([t0].[sno]) = [t1].[sno]","categories":[{"name":"EntityFramework","slug":"EntityFramework","permalink":"https://chengshen.me/categories/EntityFramework/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":"EntityFramework","slug":"EntityFramework","permalink":"https://chengshen.me/tags/EntityFramework/"}]},{"title":"EntityFramework 实体状态","slug":"csharp/EntityFramework-entity-state","date":"2023-02-16T07:47:30.000Z","updated":"2023-02-16T11:26:27.663Z","comments":true,"path":"/csharp/EntityFramework-entity-state.html","link":"","permalink":"https://chengshen.me/csharp/EntityFramework-entity-state","excerpt":"","text":"EntityState Added，在上下文中，而且对象是需要添加的状态 Deleted，在上下文中，而且对象是需要删除的状态 Modified，在上下文中，而且对象是需要修改的状态 UnChanged，在上下文中，对象没有任何状态 Detached，没有在上下文中，和 ef 上下文没有关联的状态 new 的新对象属于 Detached 状态；查询出来的对象属于 UnChanged 状态；new 的新对象调用 Attach 方法后对象属于 Unchanged 状态；调用 Add 方法后对象属于 Added 状态；Remove 方法将状态修改为 Deleted；","categories":[{"name":"EntityFramework","slug":"EntityFramework","permalink":"https://chengshen.me/categories/EntityFramework/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":"EntityFramework","slug":"EntityFramework","permalink":"https://chengshen.me/tags/EntityFramework/"}]},{"title":"NETCore .NET中的设计模式","slug":"csharp/NETCore-design-patten-in-NET","date":"2023-02-16T07:31:11.000Z","updated":"2023-02-16T11:26:27.664Z","comments":true,"path":"/csharp/NETCore-design-patten-in-NET.html","link":"","permalink":"https://chengshen.me/csharp/NETCore-design-patten-in-NET","excerpt":"","text":"责任链模式中间件的设计就是责任链模式的应用和变形。每个中间件根据需要处理请求，并且可以根据请求信息自己决定是否传递给下一个中间件。 工厂模式依赖注入的本质就是将对象的创建交给 IOC 容器 来处理，所以其实 IOC 容器本质就是一个工厂，从 IOC 中获取服务实例的过程就是工厂创建对象的过程，只是会根据服务的生命周期来决定是创建新对象还是返回已有对象。 单例模式 Cache DbContext HttpClient LoggerFactory Configuration 享元模式字符串池(string intern) 观察者模式&#x2F;发布订阅模式使用事件(event)进行解耦，外部代码通过订阅事件来解耦，实现对内部状态的观察。 适配器模式ServiceProviderFactory, 使得 .NET Core 可以更方便的集成第三方的依赖注入框架，这里使用了适配器模式。 补充观察者模式 &amp; 发布订阅模式虽然这两种模式在很多情况下非常相似，但是它们还是有一些区别。观察者模式通常用于更加简单的情况，而发布-订阅模式则更加通用，并且可以通过中间件来实现进程间通信。在发布-订阅模式中，发布者和订阅者之间可以有多个中间件，可以将其视为事件的处理管道。","categories":[{"name":"NETCore","slug":"NETCore","permalink":"https://chengshen.me/categories/NETCore/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":"NETCore","slug":"NETCore","permalink":"https://chengshen.me/tags/NETCore/"},{"name":"Design Patten","slug":"Design-Patten","permalink":"https://chengshen.me/tags/Design-Patten/"}]},{"title":"NETCore 身份验证和授权","slug":"csharp/NETCore-oauth-and-oidc","date":"2023-02-16T07:26:45.000Z","updated":"2023-02-16T11:26:27.665Z","comments":true,"path":"/csharp/NETCore-oauth-and-oidc.html","link":"","permalink":"https://chengshen.me/csharp/NETCore-oauth-and-oidc","excerpt":"","text":"定义OAuth 是授权协议（Authorization），不支持身份认证。OpenID Connect（OIDC）是基于 OAuth 的简单身份认证协议。 OAuth 2.0 授权方式 授权码 隐式 密码 客户端凭证 授权码功能最完整、流程最严密，适合通用前后端服务，由客户端的后台服务向授权服务请求 token。 12345用户正在访问网站 A ，A 支持用 QQ 登录。A 网站跳转 QQ 授权页（https://qq.com/oauth/authorize?response_type=code&amp;client_id=CLIENT_ID&amp;redirect_uri=http://a.com/callback&amp;scope=read）。QQ 提供登录页，用户用 QQ 登录，然后 QQ 跳转 A 网站（http://a.com/callback），并携带授权码（code）。A 网站使用授权码，向 QQ 请求 Token（https://qq.com/oauth/token?client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;grant_type=authorization_code&amp;code=AUTHORIZATION_CODE&amp;redirect_uri=http://a.com/callback）。QQ 收到请求，跳转 A 网站（http://a.com/callback），并携带 Token。 密码用户必须高度信任该网站。用户向客户端提供账号密码，客户端向授权服务请求 token。 123用户在 A 网站直接用 B 网站的账号密码进行登录。A 网站带上用户提供的 B 网站的账号密码向 B 网站发起登录请求（https://oauth.b.com/token?grant_type=password&amp;username=USERNAME&amp;password=PASSWORD&amp;client_id=CLIENT_ID）。在 B 网站验证账号密码成功后直接返回 Token，相当于直接响应。 凭证式客户端以自己的名义（不是以用户的名义），用 clientid 和 clientsecret 向授权服务请求 token。这会涉及客户端身份验证（clientid）。 12A 服务使用 clientid 和 clientsecret 向授权服务申请 Token（https://oauth.b.com/token?grant_type=client_credentials&amp;client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET）。授权服务验证通过以后，直接返回 Token。 隐式无后端的服务，如 swagger 服务。客户端用 clientid 直接向授权服务器请求 token，不涉及客户端身份验证。 12swagger 访问授权服务（https://id4.com/oauth/authorize?response_type=token&amp;client_id=CLIENT_ID&amp;redirect_uri=CALLBACK_URL&amp;scope=read）。授权服务访问 CALLBACK_URL 并携带 token（CALLBACK_URL#TOKEN）。","categories":[{"name":"NETCore","slug":"NETCore","permalink":"https://chengshen.me/categories/NETCore/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":"NETCore","slug":"NETCore","permalink":"https://chengshen.me/tags/NETCore/"},{"name":"OAuth","slug":"OAuth","permalink":"https://chengshen.me/tags/OAuth/"},{"name":"OIDC","slug":"OIDC","permalink":"https://chengshen.me/tags/OIDC/"}]},{"title":"NETCore IOC","slug":"csharp/NETCore-IOC","date":"2023-02-16T07:24:52.000Z","updated":"2023-02-16T11:26:27.664Z","comments":true,"path":"/csharp/NETCore-IOC.html","link":"","permalink":"https://chengshen.me/csharp/NETCore-IOC","excerpt":"","text":"生命周期Singleton：实例化一次，然后在整个应用程序中重复使用；Scoped：单个请求中会实例化一次实例，请求中可以重复使用；Transient：每次使用时都会创建新实例； 应用缓存服务、Option 等配置服务注册成 Singleton；一般服务（Service）注册成 Scoped； 常见 IOC 容器ServiceCollection、Autofac、Unity 批量注册服务12345678910111213141516171819202122232425262728/// &lt;summary&gt;/// 根据前缀后缀注册服务/// &lt;/summary&gt;/// &lt;param name=&quot;services&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;assembly&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;postfix&quot;&gt;后缀&lt;/param&gt;/// &lt;param name=&quot;prefix&quot;&gt;前缀&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static IServiceCollection AddBusinessServices(this IServiceCollection services, Assembly assembly, string postfix, string prefix = &quot;&quot;)&#123; var types = assembly?.GetTypes().Where(type =&gt; type.IsClass &amp;&amp; !type.IsAbstract).ToList(); if (!string.IsNullOrWhiteSpace(postfix)) &#123; types = types?.Where(type =&gt; type.Name.EndsWith(postfix, StringComparison.OrdinalIgnoreCase)).ToList(); &#125; if (!string.IsNullOrWhiteSpace(prefix)) &#123; types = types?.Where(type =&gt; type.Name.StartsWith(prefix, StringComparison.OrdinalIgnoreCase)).ToList(); &#125; types?.ForEach(type =&gt; &#123; foreach (var it in type.GetInterfaces()) &#123; services.AddScoped(it, type); &#125; &#125;); return services;&#125; 问题 Singleton 中如何访问 Scoped？通过 IServiceProvider.GetRequireService()。 GetService 和 GetRequiredService 区别？a. GetService 如果服务未注册，则返回 null；b. GetRequiredService 如果服务未注册，则抛出一个 Exception 异常；","categories":[{"name":"NETCore","slug":"NETCore","permalink":"https://chengshen.me/categories/NETCore/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":"NETCore","slug":"NETCore","permalink":"https://chengshen.me/tags/NETCore/"},{"name":"IOC","slug":"IOC","permalink":"https://chengshen.me/tags/IOC/"}]},{"title":"NETCore 请求管道","slug":"csharp/NETCore-request-pipeline","date":"2023-02-16T07:12:47.000Z","updated":"2023-02-16T11:26:27.665Z","comments":true,"path":"/csharp/NETCore-request-pipeline.html","link":"","permalink":"https://chengshen.me/csharp/NETCore-request-pipeline","excerpt":"","text":"中间件形式app.Use：use 中间件可以由 next。app.Run：不能调用 next，用于断路或者管道末尾。app.Map：map request，可用于匹配条件走对应的逻辑，搭配 Use。 示例app.Use12345app.Use(async (context, next) =&gt;&#123; await context.Response.WriteAsync(&quot;hello world&quot;); await next.Invoke();&#125;); app.Run1234app.Run(async context =&gt;&#123; await context.Response.WriteAsync(&quot;hello world3&quot;);&#125;); app.Map12345678app.Map(new PathString(&quot;/test&quot;), application =&gt;&#123; application.Use(async (context, next) =&gt; &#123; await context.Response.WriteAsync(&quot;test&quot;); await next(); &#125;);&#125;); 常见中间件UsingRouting、UsingEndpoint、UseAuthentication、UseAuthorization。 UseRouting注册路由，根据请求匹配路由；UseEndpoints 执行路由委托；在 UseRouting 和 UseEndpoint 管道之间注册其自定义中间件，以实现业务逻辑；UseAuthorization 应该注册在 UseRouting 之后，UseEndpoint 之前。实现对 UseRouting 匹配到的路由进行拦截，做授权验证操作等，验证通过则执行下一个中间件。 UseEndpoints对于传统路由（控制器和视图）需要用 endpoints.MapControllerRoute，restful 属性路由（用属性修饰控制器和方法）需要用 endpoints.MapController。 Authentication认证，表明用户身份的信息，你是谁；Authorization 授权，表明你有系统什么权限，管理员权限或普通用户权限等。例如：你要登机，你需要出示你的身份证和机票，身份证是为了证明你张三确实是你张三，这就是 authentication；而机票是为了证明你张三确实买了票可以上飞机，这就是 authorization。 12345678910111213141516public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; // 路由匹配，用来匹配Controller中Action app.UseRouting(); // ... // 其他处理，如鉴权、授权等 // ... // 对UseRouting匹配到的路由进行委托方法的执行 app.UseEndpoints(endpoints =&gt; &#123; // 配置默认首页是HomeController下的Index方法 endpoints.MapControllerRoute(name: &quot;default&quot;, pattern: &quot;&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;&quot;); &#125;);&#125; 过滤器过滤器(Filters)只能应用到 Action 或 Controller 方法上。 常用过滤器 Authorization filters Resource filters Action filters Exception filters Result filters 使用 [TypeFilter(typeof(xxxxxx))] [ServiceFilter(typeof(xxxxxx))] TypeFilter 不需要注册到服务容器就能直接使用；ServiceFilter 需要注册到服务容器中才能使用，如：service.AddTransient();","categories":[{"name":"NETCore","slug":"NETCore","permalink":"https://chengshen.me/categories/NETCore/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":"NETCore","slug":"NETCore","permalink":"https://chengshen.me/tags/NETCore/"},{"name":"Pipeline","slug":"Pipeline","permalink":"https://chengshen.me/tags/Pipeline/"}]},{"title":"NETCore 程序启动流程","slug":"csharp/NETCore-app-start-flow","date":"2023-02-16T07:07:14.000Z","updated":"2023-02-16T11:26:27.664Z","comments":true,"path":"/csharp/NETCore-app-start-flow.html","link":"","permalink":"https://chengshen.me/csharp/NETCore-app-start-flow","excerpt":"","text":"Program.main 创建主机(Host.CreateDefaultBuilder(args))； 配置主机(ConfigureWebHostDefaults())： 使用 kestrel 主机 读取配置文件 配置 log 组件 注册默认 IOC 容器 使用 Startup Startup.ConfigureServices 对程序中涉及的相关服务进行注册； Startup.Configure 配置请求管道。 启动执行顺序 ConfigureWebHostDefaults 注册组件，比如 Configuration 组件、IOC 容器组件等 ConfigureHostConfiguration 设置生成器自身的配置，比如配置监听的端口、URL 地址 ConfigureAppConfiguration 为应用程序设置其他配置，比如设置自定义配置文件 ConfigureServices、ConfigureLogging、Startup.ConfigureServices 服务注册 Startup.Configure 配置请求中间件","categories":[{"name":"NETCore","slug":"NETCore","permalink":"https://chengshen.me/categories/NETCore/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":"NETCore","slug":"NETCore","permalink":"https://chengshen.me/tags/NETCore/"}]},{"title":"NETCore 请求流程","slug":"csharp/NETCore-request-flow","date":"2023-02-16T06:55:17.000Z","updated":"2023-02-16T11:26:27.665Z","comments":true,"path":"/csharp/NETCore-request-flow.html","link":"","permalink":"https://chengshen.me/csharp/NETCore-request-flow","excerpt":"","text":"流程反向代理 -&gt; kestrel -&gt; middleware 管道 -&gt; 业务处理 -&gt; response 返回数据。 补充：程序启动的时候会把所有的 Controller 中的 Action 映射存储到 routeOptions 集合中，Action 映射成 Endpoint 端点的 RequestDelegate 委托属性，最后通过 UseEndPoints 添加 EndpointMiddleware 中间件进行执行，同时这个中间件中的 Endpoint 路由已经是通过 Routing 匹配后的路由。","categories":[{"name":"NETCore","slug":"NETCore","permalink":"https://chengshen.me/categories/NETCore/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":"NETCore","slug":"NETCore","permalink":"https://chengshen.me/tags/NETCore/"}]},{"title":"hello world, Hexo","slug":"hello-world","date":"2023-02-16T01:13:19.000Z","updated":"2023-02-16T11:26:27.669Z","comments":true,"path":"/hello-world.html","link":"","permalink":"https://chengshen.me/hello-world","excerpt":"","text":"12345678910111213var json1 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var json2 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var json3 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var json4 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var json5 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var json6 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var json7 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var json8 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var json9 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var json0 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var jsona = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var jsonb = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var arr = [1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0]; 这是标题12345678910111213var json1 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var json2 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var json3 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var json4 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var json5 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var json6 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var json7 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var json8 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var json9 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var json0 = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var jsona = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var jsonb = &quot;[1,2,3,4,5,6,7,8,9]&quot;;var arr = [1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0];","categories":[{"name":"hello world","slug":"hello-world","permalink":"https://chengshen.me/categories/hello-world/"}],"tags":[{"name":"hello world","slug":"hello-world","permalink":"https://chengshen.me/tags/hello-world/"}]},{"title":"CLR GC","slug":"csharp/CLR-GC","date":"2023-02-15T05:12:19.000Z","updated":"2023-02-15T11:53:42.710Z","comments":true,"path":"/csharp/CLR-GC.html","link":"","permalink":"https://chengshen.me/csharp/CLR-GC","excerpt":"","text":"算法分类 引用计数 引用跟踪 引用计数：每个对象维护一个内存字段来统计程序中有多少部分正在使用该对象，处理不好循环引用。引用跟踪：标记可达对象，清除不可达对象。 CLR 采用引用跟踪算法，托管堆维护着一个指针 NextObjPtr，它指向下一个对象在堆中的分配位置。GC 时，会暂停进程中所有线程，防止 CLR 检查期间对象状态变更。一旦根离开作用域，它的引用对象就会变得不可达，GC 会回收其内存。 标记清除标记 通过活动根标记它引用的堆对象，然后递归标记堆对象中引用的对象； 如果对象被标记过，就停止递归标记，避免死循环； 清除 清除无标记的对象：普通对象直接回收内存，有终结器的对象单独回收，清除之后内存占用会变得不连续。 压缩 挪动幸存的对象，使它们占用连续内存空间； 更新活动根引用的对象地址； 代特点 对象越新，生存期越短； 对象越老，生存期越长； 堆的部分回收快于整堆回收； 工作原理 初始添加的对象为 0 代，同时给 gen0 一个预估的内存大小阈值； 当初始申请的堆内存不足以分配给新对象时，就会触发 GC； 回收和压缩完，幸存的对象会被看成 gen1 对象，此时 gen0 被认为是空的； 新对象会被分配到 gen0； 如果又遇到 gen0 空间不足时，发现 gen1 老数据空间占用低于阈值，就转而针对 gen0 对象进行垃圾回收处理； 对于老对象中字段引用新对象情况，垃圾回收器利用 JIT 编译器内部机制，在对象引用字段发生变化时，设置一个标志位，表明老对象在上一轮垃圾回收后更新过，只有发生变化的老对象才需要检查是否引用了 gen0 对象； 根据假设，老对象中可能不值得去进行垃圾回收，所以就算 1 代存在垃圾对象，也可能会保留下来； 一顿操作后，gen0 对象也会被认为是 gen1 对象了，gen0 再次被认为是空的； gen1 缓慢增长，当某次 0 代空间又不足，触发 GC，发现 gen1 也超出容量阈值，就对 gen0 和 gen1 的对象都进行垃圾回收； gen1 变 gen2，gen0 变 gen1，gen0 被认为是空的； 默认托管堆只支持 3 代(MaxGeneration() 返回 2)； 补充说明 如果垃圾回收 0 代存活对象很少，可能会减少 0 代容量预算； 如果垃圾回收 0 代发现没多少内存被回收，就会增加 0 代容量预算； 如果没有回收到足够内存，垃圾回收器会执行一次完整回收； 如果还不够，会抛出 OOM(OutOfMemoryException)异常； 触发 GC 0 代内存不足； 显式 GC.Collect()； Windows 报告低内存情况； CLR 正在卸载 AppDomain； CLR 正在关闭； 大对象：大于等于 85000 字节，被认为是大对象。对于大对象来说，又称为 gen3。大对象堆：存放大对象，称为 gen3。第 3 代和第 2 代一起参与垃圾回收。 GC 模式 工作站，默认，适合客户端应用程序。GC 时延低，防 UI 线程明显假死； 服务器，服务器端应用程序，优化吞吐量和资源利用能力； GC 子模式 并发，默认，后台线程在应用程序运行时并发标记对象。 非并发。 延迟模式GC 时会暂停应用程序中正在运行的线程，线程被暂停的时间称为延迟。 模式 说明 Batch 服务器模式默认值 禁后台 GC（并发 GC）。用于服务器端或无 UI 的应用程序。会替代 gcConcurrent 设置。 Interactive 工作站模式默认值 用于有 UI 的大多数应用程序。如果托管了某个应用，则会优先考虑托管进程的垃圾回收器设置。 LowLatency （短期）低延迟模式 禁止 2 代回收，允许 0 代 1 代回收，只能在短时间内使用，仅工作站可用。 SustainedLowLatency 长期低延迟模式 禁止 2 代前台回收，允许 0 代 1 代回收和 2 代后台回收，可以长时间使用，工作站和服务器都可用。 NoGCRegion 在程序执行关键路径时将 GC 线程挂起 不能将该值直接赋值给 GCLatencyMode 属性，通过调用 GC.TryStartGCRegion 方法开始，调用 GC.EndGCRegion 方法结束。 内存泄露 不正确的使用静态字段，导致大量数据无法被 GC 释放； 没有正确执行 Dispose()，非托管资源没有得到释放； 不正确的使用终结器 Finalize()，导致无法正常释放资源； 其他不正确的引用，导致大量托管对象无法被 GC 释放； 托管和非托管资源托管资源指的是 .NET 可以自动进行回收的资源，主要是指托管堆上分配的内存资源。 非托管资源指的是 .NET 不知道如何回收的资源，最常见的是包装操作系统资源的对象。例如：文件，窗口，网络连接，数据库连接，图标等。通过调用 IDisposable.Dispose 方法来回收非托管资源。","categories":[{"name":"CLR","slug":"CLR","permalink":"https://chengshen.me/categories/CLR/"}],"tags":[{"name":"CLR","slug":"CLR","permalink":"https://chengshen.me/tags/CLR/"},{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"}]},{"title":"CLR 类型对象指针和同步块索引","slug":"csharp/CLR-TOP-and-SBI","date":"2023-02-15T05:03:10.000Z","updated":"2023-02-15T11:53:42.710Z","comments":true,"path":"/csharp/CLR-TOP-and-SBI.html","link":"","permalink":"https://chengshen.me/csharp/CLR-TOP-and-SBI","excerpt":"","text":"类型对象指针又称为方法表指针(MT)；32 位系统占 4 字节，64 位系统占 8 字节；实例化对象时，CLR 自动初始化类型对象指针这个成员，它指向类型对象。用 System.Object.GetType() 方法返回这个成员值，用来知道对象（包括类型对象本身）的类型。 同步块索引32 位系统占 4 字节，64 位系统占 8 字节； 同步块索引用途 线程同步 lock； GetHashCode，要用到同步块索引的后 26 位； GC 时标记对象； 线程同步当 CLR 初始化的时候，CLR 会初始化一个同步块数组，线程遇到 lock，去检查对象的同步块索引的值，如果值指向同步块数组的项，说明已加锁，等待；否则，就去同步索引数组中找个空闲位置，记录下标值到 lock 对象的同步块索引上。负责为对象分配同步块并且赋值同步块索引的线程本身是线程安全的。","categories":[{"name":"CLR","slug":"CLR","permalink":"https://chengshen.me/categories/CLR/"}],"tags":[{"name":"CLR","slug":"CLR","permalink":"https://chengshen.me/tags/CLR/"},{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"}]},{"title":"CLR new","slug":"csharp/CLR-instance-by-new","date":"2023-02-15T04:52:56.000Z","updated":"2023-02-15T11:53:42.710Z","comments":true,"path":"/csharp/CLR-instance-by-new.html","link":"","permalink":"https://chengshen.me/csharp/CLR-instance-by-new","excerpt":"","text":"CLR 要求对象都用 new 创建。 new 实例化对象： 计算类和基类中所有实例字段的总字节数，外加类型对象指针、同步块索引字节数； 从托管堆中分配所需空间，空间数据都置为 0； 初始化对象的类型对象指针、同步块索引成员； 如果实现了 Finalize 方法，对象地址会被放到终结器队列； 调用类的实例构造函数，传递必要的参数； 类型对象指针又叫做方法表指针(MT)；","categories":[{"name":"CLR","slug":"CLR","permalink":"https://chengshen.me/categories/CLR/"}],"tags":[{"name":"CLR","slug":"CLR","permalink":"https://chengshen.me/tags/CLR/"},{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"}]},{"title":"CLR 基本概念","slug":"csharp/CLR-basic-concepts","date":"2023-02-15T04:43:00.000Z","updated":"2023-02-15T11:53:42.710Z","comments":true,"path":"/csharp/CLR-basic-concepts.html","link":"","permalink":"https://chengshen.me/csharp/CLR-basic-concepts","excerpt":"","text":"CLRCommon Language Runtime，公共语言运行时，一种可被多种编程语言使用的运行时。 核心功能内存管理、程序集加载、异常处理、线程同步、安全性。 托管模块无论哪种语言(C++、C#、VB、F#等)，最后通过编译的结果都是托管模块。托管模块是 PE32 文件或 PE32+ 文件，都需要 CLR 才能执行。 IL源代码经语言编译器编译生成.exe 或.dll 是 IL(Intermediate Language，中间语言)代码，CPU 不能直接执行。通过 IL 代码可以了解程序执行的底层通用逻辑。 JITJust In Time，即时编译，以方法为单位，将 IL 编译成本机 CPU 指令。JIT 是按需编译的，来最小化启动开销，未被使用的方法 JIT 不编译，小而多的方法优于大而少的方法。JIT 对小而简单(局部变量少，控制分支简单)的方法进行登记(enregistration)，将局部变量存到寄存器中，访问效率比堆栈更高。 CTSCommon Type System，通用类型系统，描述类定义和行为，让不同编程语言能互通。 类的成员：字段、属性、方法、事件等； 类和成员的可见性： public internal protected private 类只能单继承。一个类型只能从一个基类派生； 所有类都继承自 System.Object。 CLSCommon Language Specification，公共语言规范。有的语言不区分大小写，有的语言不支持无符号整数、操作符重载。为了不同语言程序可以进行相互通信，CLS 去定义最小可通用功能集合，让不同语言编译器去支持这些规范，生成的程序彼此间达到兼容目的。","categories":[{"name":"CLR","slug":"CLR","permalink":"https://chengshen.me/categories/CLR/"}],"tags":[{"name":"CLR","slug":"CLR","permalink":"https://chengshen.me/tags/CLR/"},{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"}]},{"title":"CSharp 线程同步","slug":"csharp/CSharp-thread-synchronization","date":"2023-02-15T02:27:06.000Z","updated":"2023-02-15T11:53:42.712Z","comments":true,"path":"/csharp/CSharp-thread-synchronization.html","link":"","permalink":"https://chengshen.me/csharp/CSharp-thread-synchronization","excerpt":"","text":"概念线程同步指的是线程之间的协调，以确保它们不会同时执行并彼此冲突。目标是保持数据完整性，避免多个线程同时访问共享资源时可能出现的竞争。 分类 内核模式 用户模式 混合模式 内核模式涉及上下文切换（线程或进程切换），比较消耗操作系统资源。 Mutex Event Semaphore ReaderWriterLock 用户模式轮询 CPU，避免上下文切换，合适短时操作。 Volatile SpinLock SpinWait Interlocked 混合模式用户模式 + 内核模式。 Barrier Monitor&#x2F;lock SemaphoreSlim CountDownEvent ManualResetEventSlim ReaderWriterLockSlim 详细Mutex互斥量，支持线程互斥和进程互斥线程互斥：mutex.WaitOne、mutex.ReleaseMutex进程互斥：new Mutex(true, “test”, out flag) 参数 1：给调用线程赋予初始所有权限 参数 2：给互斥体取个名字 参数 3：如果赋予调用线程初始权限成功就返回 true，失败就返回 false。 Event有 AutoResetEvent、ManualResetEvent 等。使用：event.WaitOne、event.SetAutoResetEvent 只激活一个线程，ManualResetEvent 激活全部线程。应用：两个线程交互输出数字 SemaphoreSemaphore 信号量，支持线程同步和进程同步。使用：semaphore.Wait、semaphore.ReleaseSemaphoreSlim 轻量级信号量，用于线程同步。new SemaphoreSlim(int) 设定信号总数，限制总数，比如：限制数据库连接数。 Volatilevolatile 修饰字段，用来告诉编译器，该字段会被多线程修改，不要对该字段进行访问优化（缓存优化），确保该字段值的多线程可见性。 123456789public class Example&#123; public int x; public void DoWork() &#123; x = 5; var y = x + 10; &#125;&#125; 编译器第一次发现 y &#x3D; 15，就尝试缓存这个结果，避免每次计算 y &#x3D; x + 10，但 x 有可能被其他线程修改，不该缓存 y &#x3D; 15。解决方法：public volatile int x，表明 x 可能会被多线程修改。 SpinLock自旋锁，一个线程获取该锁，其他线程自旋等待，浪费 CPU，但避免上下文切换，功能与 lock 一样。 Monitor&#x2F;lock混合锁，可重入，lock 是 Monitor 语法糖，lock 无法设置超时。获得锁失败，线程会由运行转为阻塞，会出现上下文切换。Monitor 可超时，避免无限等待出现死锁。lock 原则： 只读私有； 禁用 this、typeof(type)、string； 避免 MethodImplAttribute 同步； 同步构造选择逻辑 避免使用同步构造 优先选择混合模式，其次同步模式，最次内核模式 异步锁 SemaphoreSlim.WaitAsync 问题为什么 lock 引用类型同步块索引。CLR 为堆内的对象分配同步索引，一个引用类型的同步索引不指向任何同步块数组中的同步块，说明没加锁，否则说明该对象被加锁了。值类型没同步块索引，所以 lock 的只能是引用类型。 lock 值类型会如何值类型会被装箱，每次装箱后的对象都不一样，会导致锁定无效。 lock 注意项别 lock this，无意义的 object 更好；别 lock 类型对象，类型对象是全局的；别 lock 字符串，因为字符串可能被驻留，不同字符对象可能指向同一个字符串；别用 MethodImplAttribute(MethodImplOptions.Synchronized)，它相当于去 lock 一个方法，实例方法 lock 的是 this，静态方法 lock 的是类型对象； 可超时线程同步 Mutex：mutex.WaitOne(int) Monitor：Monitor.TryEnter(object, int) Semaphore：semaphore .WaitOne(int) AutoResetEvent：resetEvent.WaitOne(int) 示例两个线程交互输出数字1234567891011121314151617181920212223242526272829303132var some = new SomeClass();var t1 = new Thread(some.PrintEven) &#123; Name = &quot;even&quot; &#125;;var t2 = new Thread(some.PrintOdd) &#123; Name = &quot;odd&quot; &#125;;t1.Start();t2.Start();class SomeClass&#123; // 偶数 AutoResetEvent even = new AutoResetEvent(false); // 奇数 AutoResetEvent odd = new AutoResetEvent(false); volatile int number = 0; internal void PrintEven() &#123; while (number &lt;= 100) &#123; $&quot;&#123;Thread.CurrentThread.Name&#125; - &#123;number++&#125;&quot;.Dump(); odd.Set(); even.WaitOne(); &#125; &#125; internal void PrintOdd() &#123; odd.WaitOne(); while (number &lt;= 100) &#123; $&quot;&#123;Thread.CurrentThread.Name&#125; - &#123;number++&#125;&quot;.Dump(); even.Set(); odd.WaitOne(); &#125; &#125;&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/categories/CSharp/"}],"tags":[{"name":"CLR","slug":"CLR","permalink":"https://chengshen.me/tags/CLR/"},{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":"Thread Synchronization","slug":"Thread-Synchronization","permalink":"https://chengshen.me/tags/Thread-Synchronization/"}]},{"title":"CSharp LINQ","slug":"csharp/CSharp-linq","date":"2023-02-15T02:18:03.000Z","updated":"2023-02-15T11:53:42.712Z","comments":true,"path":"/csharp/CSharp-linq.html","link":"","permalink":"https://chengshen.me/csharp/CSharp-linq","excerpt":"","text":"说明LINQ 意为集成查询语言，将查询功能集成到 C# 语言的技术统称，借助 LINQ，查询成为了最高级的语言构造，就像类、方法和事件一样。支持数据对象 (LINQ to Objects)、关系数据库 (LINQ to SQL) 和 XML (LINQ to XML) 等。查询表达式必须以 from 子句开头，必须以 group 子句或 select 子句结尾。into 存储分组结果，let 存储临时变量。 惰性计算(lazy computation)是指延迟执行查询，直到实际需要时再执行查询。当查询定义完成后，将创建一个查询表达式树，该树描述查询的结构和要执行的操作。当枚举查询结果或使用查询结果时，才会执行查询表达式树上的操作。每个操作只在该操作对应的结果需要时才被执行，并且结果仅在需要时存储。因此，在数据量很大的情况下，可以避免加载整个数据集到内存中的性能损失。","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":"LINQ","slug":"LINQ","permalink":"https://chengshen.me/tags/LINQ/"}]},{"title":"CSharp 异步","slug":"csharp/CSharp-asynchronous","date":"2023-02-15T01:30:32.000Z","updated":"2023-02-15T11:53:42.710Z","comments":true,"path":"/csharp/CSharp-asynchronous.html","link":"","permalink":"https://chengshen.me/csharp/CSharp-asynchronous","excerpt":"","text":"同步同步编程中代码逻辑按顺序执行，处理长时间运行的操作（如：IO 操作）时会导致性能问题：软件速度缓慢且无响应。 异步异步编程对于长时间运行或 I&#x2F;O 密集型的操作，会释放主线程以执行其他任务，效率更高。C# 中，异步编程是使用 Task 和 async&#x2F;await 关键字等来实现的。 Thread线程是最基本的工作单元，有自己的栈和内核资源，共用进程资源。 ThreadPool线程池是一堆线程的包装器，由 CLR 维护，当有任务需要处理，先用已创建的空闲线程来执行任务，如果没有空闲线程，可能会创建新线程，也可能会等待。线程池适合不需要结果的短时操作。 Task .NET 4 推出 Task，.NET 4.5 推出 async&#x2F;await； Task 基于池线程，不是全局线程池，而是本地线程池，避免线程资源竞争； Task 提供了丰富的 API 来管理线程、控制； Task 依赖于 CPU，对于多核的 CPU，性能更佳； 创建一个 task 也有 3 种方式：前面 2 种是一样的，不需要用 start 来开始执行，后面一种需要 start 来执行。 Task.Factory.StartNew() Task.Run() new Task() 对比 Thread、ThreadPool ，Task 原生支持延续、取消、失败通知； Task 不应该用于执行长时任务; 123Task&lt;string&gt; task1 = Task.Run&lt;string&gt;(() =&gt; &quot;something to do&quot;);// 在获取Result结果时会阻塞线程var result = task1.Result; async&#x2F;awaitasync&#x2F;await 用于简化异步代码的编写和理解，以更加自然的方式编写异步代码，避免回调地狱和复杂的状态机。async 修饰的方法表示这是一个异步方法，而 await 表示等待异步方法执行完成。使用 await 等待一个异步方法时，程序将暂停执行当前方法，等待异步方法完成，然后继续执行后续代码。async&#x2F;await 更适合处理 I/O 密集型 操作，或 UI 事件响应；","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":"Asynchronous","slug":"Asynchronous","permalink":"https://chengshen.me/tags/Asynchronous/"},{"name":"Synchronous","slug":"Synchronous","permalink":"https://chengshen.me/tags/Synchronous/"},{"name":"Task","slug":"Task","permalink":"https://chengshen.me/tags/Task/"},{"name":"async/await","slug":"async-await","permalink":"https://chengshen.me/tags/async-await/"}]},{"title":"CSharp 委托和事件","slug":"csharp/CSharp-delegate-and-event","date":"2023-02-15T01:29:35.000Z","updated":"2023-02-15T11:53:42.711Z","comments":true,"path":"/csharp/CSharp-delegate-and-event.html","link":"","permalink":"https://chengshen.me/csharp/CSharp-delegate-and-event","excerpt":"","text":"委托委托约定方法签名，引用一个或多个方法，调用委托就是调用委托引用的全部方法。 事件类或对象通过事件向其他类或对象通知发生的相关事情。事件只能在定义的类内部调用； 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;namespace SimpleTest&#123; internal class Program &#123; private static void Main(string[] args) &#123; Publisher publisher = new Publisher(); Subscriber subscriber = new Subscriber(publisher); // 触发事件 publisher.Trigger(); Console.ReadLine(); &#125; &#125; /// &lt;summary&gt; /// 发布者 /// &lt;/summary&gt; public class Publisher &#123; public delegate void NoticeHandler(string message); public event NoticeHandler OnNotice; public void Trigger() &#123; // 传递事件及参数 OnNotice?.Invoke(&quot;警告！警告！警告！警告&quot;); &#125; &#125; /// &lt;summary&gt; /// 订阅者 /// &lt;/summary&gt; public class Subscriber &#123; public Subscriber(Publisher pub) &#123; //订阅事件 pub.OnNotice += NoticeHandler; &#125; /// &lt;summary&gt; /// 订阅事件后的响应函数 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt; private void NoticeHandler(string message) &#123; Console.WriteLine($&quot;Notice Handler Got Message: &#123;message&#125;&quot;); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System;namespace MyConsole&#123; public delegate string DelegateFun(string word); public class Test &#123; public event DelegateFun EventSay; public DelegateFun DelegateSay; public void DoEventSay(string str) &#123; if (EventSay != null) &#123; EventSay(str); &#125; &#125; &#125; internal static class Program &#123; private static void Main(string[] args) &#123; Test t = new Test(); t.EventSay += Say1; t.DelegateSay += Say1; t.DelegateSay += Say2; // 错误 事件不能在外部直接调用 // t.eventSay(&quot;eventSay&quot;); // 正确 事件只能在声明的类内部调用 t.DoEventSay(&quot;eventSay&quot;); // 正确。委托可以在外部直接调用，内部调用也行，还能有返回值，返回最后一个注册的方法的返回值 string str = t.DelegateSay(&quot;deleSay&quot;); Console.Read(); &#125; private static string Say1(string word) &#123; Console.WriteLine(word); return &quot;return &quot; + word; &#125; private static string Say2(string word) &#123; Console.WriteLine(word); return &quot;return &quot; + word + &quot; 2&quot;; &#125; &#125;&#125;","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":"Delegate","slug":"Delegate","permalink":"https://chengshen.me/tags/Delegate/"},{"name":"Event","slug":"Event","permalink":"https://chengshen.me/tags/Event/"}]},{"title":"CSharp dispose","slug":"csharp/CSharp-dispose","date":"2023-02-14T15:37:48.000Z","updated":"2023-02-15T11:53:42.712Z","comments":true,"path":"/csharp/CSharp-dispose.html","link":"","permalink":"https://chengshen.me/csharp/CSharp-dispose","excerpt":"","text":"IDisposable.Dispose对于非托管资源建立和释放，C# 约定由 Dispose 方法来处理。当类库中涉及到非托管资源，就应实现 Dispose 方法，来定义资源释放逻辑。using 用来管理实现了 Dispose 方法的类，编译器会在作用域结束时调用 Dispose 方法。非托管资源包括：网络请求，数据库连接，句柄等。 标准 dispose 模式 析构函数中调用 dispose 方法，托底防忘记调用； dispose 中最后要调用 GC.SuppressFinaliza 方法，通知 CLR 无需执行析构函数，因为清除工作已完成； 多次调用 dispose 应该是安全的，dispose 方法调用后，后续再调用都不会执行额外的工作； dispose 方法有 2 个重载：public 和 protected，protected 真实清除，public 调用 protected； 析构函数调用 protected； protected 的 bool 参数区分是被析构函数调用（false）还是被 public 调用（true）； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071using System;using System.Runtime.InteropServices;namespace MyConsole.DisposeDemo&#123; /// &lt;summary&gt; /// 用于模拟一个托管资源 /// &lt;/summary&gt; public class SomeManagedResource &#123; public SomeManagedResource(string name) &#123; Name = name; &#125; public string Name &#123; get; &#125; &#125; /// &lt;summary&gt; /// 用于模拟一个非托管资源 /// &lt;/summary&gt; public class MyUnmanagedResource : IDisposable &#123; // 模拟一个非托管资源 private IntPtr someUnmanagedResource = Marshal.AllocHGlobal(100); // 模拟一个托管资源 private SomeManagedResource managedResource = new SomeManagedResource(&quot;这是托管资源&quot;); // 是否被清理过的标识 protected bool baseDisposed = false; public void Dispose() &#123; Dispose(true); GC.SuppressFinalize(this); &#125; protected virtual void Dispose(bool isDisposing) &#123; // 确保多次执行的安全性 if (baseDisposed) &#123; return; &#125; // 被 public 调用，需要额外清理托管资源 if (isDisposing) &#123; // 要调用 SuppressFinaliza，需手动清理托管资源, 否则无法释放。 if (managedResource != null) &#123; managedResource = null; &#125; &#125; // 清理非托管资源 if (someUnmanagedResource != IntPtr.Zero) &#123; Marshal.FreeHGlobal(someUnmanagedResource); someUnmanagedResource = IntPtr.Zero; &#125; baseDisposed = true; &#125; ///&lt;summary&gt; /// 必须，以防忘记调用 Dispose 方法的托底方法 ///&lt;/summary&gt; ~MyUnmanagedResource() &#123; // 必须为false Dispose(false); &#125; &#125;&#125; Finalize 无法显式的重写 Finalize 方法，只能通过析构函数语法形式来实现。 struct 中不允许定义析构函数，只有 class 中才可以，并且只能有一个。 Finalize 方法不能被继承或重载。 执行垃圾回收之前系统会自动执行 Finalize 操作。 Finalize 方法会极大地损伤性能。","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":"Dispose","slug":"Dispose","permalink":"https://chengshen.me/tags/Dispose/"}]},{"title":"CSharp 简单应用","slug":"csharp/CSharp-usage","date":"2023-02-14T15:27:46.000Z","updated":"2023-02-16T11:26:27.662Z","comments":true,"path":"/csharp/CSharp-usage.html","link":"","permalink":"https://chengshen.me/csharp/CSharp-usage","excerpt":"","text":"生成二维码1234567891011public Stream QRCodeStream(string contents)&#123; QRCodeGenerator qrGenerator = new QRCodeGenerator(); QRCodeData qrCodeData = qrGenerator.CreateQrCode(contents, QRCodeGenerator.ECCLevel.L); QRCode qrCode = new QRCode(qrCodeData); Bitmap bigMap = qrCode.GetGraphic(20, Color.Black, Color.White, true); MemoryStream stream = new MemoryStream(); bigMap.Save(stream, System.Drawing.Imaging.ImageFormat.Png); stream.Position = 0; return stream;&#125; 拼接图片123456789101112131415string file1 = @&quot;C:\\Users\\Admin\\Desktop\\images\\1.png&quot;;string file2 = @&quot;C:\\Users\\Admin\\Desktop\\images\\2.png&quot;;Image image1 = Image.FromStream(new MemoryStream(File.ReadAllBytes(file1)));Image image2 = Image.FromStream(new MemoryStream(File.ReadAllBytes(file2)));var image1Width = image1.Width;var image1Height = image1.Height;var image2Width = image2.Height;var image2Height = image2.Height;var stream = new MemoryStream();using Bitmap map = new Bitmap(image1Width, image1Height);//定义画布Graphics g = Graphics.FromImage(map);//定义画笔g.Clear(Color.White);//把画布更改为白色g.DrawImage(image1, new Point(0, 0));g.DrawImage(image2, new Point(image1Width - image2Width, image1Height - image2Height));map.Save(stream, ImageFormat.Jpeg); 端口占用检查1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465while (true)&#123; Console.WriteLine(&quot;请输入需要检测的端口号(如：80), 输入exit退出此程序&quot;); var inPortString = Console.ReadLine(); Process process = new Process(); if (inPortString == &quot;exit&quot;) &#123; process.Close(); break; &#125; int port = 80; try &#123; if (string.IsNullOrWhiteSpace(inPortString)) &#123; Console.WriteLine(&quot;输入端口号非法，将查询默认端口号：80&quot;); &#125; else &#123; port = Convert.ToInt32(inPortString); &#125; &#125; catch (Exception e) &#123; Console.WriteLine(&quot;输入端口号非法，将查询默认端口号：80&quot;); port = 80; &#125; process.StartInfo.FileName = &quot;cmd.exe&quot;; process.StartInfo.UseShellExecute = false; process.StartInfo.RedirectStandardInput = true; process.StartInfo.RedirectStandardOutput = true; process.StartInfo.RedirectStandardError = true; process.StartInfo.CreateNoWindow = true; process.Start(); process.StandardInput.WriteLine(&quot;netstat -ano&quot;); process.StandardInput.WriteLine(&quot;exit&quot;); Regex reg = new Regex(&quot;\\\\s+&quot;, RegexOptions.Compiled); bool found = false; string line = string.Empty; while ((line = process.StandardOutput.ReadLine()) != null) &#123; line = line.Trim(); if (line.StartsWith(&quot;TCP&quot;, StringComparison.OrdinalIgnoreCase)) &#123; line = reg.Replace(line, &quot;,&quot;); string[] arr = line.Split(&#x27;,&#x27;); if (arr[1].EndsWith($&quot;:&#123;port&#125;&quot;)) &#123; found = true; int pid = int.Parse(arr[4]); Process foundProcess = Process.GetProcessById(pid); Console.WriteLine($&quot;&#123;port&#125;端口. pid：&#123;pid&#125;, 进程名：&#123;foundProcess.ProcessName&#125;\\n&quot;); break; &#125; &#125; &#125; if (!found) &#123; Console.WriteLine($&quot;未找到&#123;port&#125;端口上的进程\\n&quot;); &#125; process.Close();&#125; byte[]、string、stream 间转换stream -&gt; string12using StreamReader reader = new StreamReader(stream);string result = reader.ReadToEnd(); string -&gt; stream12345string test = &quot;This is string&quot;;using MemoryStream stream = new MemoryStream();using StreamWriter writer = new StreamWriter( stream );writer.Write( test );writer.Flush(); byte[] -&gt; string1string str = System.Text.Encoding.Default.GetString( byteArray ); string -&gt; byte[]1byte[] byteArray = System.Text.Encoding.Default.GetBytes( str ); stream -&gt; byte[]12byte[] bytes = new byte[stream.Length];stream.Read(bytes, 0, bytes.Length); byte[] -&gt; stream1using Stream stream = new MemoryStream(bytes); 文本长度12345678string strTmp = &quot;a1某某某&quot;;// 10，Unicode下中英文每个字2字节。int len1 = System.Text.Encoding.Unicode.GetBytes(strTmp).Length;// 11，Default 等价与 UTF8，中文3个字节，英文1个字节int len2 = System.Text.Encoding.Default.GetBytes(strTmp).Length;int len3 = System.Text.Encoding.UTF8.GetBytes(strTmp).Length;// 5，就是个数int len4 = System.Text.Encoding.Default.GetBytes(strTmp).Length; WebSocket 应用Startup.Configure1app.UseWebSockets(); Controller.cs123456789101112131415161718192021222324252627282930313233[HttpGet(&quot;receive-message&quot;)]public async Task GetMessage()&#123; if (HttpContext.WebSockets.IsWebSocketRequest) &#123; using (var webSocket = await HttpContext.WebSockets.AcceptWebSocketAsync()) &#123; Console.WriteLine(&quot;WebSocket connection established&quot;); await Echo(webSocket); &#125; &#125; else &#123; HttpContext.Response.StatusCode = 400; &#125;&#125;private async Task Echo(WebSocket webSocket)&#123; var buffer = new byte[1024 * 4]; var result = await webSocket.ReceiveAsync(new ArraySegment&lt;byte&gt;(buffer), CancellationToken.None); Console.WriteLine(&quot;Message received from Client&quot;); while (!result.CloseStatus.HasValue) &#123; var serverMsg = Encoding.UTF8.GetBytes($&quot;Server: Hello. You said: &#123;Encoding.UTF8.GetString(buffer)&#125;&quot;); await webSocket.SendAsync(new ArraySegment&lt;byte&gt;(serverMsg, 0, serverMsg.Length), result.MessageType, result.EndOfMessage, CancellationToken.None); Console.WriteLine(&quot;Message sent to Client&quot;); result = await webSocket.ReceiveAsync(new ArraySegment&lt;byte&gt;(buffer), CancellationToken.None); Console.WriteLine(&quot;Message received from Client&quot;); &#125; await webSocket.CloseAsync(result.CloseStatus.Value, result.CloseStatusDescription, CancellationToken.None); Console.WriteLine(&quot;WebSocket connection closed&quot;);&#125; index.html12var socket = new WebSocket(&#x27;wss://localhost:6666/receive-message&#x27;);socket.send(&#x27;前端消息&#x27;); HTTP 网络请求HttpWebRequest：最早，不阻塞 ui，细节控制；WebClient：对 HttpWebRequest 的简化和封装；HttpClient：.NET 4.5 开始，预热机制，适合发送多次请求； HttpClient1234567var httpClientHandler = new HttpClientHandler&#123; Proxy = new WebProxy(&quot;http://127.0.0.1:1080&quot;, false),// 设置代理&#125;;var httpClient = new HttpClient(httpClientHandler);var response = await httpClient.GetAsync(&quot;http://www.baidu.com&quot;);var responseText = await response.Content.ReadAsStringAsync(); HttpClient 存在 Dispose 后不能立即释放对应套接字问题，默认需要 4 分钟去释放。可以创建一个 HttpClient 实例，把它存储在一个静态字段中，或者使用 HttpClientFactory，相关文章。","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"}]},{"title":"CSharp .NET 和 C#","slug":"csharp/CSharp-dotnet-and-csharp","date":"2023-02-14T15:21:07.000Z","updated":"2023-02-15T11:53:42.712Z","comments":true,"path":"/csharp/CSharp-dotnet-and-csharp.html","link":"","permalink":"https://chengshen.me/csharp/CSharp-dotnet-and-csharp","excerpt":"","text":"C# 和 .NET 语言版本 发布时间 .NET Framework 要求 Visual Studio 版本 C# 1.0 2002.1 .NET Framework 1.0 Visual Studio .NET 2002 C# 1.1&#x2F;1.2 2003.4 .NET Framework 1.1 Visual Studio .NET 2003 C# 2.0 2005.11 .NET Framework 2.0 Visual Studio 2005 C# 3.0 2007.11 .NET Framework 2.0&#x2F;3.0&#x2F;3.5 Visual Studio 2008 C# 4.0 2010.4 .NET Framework 4.0 Visual Studio 2010 C# 5.0 2012.8 .NET Framework 4.5 Visual Studio 2012&#x2F;2013 C# 6.0 2015.7 .NET Framework 4.6 Visual Studio 2015 C# 7.0 2017.3 .NET Framework 4.6.2 Visual Studio 2017 C# 7.1 2017.6 .NET Framework 4.7 Visual Studio 2017 v15.3 预览版 C# 7.2 2017.11 .NET Framework 4.7.1 Visual Studio 2017 v15.5 C# 7.3 2018.5 .NET Framework 4.7.2 Visual Studion 2017 v15.7 C# 8.0 2019.04.18 .NET Framework 4.8&#x2F;.NET Core 3&#x2F;3.1 Visual Studion 2019 C# 9 2020.09.04 .NET 5 Visual Studion 2019 C# 10.0 2021.11.09 .NET 6 Visual Studion 2022 C# 11 2022.11.8 .NET 7 Visual Studion 2022 C# 版本及其语言特性C# 1.0 [2002 年 01 月]类、结构、接口、事件、属性、委托，运算符和表达式、语句、特性 C# 2.0 [2005 年 11 月]泛型、Partial 类型、匿名方法、迭代器、可空类型、私有 setters、方法组转化(delegates)、协变和逆变、静态类 C# 3.0 [2007 年 11 月]隐式类型的局部变量(var)、对象与集合初始化器、自动实现属性(get;set;)、Partial 方法、匿名类、扩展方法、LINQ、Lambda 表达式、表达式树https://msdn.microsoft.com/en-us/library/bb308966.aspx C# 4.0 [2010 年 04 月]动态绑定(dynamic)、命名参数和可选参数、泛型协变和逆变、嵌入式互操作类型https://msdn.microsoft.com/en-us/magazine/ff796223.aspx C# 5.0 [2012 年 08 月]异步特性(async &amp; await)、调用者信息https://learn.microsoft.com/zh-cn/archive/blogs/mvpawardprogram/an-introduction-to-new-features-in-c-5-0 C# 6.0 [2015 年 07 月]表达式为主体的成员方法和只读属性、属性初始化赋值、nameof 表达式、Await in catch block、异常过滤器(when)、字符串插值https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-6 C# 7.0 [2017 年 03 月]out variables、Tuples、Discards、Pattern Matching、局部方法、Generalized async return typeshttps://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7 C# 8.0 [2019 年 04 月]Readonly members、默认接口方法、Using declarations、静态局部方法、Disposable ref structs、可空引用类型https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8 C# 9.0 [2020 年 09 月]Records、Init-only properties、Top-level statements、Init accessors and readonly fields、With 表达式、Value-based equality、Primary constructorhttps://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9 C# 10.0 [2021 年 11 月]Record structs、Global using directives、File-scoped namespace declaration、Extended Proptery Patterns、Null Parameter Checking、Constant interpolated stringshttps://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10 C# 11.0 [2022 年 11 月]原生字符串字面量、Generic math support、泛型 attributes、UTF-8 字符串字面量、Newlines in string interpolation expressions、List patterns、file 类修饰符、Required members、Auto-default structs、Pattern match Span on a constant string、Extended nameof scope、Numeric IntPtr、ref fields and scoped ref、Improved method group conversion to delegate、Warning wave 7https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11综合https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":".NET","slug":"NET","permalink":"https://chengshen.me/tags/NET/"},{"name":"Features","slug":"Features","permalink":"https://chengshen.me/tags/Features/"}]},{"title":"CSharp 基础知识","slug":"csharp/CSharp-basic-concepts","date":"2023-02-14T14:49:07.000Z","updated":"2023-02-16T13:45:55.098Z","comments":true,"path":"/csharp/CSharp-basic-concepts.html","link":"","permalink":"https://chengshen.me/csharp/CSharp-basic-concepts","excerpt":"","text":"string.Empty、 “” 、 nullEmpty 是 string 类中的一个静态的只读字段。string.Empty 和 “” 是一样的。string str &#x3D; null 表示 str 未指向任何对象。 string 和 StringBuilderstring 是不可变对象，string 是 String 的别名，string 是 c#中的类，String 是 Framework 的类，编译器会把 string 编译成 String。StringBuilder 为动态字符串。StringBuilder 当达到容量时，将自动分配新的空间且容量翻倍。 扩展方法向现有类型“添加”方法，无需派生、重新编译或修改原始类型。扩展方法是一种静态类中的静态方法。扩展方法第一个参数是 this 修饰的被扩展的类。 装箱和拆箱装箱：值类型 -&gt; 引用类型 。拆箱：引用类型 -&gt; 值类型。一次装箱要分配内存（托管堆）和拷贝数据（从栈到托管堆）。拆箱就是装箱的相反操作。 更改已装箱的对象已装箱的对象，无法直接调用其指定方法。让类对象继承一个接口，借助接口方式来更改已装箱的对象中的数据。 123456789101112131415161718public interface ISomeClass &#123; void Change(int x);&#125;public class SomeClass : ISomeClass&#123; public int x &#123; get; set; &#125; public void Change(int x) &#123; this.x = x; &#125;&#125;SomeClass some = new SomeClass();some.x = 100;Object o = some; // 装箱((SomeClass)o).Change(200); // 没改掉。((ISomeClass)o).Change(200); // 改掉了。 new 关键字 运算符：创建对象实例。 修饰符：在派生类定义一个重名的方法，隐藏基类方法。 约束：泛型约束，表示泛型类型要有 public 修饰的无参构造。 12public class ItemFactory&lt;T&gt; where T : IComparable, new()&#123; &#125; new 和 overridenew 和 override 都可用覆盖基类同名方法；new 覆盖基类不完全，父类引用子类实例时，能调用到基类方法，override 覆盖基类是彻底的，一旦子类 override 基类方法后，就无法再调用基类同名方法。 123456789101112131415161718192021222324252627282930313233class Parent&#123; public virtual string Say () &#123; return &quot;I am parent&quot;; &#125;&#125;class Child1 : Parent&#123; public override string Say () &#123; return &quot;I am child1&quot;; &#125;&#125;class Child2 : Parent&#123; public new string Say () &#123; return &quot;I am child2&quot;; &#125;&#125;// 父类引用子类实例Parent instance1 = new Child1();// I am child1string who1 = instance1.Say();// 父类引用子类实例Parent instance2 = new Child2();// 注意，这里就能调用到基类方法，结果为：I am parentstring who1 = instance2.Say(); int? 和 int可空类型，默认值可以是 null。int? 是通过 int 装箱为引用类型实现。Nullable.GetUnderlyingType(typeof(int?)) != null 用来判断类型是否是可空类型 委托约定方法签名，来对方法进行引用，类似指针，方法能当参数传递给形参，用于事件、回调等。 const 和 readonlyreadonly 运行时常量。const 编译时常量。readonly 常量只能声明为类字段。const 除了类字段，还可以声明为方法中的局部常量，默认为静态类型，不能用 static 修饰。 CTS、CLS、CLRCTS：通用类型系统；CLS：通用语言规范；CLR：公共语言运行库； using 引用命名空间。 using 一个非托管资源（IDisposiable），用来释放资源。 托管资源和非托管资源托管资源指的是.NET 可以自动进行回收的资源，主要是指托管堆上分配的内存资源。非托管资源指的是.NET 不知道如何回收的资源，最常见的是包装操作系统资源的对象，例如文件，窗口，网络连接，数据库连接，画刷，图标等。建议通过调用 IDisposable.Dispose()方法来回收非托管资源。 ref、out、in相同：都是按引用传递，形参成为实参的别名；不同：ref 在方法外需初始化；out 需在方法内赋值；in 在方法内是只读的。 123456789101112131415static void Main(string[] args)&#123; //初始化 int number = 50; Console.WriteLine(&quot;调用方法前 number 值：&quot; + number); RefFunction(ref number); Console.WriteLine(&quot;调用方法后 number 值：&quot; + number); Console.Read();&#125;// 传入的参数值是 50 ，方法中使用的 num 值也是 50static void RefFunction(ref int num)&#123; num = num / 2;&#125; 12345678910111213141516static void Main(string[] args)&#123; int number = 50; Console.WriteLine(&quot;调用方法前 number 值：&quot; + number); OutFunction(out number); Console.WriteLine(&quot;调用方法后 number 值：&quot; + number); Console.Read();&#125;// 无法将的参数值 50 传入 ，但是必须在方法中初始化static void OutFunction(out int num)&#123; //初始化 num = 120; num = num / 2;&#125; in 的意义结构体实例数据分配在栈上，当需要将大数据量的结构体作为方法参数时，会复制一份该大结构体，成本有点高，使用 in 来按引用传递该大结构体，就能避免复制问题。 ref、out、in 使用限制async 修饰的异步方法中无法使用；迭代器方法（含有 yield return 或 yield break 的方法）中无法使用；扩展方法的第一个参数不能有 in 修饰符，除非该参数是结构体；扩展方法的第一个参数，其中该参数是泛型类型（即使该类型被约束为结构体）； Equals 和 &#x3D;&#x3D;&#x3D;&#x3D; 值类型数据比较的是值，引用类型比较的是引用地址。Equals 引用类型比较的是最终数据。 as、is、IsAssignableFromas 用于在兼容的引用类型之间执行类型转换，无法转换则为 null；is 兼容性判断，返回 bool 值，不会抛出异常，语法：实例对象 is 类型；IsAssignableFrom 兼容性判断，返回 bool 值，不会抛出异常，语法：类型.IsAssignableFrom(类型)。 访问修饰符public：共有的，访问不受限制；private：私有的，只能在当前类中访问；internal：内部的，只能在当前程序集中访问；protected：受保护的，只能在当前类或其派生类中访问；file：当前文件范围，C# 11 新增；protected internal：受保护的内部成员，当前程序集或派生自包含类的类型可访问；private protected：私有受保护的成员，当前程序集中的包含类或从包含类派生的类型可访问；class 默认 internal，class member 默认 private。 class、interface 成员class 成员：字段、常量、属性、方法、事件、运算符、索引器、构造函数、终结器、嵌套类型。interface 成员：方法、属性、索引器和事件 类的执行顺序父类，子类，静态块，静态字段，非静态块，非静态字段，构造器，方法 数据类型和内存占用 大小 成员 1 byte bool、byte 2 byte char、short 4 byte int、float 8 byte long、double 16 byte decimal 多态编译时多态和运行时多态。 编译时多态重载编译时多态。根据签名不同分为不同的方法，编译后就成两个不同名函数。 运行时多态虚方法是运行时多态，父类中有虚方法，子类覆盖实现虚方法。 浅拷贝和深拷贝在浅拷贝中，仅对顶级对象进行了复制，对低级别对象进行了引用。在深拷贝中，会复制所有对象。 浅拷贝继承 ICloneable，实现 Clone()方法，方法中调用 MemberwiseClone()；如果字段是值类型，则执行字段的按位复制；如果字段是引用类型，引用将复制，但被引用的对象不会被复制。 协变和逆变in 逆变，out 协变。赋值的兼容性，用在委托或者接口上。需要返回数据，这种结构化的委托有效性之间的关系叫做协变，用 out 标记泛型类型。需要接受数据，期望传入基类时允许传入派生对象的特性叫逆变，用 in 标记泛型类型。协变： IEnumerable IEnumerator IQueryable IGrouping&lt;out TKey, out TElement&gt; 逆变： IComparer IEqualityComparer IComparable Action Predicate Comparison 协变 + 逆变： TOutput Converter&lt;in TInput, out TOutput&gt; object 和 dynamicobject 是一种引用类型，表示 .NET 框架中的任何类型。它是所有引用类型的基类，允许将任何类型的对象存储在这个变量中。dynamic 是 C# 中的一个关键字，在编译时将变量的类型指定为 dynamic ，对象的实际类型将在运行时确定，这在使用没有特定类型定义的 API 或库时非常有用。 总结object 是基类，可以存储任何引用类型；dynamic 是关键字，在编译时跳过类型检查，在运行时确定类型。 场景object 在我们不知道数据类型时很有用。dynamic 更多是用在反射，支持动态语言，COM 对象调用以及获取 LINQ 的查询结果。 12345object a = &quot;Rohatash Kumar&quot;;string a1 = a.ToString();dynamic a = &quot;Rohatash Kumar&quot;;string a1 = a; 抽象类和接口 都能有默认实现； 都不能直接实例化； 抽象类单继承，接口多继承； 抽象类中可以有字段、属性、方法，接口中可以有属性、方法、索引器、事件，没有字段；","categories":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/categories/CSharp/"}],"tags":[{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"}]},{"title":"HTML src 和 href","slug":"web/HTML-src-and-href","date":"2023-02-14T14:27:46.000Z","updated":"2023-02-15T11:53:42.715Z","comments":true,"path":"/web/HTML-src-and-href.html","link":"","permalink":"https://chengshen.me/web/HTML-src-and-href","excerpt":"","text":"作用结果不同href 用于在当前文档和引用资源之间建立联系。src 加载资源，嵌入相应元素中。 浏览器解析方式不同href 浏览器会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。src 会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，如图片(img)和框架(iframe)等，类似于将资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。 请求资源类型不同href（Hypertext Reference，超文本引用）用来建立当前元素和文档之间的链接。如：link、a。src 的资源，会将资源下载并应用到文档中，常用的有 script，img 、iframe。 使用1234567&lt;link href=&quot;./style.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;a href=&quot;http://example.com&quot; target=&quot;_blank&quot;&gt;click here&lt;/a&gt;&lt;script src=&quot;http://example.com/foo.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;img src=&quot;http://example.com/bar.png&quot;&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"https://chengshen.me/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://chengshen.me/tags/HTML/"}]},{"title":"Web 浏览器中网络请求过程","slug":"web/Web-request-process-in-browser","date":"2023-02-14T14:21:06.000Z","updated":"2023-02-15T11:53:42.716Z","comments":true,"path":"/web/Web-request-process-in-browser.html","link":"","permalink":"https://chengshen.me/web/Web-request-process-in-browser","excerpt":"","text":"地址解析，提取出协议、域名、端口等信息等 通过 DNS 获取到 IP 地址 进行 TCP 连接(三次握手)a. 第一次握手：建立连接时，客户端发送 syn(建立联机)包到服务器，并进入 syn_send 状态，等待服务器确认；b. 第二次握手：服务器收到 syn 包，确认包信息，同时自己也发送一个 syn + ack(确认)包并进入 syn_recv 状态;c. 第三次握手：客户端收到 syn+ack 包，向服务器发送 ack 包，发送完后，客户端和服务器都进入 established 状态，完成三次握手； HTTP 请求 服务器响应请求 DOM 解析和渲染","categories":[{"name":"Web","slug":"Web","permalink":"https://chengshen.me/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://chengshen.me/tags/Web/"},{"name":"Request","slug":"Request","permalink":"https://chengshen.me/tags/Request/"}]},{"title":"Web DOM 的解析和渲染","slug":"web/Web-dom-parsing-and-rendering","date":"2023-02-14T14:12:08.000Z","updated":"2023-02-15T11:53:42.716Z","comments":true,"path":"/web/Web-dom-parsing-and-rendering.html","link":"","permalink":"https://chengshen.me/web/Web-dom-parsing-and-rendering","excerpt":"","text":"解析流程 解析 html，构建 DOM Tree 解析 CSS，构建 CSS Rule Tree 由 DOM Tree 和 CSS Rule Tree 生成 Render Tree 利用 Render Tree 进行布局 Layout，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置 painting 绘制 按照算出来的规则将内容绘制到屏幕上 相关问题问：DOM 树的构建是文档加载完成开始的？答：不是，为更好用户体验，渲染引擎会尽快将内容进行显示，加载部分后就尝试解析、构建、布局、渲染。问：Render 树是 DOM 树和 CSSOM 树构建完毕才开始构建的吗？答：不是。三者交叉进行，一边加载，一边解析，一边渲染。问：CSS 解析顺序？答：选择器从右往左，DOM 树从下向上的解析顺序。嵌套标签越多解析越慢。问：repaint 重绘？答：改变元素背景色、前景色、边框色等，不影响文档中周边元素布局位置。问：reflow 回流？答：影响元素布局位置变更的操作，会导致回流，从根向下重新计算全部元素节点尺寸和位置，比如：元素显隐、元素尺寸变更、定位方式等，都会引起内部、周围、整个页面的重新渲染。通常无法预估页面哪部分会回流，它们都彼此相互影响着。频繁回流会影响性能。","categories":[{"name":"Web","slug":"Web","permalink":"https://chengshen.me/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://chengshen.me/tags/Web/"},{"name":"Dom","slug":"Dom","permalink":"https://chengshen.me/tags/Dom/"},{"name":"Dom Parsing","slug":"Dom-Parsing","permalink":"https://chengshen.me/tags/Dom-Parsing/"},{"name":"Dom Rendering","slug":"Dom-Rendering","permalink":"https://chengshen.me/tags/Dom-Rendering/"}]},{"title":"HTML 块级格式化上下文","slug":"web/HTML-block-formatting-context","date":"2023-02-14T11:53:32.000Z","updated":"2023-02-15T11:53:42.715Z","comments":true,"path":"/web/HTML-block-formatting-context.html","link":"","permalink":"https://chengshen.me/web/HTML-block-formatting-context","excerpt":"","text":"概念一个块级格式化上下文（Block Formatting Context），包含该上下文元素的所有直接子元素，但是不包括子元素的子元素。 案例123456&lt;div class=&quot;box-a&quot; id=&quot;bfc1&quot;&gt; &lt;div class=&quot;box-b&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box-c&quot; id=&quot;bfc2&quot;&gt; &lt;div class=&quot;box-d&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; #bfc1 的 BFC 指的是 .box-b 和 .box-c；#bfc2 的 BFC 指的是 .box-d； 特点 每一个 BFC 区域只包括其子元素，不包括其子元素的子元素； 每一个 BFC 区域都是独立隔绝的，互不影响！ 三种布局 标准流（normal） 浮动流（float） 定位流（position） 触发 BFC body 根元素； 设置 float，不包括 none； 设置 position，包括 absoulte、fixed； 设置 display 为 inline-block； 设置 overflow，包括 hidden、auto、scroll； 表格单元格，table-cell； 弹性布局，flex； BFC 实际应用兄弟 div margin 重叠问题描述：文档中相邻 div 元素，上下分布，但两者 margin 默认会重叠。解决思路：将相邻兄弟变成非相邻同级：把这两兄弟元素各用 div 包裹，触发包裹元素的 bfc。 父子 div margin 重叠问题描述：文档中父子 div 元素，子 div margin-top 会让父子 div 同时下移。解决思路：触发父级 bfc、父级设置边框。 清除浮动影响问题描述：父元素没设置高度，包含一个子元素，子元素设置浮动，父元素会高度塌陷。","categories":[{"name":"HTML","slug":"HTML","permalink":"https://chengshen.me/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://chengshen.me/tags/HTML/"},{"name":"BFC","slug":"BFC","permalink":"https://chengshen.me/tags/BFC/"}]},{"title":"CSS transform、transition、animation","slug":"css/CSS-transform-transition-animation","date":"2023-02-14T11:41:16.000Z","updated":"2023-02-15T11:53:42.714Z","comments":true,"path":"/css/CSS-transform-transition-animation.html","link":"","permalink":"https://chengshen.me/css/CSS-transform-transition-animation","excerpt":"","text":"transformtransform: [转换函数];转换函数：translate、scale、rotate、skew。transform 只影响当前元素，不影响文档流。 12transform: translateX(1px);transform: translateY(2px); 特性参考：https://www.bilibili.com/video/BV1L3411C76T 变换后盒子模型占据的尺寸和位置不会变换； 变换后会创建层叠上下文； 对内联元素无效； 不同顺序效果不同； 锯齿或虚化问题； transition改变目标元素的样式：颜色、外观、尺寸，一般搭配伪类。transition 尺寸变更会对文档流产生影响。 12345678.box &#123; width: 10px; transition: width 0.4s ease;&#125;.box:hover &#123; width: 50px;&#125; 或者用 JavaScript 改变元素属性触发 transition 12345678910.box &#123; width: 100px; height: 100px; background-color: blueviolet; transition: width 1s linear 0.5s;&#125;.box1 &#123; width: 400px;&#125; 1document.querySelector(&#x27;.box&#x27;).classList.add(&#x27;box1&#x27;); 局限性 transition 需要触发，没法在网页加载时自动发生。 transition 是一次性的，不能重复发生，除非一再触发。 transition 只能定义开始状态和结束状态，不能定义中间状态。 一条 transition 规则，只能定义一个属性的变化，不能涉及多个属性。 animationtransition 不够用的时候，可以使用 animation。animation 搭配 @keyframes 使用，无需搭配伪类，页面加载 animation 就自动开始了。 123456789101112131415161718192021.animation1 &#123; /* forwards：动画结束时，就停在最终状态 */ animation: changeAnimation 1s ease forwards;&#125;.animation2 &#123; /* infinite alternate：无限循环 + 往复 */ animation: changeAnimation 1s ease infinite alternate;&#125;@keyframes changeAnimation &#123; 0% &#123; width: 110px; &#125; 50% &#123; width: 140px; &#125; 100% &#123; width: 200px; &#125;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://chengshen.me/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://chengshen.me/tags/CSS/"},{"name":"transform","slug":"transform","permalink":"https://chengshen.me/tags/transform/"},{"name":"transition","slug":"transition","permalink":"https://chengshen.me/tags/transition/"},{"name":"animation","slug":"animation","permalink":"https://chengshen.me/tags/animation/"}]},{"title":"CSS 伪类和伪元素","slug":"css/CSS-pseudo-classes-and-pseudo-elements","date":"2023-02-14T09:35:15.000Z","updated":"2023-02-15T11:53:42.714Z","comments":true,"path":"/css/CSS-pseudo-classes-and-pseudo-elements.html","link":"","permalink":"https://chengshen.me/css/CSS-pseudo-classes-and-pseudo-elements","excerpt":"","text":"伪类功能和 class 有些类似，但它是基于文档之外的抽象，所以叫伪类。 :link、:visited、:hover、:active、:focus、:right、:left、:first、:lang、:first-child 伪元素伪元素是 DOM 树没有定义的虚拟元素。 ::before、::after、::selection","categories":[{"name":"CSS","slug":"CSS","permalink":"https://chengshen.me/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://chengshen.me/tags/CSS/"}]},{"title":"CSS 选择第二个以及后续元素","slug":"css/CSS-select-children-between-2nd-and-last","date":"2023-02-14T09:28:47.000Z","updated":"2023-02-15T11:53:42.714Z","comments":true,"path":"/css/CSS-select-children-between-2nd-and-last.html","link":"","permalink":"https://chengshen.me/css/CSS-select-children-between-2nd-and-last","excerpt":"","text":"元素如下，希望除了第一个子 div 不选择，其他子 div 都选择。 123456&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item item-1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item item-2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item item-3&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;item item-4&quot;&gt;4&lt;/div&gt;&lt;/div&gt; 方式一 12.item:nth-of-type(n + 2) &#123;&#125; 方式二 12.item:nth-child(n + 2) &#123;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://chengshen.me/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://chengshen.me/tags/CSS/"},{"name":"Selector","slug":"Selector","permalink":"https://chengshen.me/tags/Selector/"}]},{"title":"CSS 1像素线","slug":"css/CSS-1px-line","date":"2023-02-14T09:21:43.000Z","updated":"2023-02-15T11:53:42.713Z","comments":true,"path":"/css/CSS-1px-line.html","link":"","permalink":"https://chengshen.me/css/CSS-1px-line","excerpt":"","text":"场景移动端开发线条的 1 像素线绘制。 方式 用 0.5px transform scale box-shadow 模拟 图片 scale123456div &#123; height: 1px; display: block; transform: scale(1, 0.5); background-color: #000;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://chengshen.me/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://chengshen.me/tags/CSS/"},{"name":"CSS Tricks","slug":"CSS-Tricks","permalink":"https://chengshen.me/tags/CSS-Tricks/"}]},{"title":"JavaScript 深拷贝和浅拷贝","slug":"web/javascript/JavaScript-deep-clone-and-shallow-clone","date":"2023-02-14T09:08:52.000Z","updated":"2023-02-15T11:53:42.719Z","comments":true,"path":"/web/javascript/JavaScript-deep-clone-and-shallow-clone.html","link":"","permalink":"https://chengshen.me/web/javascript/JavaScript-deep-clone-and-shallow-clone","excerpt":"","text":"定义浅拷贝：复制一层数据，基本类型直接复制，对象类型复制引用。深拷贝：会递归复制。 浅拷贝 扩展运算符(...) Object.assign 深拷贝 JSON.parse(JSON.stringify()) 遍历递归 JSON 化问题 正则变成空对象(&#123;&#125;)； 函数直接丢； 日期变成时间字符串(无解)； 构造函数丢失，变成 Object； 循环引用无法正确处理； 遍历深拷贝版本一 12345678910111213141516171819202122function deepClone(obj, hash = new WeakMap()) &#123; // 处理null或者undefined if (obj === null) return obj; // 处理日期类型 if (obj instanceof Date) return new Date(obj); // 处理正则类型 if (obj instanceof RegExp) return new RegExp(obj); // 普通值或函数不需要深拷贝 if (typeof obj !== &quot;object&quot;) return obj; // 对象进行深拷贝 if (hash.get(obj)) return hash.get(obj); let cloneObj = new obj.constructor(); // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身 hash.set(obj, cloneObj); for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; // 实现一个递归拷贝 cloneObj[key] = deepClone(obj[key], hash); &#125; &#125; return cloneObj;&#125; 版本二 1234567891011121314151617181920212223242526272829303132const isComplexDataType = obj =&gt; (typeof obj === &#x27;object&#x27; || typeof obj === &#x27;function&#x27;) &amp;&amp; (obj !== null)const deepClone = function (obj, hash = new WeakMap()) &#123; if (obj.constructor === Date) &#123; // 日期对象直接返回一个新的日期对象 return new Date(obj); &#125; if (obj.constructor === RegExp) &#123; // 正则对象直接返回一个新的正则对象 return new RegExp(obj); &#125; if (hash.has(obj)) &#123; // 如果循环引用了就用 weakMap 来解决 return hash.get(obj); &#125; let allDescriptors = Object.getOwnPropertyDescriptors(obj); // 遍历传入参数所有键的特性 let cloneObj = Object.create(Object.getPrototypeOf(obj), allDescriptors); // 继承原型链 hash.set(obj, cloneObj) for (let key of Reflect.ownKeys(obj)) &#123; cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; typeof obj[key] !== &#x27;function&#x27;) ? deepClone(obj[key], hash) : obj[key]; &#125; return cloneObj&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/tags/JavaScript/"},{"name":"Deep Clone","slug":"Deep-Clone","permalink":"https://chengshen.me/tags/Deep-Clone/"}]},{"title":"JavaScript 模块化","slug":"web/javascript/JavaScript-module","date":"2023-02-14T08:57:11.000Z","updated":"2023-02-15T11:53:42.721Z","comments":true,"path":"/web/javascript/JavaScript-module.html","link":"","permalink":"https://chengshen.me/web/javascript/JavaScript-module","excerpt":"","text":"种类 AMD&#x2F;CMD CommonJS(适用于服务端) UMD ESM(EcmaScript Module) AMD&#x2F;CMDAMD：Asynchronous Module Definition，异步模块定义。CMD：Common Module Definition，通用模块定义。相对于 CommonJS，定义了适用于浏览器端的规范。AMD 中有 requirejs，CMD 中有 seajs。用 define 方法来定义一个模块，通过前置依赖列表导入外部模块数据。 CommonJSnodejs 模块化采用的是 CommonJS。module.exports 或 exports 导出，require 导入。CommonJS 规范一些特性：文件系统，同步加载等，不适用于浏览器端，适用于服务端。 UMDUMD：Universal Module Definition，通用模块定义不属于一套模块规范，主要用来处理 CommonJS、AMD、CMD 的差异兼容，使模块代码能在前面不同的模块环境下都能正常运行。 ESMJavaScript 在 ES6 开始引入模块概念：ES Module。export default 或 export 导出，import 导入。动态导入 import() 返回 promise。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/tags/JavaScript/"},{"name":"Module","slug":"Module","permalink":"https://chengshen.me/tags/Module/"}]},{"title":"JavaScript 继承","slug":"web/javascript/JavaScript-inherit","date":"2023-02-14T08:44:17.000Z","updated":"2023-02-15T11:53:42.720Z","comments":true,"path":"/web/javascript/JavaScript-inherit.html","link":"","permalink":"https://chengshen.me/web/javascript/JavaScript-inherit","excerpt":"","text":"ES6 继承12class Parent &#123; &#125;class Child extends Parent &#123; &#125; 寄生组合式继承123456789101112131415161718192021222324function clone(parent, child) &#123; // 该操作将 Parent 原型中属性方法等带到 Child child.prototype = Object.create(parent.prototype); child.prototype.constructor = child;&#125;function Parent() &#123; this.name = &quot;parent&quot;; this.play = [1, 2, 3];&#125;Parent.prototype.getName = function() &#123; return this.name; &#125;;function Child() &#123; // 该 call 操作会将 Parent 自身的属性字段带到 Child Parent.call(this); this.friends = &quot;child&quot;;&#125;clone(Parent, Child);Child.prototype.getFriends = function() &#123; return this.friends;&#125;;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/tags/JavaScript/"},{"name":"Inherit","slug":"Inherit","permalink":"https://chengshen.me/tags/Inherit/"}]},{"title":"JavaScript 词法作用域和动态作用域","slug":"web/javascript/JavaScript-lexical-scope-and-dynamic-scope","date":"2023-02-13T13:40:43.000Z","updated":"2023-02-15T11:53:42.720Z","comments":true,"path":"/web/javascript/JavaScript-lexical-scope-and-dynamic-scope.html","link":"","permalink":"https://chengshen.me/web/javascript/JavaScript-lexical-scope-and-dynamic-scope","excerpt":"","text":"说明JavaScript 中，变量采用的是词法作用域。 词法作用域&#x2F;静态作用域作用域在变量定义时就确定。 动态作用域作用域在变量使用时才确定。 验证123456789101112var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar(); 这里 bar 中 foo 的 value 输出为 1，说明变量在函数定义时就确定了，属于词法作用域。如果是动态作用域，bar 中 foo 的 value 值就应当等于 2。 问题问：this 是动态作用域吗？答：不是。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"https://chengshen.me/tags/Function/"}]},{"title":"JavaScript 闭包","slug":"web/javascript/JavaScript-closure","date":"2023-02-13T13:15:30.000Z","updated":"2023-02-15T11:53:42.718Z","comments":true,"path":"/web/javascript/JavaScript-closure.html","link":"","permalink":"https://chengshen.me/web/javascript/JavaScript-closure","excerpt":"","text":"定义闭包是一个特殊的函数，能够记录自己词法作用域内变量的状态，可以读取该作用域内的变量，在函数或语句块结束后，变量仍然对引用它的函数有效。在一个函数中返回函数或者作为回调，这样创建了闭包。当基于参数创建回调，参数必须在闭包中存储（比如：形参存储），否则就会创建一个闭包指向封闭环境中的变量，而这个变量可能会变。 场景一，返回函数123456var add = (function () &#123; var counter = 0; return function () &#123; return counter += 1; &#125;&#125;)();add(); 场景二，作为回调123456for (var i = 0; i &lt; 5; i++) &#123; (function clo(ii) &#123; // 形参 ii 对 i 进行了存储 setTimeout(function() &#123; console.log(ii); &#125;, 20); &#125;)(i);&#125; 或者 1234567// 需要浏览器版本 &gt; IE9for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function(ii) &#123; // 形参 ii 对 i 进行了存储 console.log(ii); &#125;, 20, i);&#125; 用途封装变量：闭包可以隐藏内部变量，使得代码变得更加简洁；模拟私有变量：闭包可以模拟私有变量，使得变量不被外部访问；实现回调函数：闭包可以作为回调函数传递给其他函数，以实现延迟执行；实现单例模式：闭包可以保证一个类型仅有一个实例；构建命名空间：闭包可以构建命名空间，使得变量名不冲突； 注意参数未在闭包中存储，就会创建一个闭包指向封闭环境中的变量，这变量会变。 123456for(var i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; // 未对变量 i 进行存储 console.log(&#x27;i is &#x27; + i); &#125;, 10);&#125; 这里参数未在闭包中存储，运行中 i 会变，最终 i 变成 10，输出 10 次 i is 10。类似的有 setTimeout、setInterval、eval() 等。 问题问：闭包一定需要 return 吗答：不一定，上面所示的场景二也是闭包，就不涉及 return。 参考https://creeperyang.github.io/2015/01/JavaScript-dynamic-scope-vs-static-scope/","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/tags/JavaScript/"},{"name":"Closure","slug":"Closure","permalink":"https://chengshen.me/tags/Closure/"}]},{"title":"JavaScript apply、bind、call","slug":"web/javascript/JavaScript-apply-bind-call","date":"2023-02-13T12:53:10.000Z","updated":"2023-02-15T11:53:42.717Z","comments":true,"path":"/web/javascript/JavaScript-apply-bind-call.html","link":"","permalink":"https://chengshen.me/web/javascript/JavaScript-apply-bind-call","excerpt":"","text":"用途apply、bind、call 用来改变函数内 this 指向 用法123func.apply(this, [arg1, arg2 [,...]])func.bind(this, arg1, arg2 [,...])func.call(this, arg1, arg2 [,...]) 区别 分类 说明 apply 参数数组形式传，并调用对应函数 bind 参数一个一个传，返回一个函数 call 参数一个一个传，并调用对应函数 问题问：一个方法连续 bind 多次，结果如何？答：只有第一次 bind 有效果。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"https://chengshen.me/tags/Function/"}]},{"title":"JavaScript 防抖和节流","slug":"web/javascript/JavaScript-debouncing-and-throttling","date":"2023-02-13T12:35:59.000Z","updated":"2023-02-15T11:53:42.718Z","comments":true,"path":"/web/javascript/JavaScript-debouncing-and-throttling.html","link":"","permalink":"https://chengshen.me/web/javascript/JavaScript-debouncing-and-throttling","excerpt":"","text":"意义节流和防抖是 JavaScript 中常用的性能优化手段，用途主要是在高频率的事件触发时，如鼠标移动、滚动事件、输入事件等，避免因频繁调用而导致性能下降。 应用页面滚动时需要请求数据，可以使用节流限制请求频率。验证用户输入是否合法，此时可以使用防抖避免频繁验证。 节流节流（throttling）是指在一段时间内，只让一个函数有限次执行。它通常用来限制函数在一段时间内的最大调用次数，从而防止对性能造成过大的影响。 1234567891011function throttle(fn, interval) &#123; let canRun = true; return function () &#123; if (!canRun) return; canRun = false; setTimeout(() =&gt; &#123; fn.apply(this, arguments); canRun = true; &#125;, interval); &#125;;&#125; 防抖防抖（debouncing）是指在一段时间内，等待事件停止触发后才执行一次函数。它通常用来限制事件触发的频率，从而防止对性能造成过大的影响。 123456789function debounce(fn, interval) &#123; let timeout; return function () &#123; clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, interval); &#125;;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/tags/JavaScript/"},{"name":"Closure","slug":"Closure","permalink":"https://chengshen.me/tags/Closure/"},{"name":"Performance Optimization","slug":"Performance-Optimization","permalink":"https://chengshen.me/tags/Performance-Optimization/"}]},{"title":"JavaScript 函数","slug":"web/javascript/JavaScript-function","date":"2023-02-13T12:00:45.000Z","updated":"2023-02-15T11:53:42.720Z","comments":true,"path":"/web/javascript/JavaScript-function.html","link":"","permalink":"https://chengshen.me/web/javascript/JavaScript-function","excerpt":"","text":"函数定义一般形式1function functionName(parameters) &#123; &#125; 表达式形式1var functionName = function (parameters) &#123; &#125;; 箭头函数形式1(parameters) =&gt; &#123; &#125; 提升（Hoisting）提升特性让函数可以在声明之前调用，使用表达式定义函数时，无法提升。 12myFunction(5);function myFunction(y) &#123; return y * y; &#125; 自调用函数12(function()&#123; &#125;)();(()=&gt;&#123; &#125;)(); 箭头函数特点 不能做构造函数，不能 new 没有 arguments，可用剩余参数代替 没有自己的 this，this 取决于箭头函数所在上下文 apply、bind、call 无法影响 this 指向 没有原型属性 不能作为 Generator 函数，不能使用 yield","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"https://chengshen.me/tags/Function/"}]},{"title":"JavaScript this","slug":"web/javascript/JavaScript-this","date":"2023-02-13T11:54:25.000Z","updated":"2023-02-15T11:53:42.721Z","comments":true,"path":"/web/javascript/JavaScript-this.html","link":"","permalink":"https://chengshen.me/web/javascript/JavaScript-this","excerpt":"","text":"普通函数普通函数中的 this 是根据运行时上下文动态确定的，this 指向函数运行时所在上下文。 123456let obj = &#123; name: &quot;san&quot;, func: function () &#123; console.log(`name is $&#123;this.name&#125;`); // name is san &#125;&#125;; 箭头函数箭头函数的中 this 在非运行期间就确定了，箭头函数的 this 和外层函数的 this 一致。 1234567891011let name = &#x27;win&#x27;;let obj = &#123; name: &#x27;san&#x27;, funcA: function () &#123; (() =&gt; console.log(`name is $&#123;this.name&#125;`))(); // name is san &#125;, funcB: () =&gt; &#123; // 这里箭头函数是 obj 下定义的，外层没有函数包裹，就会找到最外层的 window 对象上 console.log(`name is $&#123;this.name&#125;`); // name is win &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/tags/JavaScript/"},{"name":"Function","slug":"Function","permalink":"https://chengshen.me/tags/Function/"}]},{"title":"JavaScript 事件循环","slug":"web/javascript/JavaScript-event-loop","date":"2023-02-13T08:30:17.000Z","updated":"2023-02-16T14:27:40.540Z","comments":true,"path":"/web/javascript/JavaScript-event-loop.html","link":"","permalink":"https://chengshen.me/web/javascript/JavaScript-event-loop","excerpt":"","text":"关键词宏任务 &amp; 微任务 意义让 JavaScript 在单线程环境中处理异步操作，不阻塞主线程，保证程序的流畅性，如：用户输入、网络请求、动画等。 细分宏任务：IO、setTimeout、setInterval；微任务：Promise、process.nextTick、MutationObserver； 浏览器环境 同步代码 一个宏任务 全部微任务 + 新产生的微任务 一个宏任务 全部微任务 + 新产生的微任务 … Node.js 环境 阶段 说明 timers 执行 setTimeout、setInterval 回调 pending callbacks 执行上一轮循环少数未执行的 I&#x2F;O 回调 idle, prepare 仅 node 内部使用 poll 执行 timers、setImmediate、close 之外的大部分回调，如网络连接 check 执行 setImmediate 回调 close callbacks 执行 socket.close 回调 环境差异 浏览器中，微任务在宏任务之后执行； Node.js 中，微任务在各阶段之间执行：一个阶段执行完毕，就去执行微任务。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/tags/JavaScript/"},{"name":"Event Loop","slug":"Event-Loop","permalink":"https://chengshen.me/tags/Event-Loop/"}]},{"title":"ECMAScript 版本与特性","slug":"web/javascript/ECMAScript-features","date":"2023-02-13T06:44:00.000Z","updated":"2023-02-15T11:53:42.717Z","comments":true,"path":"/web/javascript/ECMAScript-features.html","link":"","permalink":"https://chengshen.me/web/javascript/ECMAScript-features","excerpt":"","text":"ES6&#x2F;ES2015 类 Set Map Proxy 模块化 Promise 箭头函数 解构赋值 模板字符串 展开操作符 let 与 const 对象属性简写 函数参数默认值 ES7&#x2F;ES2016 指数运算符(**) Array.prototype.includes() ES8&#x2F;ES2017 async &amp; await Object.values() Object.entries() padStart() &amp; padEnd() 函数参数列表结尾允许逗号 Object.getOwnPropertyDescriptors() ShareArrayBuffer &amp; Atomics 共享内存读写 ES9&#x2F;ES2018 异步迭代 Promise.finally() Rest &amp; Spread 属性 正则表达式 dotAll 模式 正则表达式 Unicode 转义 非转义序列的模板字符串 正则表达式反向断言(lookbehind) 正则表达式命名捕获组(Regular ExpressionNamed Capture Groups) ES10&#x2F;ES2019 可选的 catch 参数 Object.fromEntries() JSON.stringify() 优化 私有的实例方法和访问器 Symbol.prototype.description Array.flat() &amp; Array.flatMap() Array.Sort 中 QuickSort 换成 TimSort String.trimStart() &amp; String.trimEnd() Function.toString() 会保留空格、换行、注释等 ES11&#x2F;ES2020 BigInt import() globalThis nullish: ?? for-in 顺序标准化 String.matchAll() optional chaining: ? ES12&#x2F;ES2021 WeakRef 数字分隔符 Promise.any() ??=, &amp;&amp;=, ||= AggregateError String.replaceAll() FinalizationRegistry 优化 Array.prototype.sort ES13&#x2F;ES2022 top-level await Object.hasOwn public &amp; private(#fieldname) 成员修饰符","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/categories/JavaScript/"}],"tags":[{"name":"Features","slug":"Features","permalink":"https://chengshen.me/tags/Features/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/tags/JavaScript/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://chengshen.me/tags/ECMAScript/"}]},{"title":"JavaScript 数据类型","slug":"web/javascript/JavaScript-data-types","date":"2023-02-08T05:52:29.000Z","updated":"2023-02-15T11:53:42.718Z","comments":true,"path":"/web/javascript/JavaScript-data-types.html","link":"","permalink":"https://chengshen.me/web/javascript/JavaScript-data-types","excerpt":"","text":"JavaScript 中： 数据类型：number、string、boolean、null、undefined、symbol、bigint、object 基本数据类型：number、string、boolean、null、undefined、symbol、bigint 引用数据类型：object 基本数据类型的特性是值无法修改，比如：修改字符串会得到一个新的字符串。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/tags/JavaScript/"},{"name":"Data Types","slug":"Data-Types","permalink":"https://chengshen.me/tags/Data-Types/"}]}],"categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/categories/MySQL/"},{"name":"EntityFramework","slug":"EntityFramework","permalink":"https://chengshen.me/categories/EntityFramework/"},{"name":"NETCore","slug":"NETCore","permalink":"https://chengshen.me/categories/NETCore/"},{"name":"hello world","slug":"hello-world","permalink":"https://chengshen.me/categories/hello-world/"},{"name":"CLR","slug":"CLR","permalink":"https://chengshen.me/categories/CLR/"},{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/categories/CSharp/"},{"name":"HTML","slug":"HTML","permalink":"https://chengshen.me/categories/HTML/"},{"name":"Web","slug":"Web","permalink":"https://chengshen.me/categories/Web/"},{"name":"CSS","slug":"CSS","permalink":"https://chengshen.me/categories/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/categories/JavaScript/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://chengshen.me/tags/MySQL/"},{"name":"Slow Query","slug":"Slow-Query","permalink":"https://chengshen.me/tags/Slow-Query/"},{"name":"MVCC","slug":"MVCC","permalink":"https://chengshen.me/tags/MVCC/"},{"name":"Procedure","slug":"Procedure","permalink":"https://chengshen.me/tags/Procedure/"},{"name":"Explain","slug":"Explain","permalink":"https://chengshen.me/tags/Explain/"},{"name":"Isolation Level","slug":"Isolation-Level","permalink":"https://chengshen.me/tags/Isolation-Level/"},{"name":"binlog","slug":"binlog","permalink":"https://chengshen.me/tags/binlog/"},{"name":"Transaction","slug":"Transaction","permalink":"https://chengshen.me/tags/Transaction/"},{"name":"Database Index","slug":"Database-Index","permalink":"https://chengshen.me/tags/Database-Index/"},{"name":"Database Engine","slug":"Database-Engine","permalink":"https://chengshen.me/tags/Database-Engine/"},{"name":"CSharp","slug":"CSharp","permalink":"https://chengshen.me/tags/CSharp/"},{"name":"EntityFramework","slug":"EntityFramework","permalink":"https://chengshen.me/tags/EntityFramework/"},{"name":"ADO.NET","slug":"ADO-NET","permalink":"https://chengshen.me/tags/ADO-NET/"},{"name":"Interceptor","slug":"Interceptor","permalink":"https://chengshen.me/tags/Interceptor/"},{"name":"SQL","slug":"SQL","permalink":"https://chengshen.me/tags/SQL/"},{"name":"Fluent API","slug":"Fluent-API","permalink":"https://chengshen.me/tags/Fluent-API/"},{"name":"NETCore","slug":"NETCore","permalink":"https://chengshen.me/tags/NETCore/"},{"name":"Design Patten","slug":"Design-Patten","permalink":"https://chengshen.me/tags/Design-Patten/"},{"name":"OAuth","slug":"OAuth","permalink":"https://chengshen.me/tags/OAuth/"},{"name":"OIDC","slug":"OIDC","permalink":"https://chengshen.me/tags/OIDC/"},{"name":"IOC","slug":"IOC","permalink":"https://chengshen.me/tags/IOC/"},{"name":"Pipeline","slug":"Pipeline","permalink":"https://chengshen.me/tags/Pipeline/"},{"name":"hello world","slug":"hello-world","permalink":"https://chengshen.me/tags/hello-world/"},{"name":"CLR","slug":"CLR","permalink":"https://chengshen.me/tags/CLR/"},{"name":"Thread Synchronization","slug":"Thread-Synchronization","permalink":"https://chengshen.me/tags/Thread-Synchronization/"},{"name":"LINQ","slug":"LINQ","permalink":"https://chengshen.me/tags/LINQ/"},{"name":"Asynchronous","slug":"Asynchronous","permalink":"https://chengshen.me/tags/Asynchronous/"},{"name":"Synchronous","slug":"Synchronous","permalink":"https://chengshen.me/tags/Synchronous/"},{"name":"Task","slug":"Task","permalink":"https://chengshen.me/tags/Task/"},{"name":"async/await","slug":"async-await","permalink":"https://chengshen.me/tags/async-await/"},{"name":"Delegate","slug":"Delegate","permalink":"https://chengshen.me/tags/Delegate/"},{"name":"Event","slug":"Event","permalink":"https://chengshen.me/tags/Event/"},{"name":"Dispose","slug":"Dispose","permalink":"https://chengshen.me/tags/Dispose/"},{"name":".NET","slug":"NET","permalink":"https://chengshen.me/tags/NET/"},{"name":"Features","slug":"Features","permalink":"https://chengshen.me/tags/Features/"},{"name":"HTML","slug":"HTML","permalink":"https://chengshen.me/tags/HTML/"},{"name":"Web","slug":"Web","permalink":"https://chengshen.me/tags/Web/"},{"name":"Request","slug":"Request","permalink":"https://chengshen.me/tags/Request/"},{"name":"Dom","slug":"Dom","permalink":"https://chengshen.me/tags/Dom/"},{"name":"Dom Parsing","slug":"Dom-Parsing","permalink":"https://chengshen.me/tags/Dom-Parsing/"},{"name":"Dom Rendering","slug":"Dom-Rendering","permalink":"https://chengshen.me/tags/Dom-Rendering/"},{"name":"BFC","slug":"BFC","permalink":"https://chengshen.me/tags/BFC/"},{"name":"CSS","slug":"CSS","permalink":"https://chengshen.me/tags/CSS/"},{"name":"transform","slug":"transform","permalink":"https://chengshen.me/tags/transform/"},{"name":"transition","slug":"transition","permalink":"https://chengshen.me/tags/transition/"},{"name":"animation","slug":"animation","permalink":"https://chengshen.me/tags/animation/"},{"name":"Selector","slug":"Selector","permalink":"https://chengshen.me/tags/Selector/"},{"name":"CSS Tricks","slug":"CSS-Tricks","permalink":"https://chengshen.me/tags/CSS-Tricks/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://chengshen.me/tags/JavaScript/"},{"name":"Deep Clone","slug":"Deep-Clone","permalink":"https://chengshen.me/tags/Deep-Clone/"},{"name":"Module","slug":"Module","permalink":"https://chengshen.me/tags/Module/"},{"name":"Inherit","slug":"Inherit","permalink":"https://chengshen.me/tags/Inherit/"},{"name":"Function","slug":"Function","permalink":"https://chengshen.me/tags/Function/"},{"name":"Closure","slug":"Closure","permalink":"https://chengshen.me/tags/Closure/"},{"name":"Performance Optimization","slug":"Performance-Optimization","permalink":"https://chengshen.me/tags/Performance-Optimization/"},{"name":"Event Loop","slug":"Event-Loop","permalink":"https://chengshen.me/tags/Event-Loop/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://chengshen.me/tags/ECMAScript/"},{"name":"Data Types","slug":"Data-Types","permalink":"https://chengshen.me/tags/Data-Types/"}]}