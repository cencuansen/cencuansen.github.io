<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

<meta name="author" content="SanHuo">


<meta name="subtitle" content="纤凝翠薇巅，扶光入沧渊，扶摇惊砂起，山弄望舒远">


<meta name="description" content="SanHuo的全栈藏经阁">


<meta name="keywords" content="JavaScript,csharp,c#,.NET,.NET Core,MySQL">


<title>
  SanHuo
</title>



<link rel="icon" href="/image/avatar-main.jpeg">




<!-- stylesheets list from _config.yml -->

<link rel="stylesheet" href="/css/style.css">

<link rel="stylesheet" href="/css/codeOps.css">




<!-- scripts list from _config.yml -->

<script src="/js/script.js"></script>

<script src="/js/tocbot.min.js"></script>

<script src="/js/clipboard.js"></script>

<script src="/js/codeOps.js"></script>









<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="SanHuo" type="application/atom+xml">
</head>

<body>
  <script>
    // this function is used to check current theme before page loaded.
    (() => {
      const currentTheme = window.localStorage && window.localStorage.getItem('theme') || 'dark';
      const isDark = currentTheme === 'dark';
      const pagebody = document.getElementsByTagName('body')[0]
      const mobileToggleTheme = document.getElementById("mobile-toggle-theme");
      if (isDark) {
        pagebody.classList.add('dark-theme');
        // mobile
        mobileToggleTheme && (document.getElementById("mobile-toggle-theme").innerText = "🌙");
      } else {
        pagebody.classList.remove('dark-theme');
        // mobile
        mobileToggleTheme && (document.getElementById("mobile-toggle-theme").innerText = "☀️");
      }
    })();
  </script>

  <div class="wrapper">
    <header>
  <nav class="navbar">
    <div class="container">
      <div class="navbar-header header-logo"><a href="/">
          首页
        </a></div>
      <div class="menu navbar-right">
        
        <a class="menu-item" href="/categories">
          分类
        </a>
        
        <a class="menu-item" href="/tags">
          标签
        </a>
        
        <input id="switch_default" type="checkbox" checked class="switch_default">
        <label for="switch_default" class="toggleBtn"></label>
      </div>
    </div>
  </nav>

  
  <nav class="navbar-mobile" id="nav-mobile">
    <div class="container">
      <div class="navbar-header">
        <div>
          <a href="/">首页</a>
          <a id="mobile-toggle-theme">☀️</a>
        </div>
        <div class="menu-toggle" onclick="mobileBtn()">&#9776; 菜单</div>
      </div>
      <div class="menu" id="mobile-menu">
        
        <a class="menu-item" href="/categories">分类</a>
        
        <a class="menu-item" href="/tags">标签</a>
        
      </div>
    </div>
  </nav>

</header>
<script>
  var mobileBtn = function f() {
    var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
    var mobileMenu = document.getElementById("mobile-menu");
    if (toggleMenu.classList.contains("active")) {
      toggleMenu.classList.remove("active")
      mobileMenu.classList.remove("active")
    } else {
      toggleMenu.classList.add("active")
      mobileMenu.classList.add("active")
    }
  }
</script>
    <div class="main">
      
<div class="container">
  
  
  <div class="post-toc">
  <div class="tocbot-list"></div>
  <div class="tocbot-list-menu">
    <!-- <a class="tocbot-toc-expand" onclick="expand_toc()">+ 展开</a> -->
    <a onclick="go_top()">↑ 顶部</a>
    <a onclick="go_bottom()">↓ 底部</a>
  </div>
</div>

<script>
  // tocbot: https://github.com/tscanlin/tocbot
  var tocbot_timer;
  var DEPTH_MAX = 6; // 为 6 时展开所有
  var tocbot_default_config = {
    // Where to render the table of contents.
    tocSelector: '.tocbot-list',
    // // Where to grab the headings to build the table of contents.
    contentSelector: '.post-content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    // 0: collapse them all; 6: expand all
    collapseDepth: 0,
    orderedList: false,
    scrollSmooth: true,
    isCollapsedClass: 'is-collapsed',
    onClick: () => {} // extend_click,
  };

  function extend_click() {
    clearTimeout(tocbot_timer);
    tocbot_timer = setTimeout(function() {
      tocbot.refresh(obj_merge(tocbot_default_config, {
        hasInnerContainers: false
      }));
    }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
  }

  document.ready(function() {
    tocbot.init(obj_merge(tocbot_default_config));
  });

  function expand_toc() {
    var expandButton = document.querySelector('.tocbot-toc-expand');
    var expanded = expandButton.getAttribute('data-expanded');
    expanded ? expandButton.removeAttribute('data-expanded') : expandButton.setAttribute('data-expanded', true);
    // tocbot.refresh(obj_merge(tocbot_default_config, {
    //   collapseDepth: expanded ? 0 : DEPTH_MAX
    // }));
    expandButton.innerText = expanded ? '+ 展开' : '× 关闭';
  }

  function go_top() {
    window.scrollTo(0, 0);
  }

  function go_bottom() {
    window.scrollTo(0, document.body.scrollHeight);
  }

  function obj_merge(target, source) {
    for (var item in source) {
      if (source.hasOwnProperty(item)) {
        target[item] = source[item];
      }
    }
    return target;
  }
</script>
  

  
  <article class="post-wrap">
    <header class="post-header">
      <h1 class="post-title">
        CSharp 基础知识
      </h1>
      
      <div class="post-meta">
        

        
        <span class="post-time">
          日期：<a href="#">
            2023年 02月
            <!-- &nbsp;&nbsp;22:49:07 -->
          </a>
        </span>
        
        
        <span class="post-category">
          &nbsp;&nbsp;
          分类：
          <a href="/categories/CSharp/">CSharp</a>
          
        </span>
        
      </div>
      
      <section class="post-tags">
        <div style="text-align: left;">
          <span>标签：</span>
          <span class="tag" style>
            
            
            <a href="/tags/CSharp/"># CSharp</a>
            
            
          </span>
        </div>
        <div style="text-align: right; min-width: 50px;">
          <a href="javascript:window.history.back();"> ← 返回</a>
          <!-- <span>&nbsp;|&nbsp;</span>
          <a href="/">返回主页</a> -->
        </div>
      </section>
    </header>

    <div class="post-content">
      <h1 id="string-Empty、-“”-、-null。"><a href="#string-Empty、-“”-、-null。" class="headerlink" title="string.Empty、 “” 、 null。"></a>string.Empty、 “” 、 null。</h1><p>Empty 是 string 类中的一个静态的只读字段。<br>string.Empty 和 “” 是一样的。<br>string str &#x3D; null 表示 str 未指向任何对象。</p>
<h1 id="string-和-StringBuilder"><a href="#string-和-StringBuilder" class="headerlink" title="string 和 StringBuilder"></a>string 和 StringBuilder</h1><p>string 是不可变对象，string 是 String 的别名，string 是 c#中的类，String 是 Framework 的类，编译器会把 string 编译成 String。<br>StringBuilder 为动态字符串。StringBuilder 当达到容量时，将自动分配新的空间且容量翻倍。</p>
<h1 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h1><p>向现有类型“添加”方法，无需派生、重新编译或修改原始类型。<br>扩展方法是一种静态类中的静态方法。<br>扩展方法第一个参数是 this 修饰的被扩展的类。</p>
<h1 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h1><p>装箱：值类型 -&gt; 引用类型 。<br>拆箱：引用类型 -&gt; 值类型。<br>一次装箱要分配内存（托管堆）和拷贝数据（从栈到托管堆）。<br>拆箱就是装箱的相反操作。</p>
<h1 id="更改已装箱的对象"><a href="#更改已装箱的对象" class="headerlink" title="更改已装箱的对象"></a>更改已装箱的对象</h1><p>已装箱的对象，无法直接调用其指定方法。<br>让类对象继承一个接口，借助接口方式来更改已装箱的对象中的数据。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISomeClass</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Change</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeClass</span> : <span class="title">ISomeClass</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span> x &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Change</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SomeClass some = <span class="keyword">new</span> SomeClass();</span><br><span class="line">some.x = <span class="number">100</span>;</span><br><span class="line">Object o = some; <span class="comment">// 装箱</span></span><br><span class="line">((SomeClass)o).Change(<span class="number">200</span>); <span class="comment">// 没改掉。</span></span><br><span class="line">((ISomeClass)o).Change(<span class="number">200</span>); <span class="comment">// 改掉了。</span></span><br></pre></td></tr></table></figure>

<h1 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h1><ul>
<li>运算符：创建对象实例。</li>
<li>修饰符：在派生类定义一个重名的方法，隐藏基类方法。</li>
<li>约束：泛型约束，表示泛型类型要有 public 修饰的无参构造。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ItemFactory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">IComparable</span>, <span class="title">new</span>()</span><br><span class="line">&#123;  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="new-和-override"><a href="#new-和-override" class="headerlink" title="new 和 override"></a>new 和 override</h1><p>new 和 override 都可用覆盖基类同名方法；<br>new 覆盖基类不完全，父类引用子类实例时，能调用到基类方法，override 覆盖基类是彻底的，一旦子类 override 基类方法后，就无法再调用基类同名方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">Say</span> ()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I am parent&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Child1</span> : <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">Say</span> ()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I am child1&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Child2</span> : <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">new</span> <span class="built_in">string</span> <span class="title">Say</span> ()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I am child2&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类引用子类实例</span></span><br><span class="line">Parent instance1 = <span class="keyword">new</span> Child1();</span><br><span class="line"><span class="comment">// I am child1</span></span><br><span class="line"><span class="built_in">string</span> who1 = instance1.Say();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类引用子类实例</span></span><br><span class="line">Parent instance2 = <span class="keyword">new</span> Child2();</span><br><span class="line"><span class="comment">// 注意，这里就能调用到基类方法，结果为：I am parent</span></span><br><span class="line"><span class="built_in">string</span> who1 = instance2.Say();</span><br></pre></td></tr></table></figure>

<h1 id="int-和-int"><a href="#int-和-int" class="headerlink" title="int? 和 int"></a>int? 和 int</h1><p>可空类型，默认值可以是 null。<br>int? 是通过 int 装箱为引用类型实现。<br><code>Nullable.GetUnderlyingType(typeof(int?)) != null</code> 用来判断类型是否是可空类型</p>
<h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>约定方法签名，来对方法进行引用，类似指针，方法能当参数传递给形参，用于事件、回调等。</p>
<h1 id="const-和-readonly"><a href="#const-和-readonly" class="headerlink" title="const 和 readonly"></a>const 和 readonly</h1><p>readonly 运行时常量。<br>const 编译时常量。<br>readonly 常量只能声明为类字段。<br>const 除了类字段，还可以声明为方法中的局部常量，默认为静态类型，不能用 static 修饰。</p>
<h1 id="CTS、CLS、CLR"><a href="#CTS、CLS、CLR" class="headerlink" title="CTS、CLS、CLR"></a>CTS、CLS、CLR</h1><p>CTS：通用类型系统；<br>CLS：通用语言规范；<br>CLR：公共语言运行库；</p>
<h1 id="using"><a href="#using" class="headerlink" title="using"></a>using</h1><ul>
<li>引用命名空间。</li>
<li>using 一个非托管资源（IDisposiable），用来释放资源。</li>
</ul>
<h1 id="托管资源、非托管资源"><a href="#托管资源、非托管资源" class="headerlink" title="托管资源、非托管资源"></a>托管资源、非托管资源</h1><p>托管资源指的是.NET 可以自动进行回收的资源，主要是指托管堆上分配的内存资源。<br>非托管资源指的是.NET 不知道如何回收的资源，最常见的是包装操作系统资源的对象，例如文件，窗口，网络连接，数据库连接，画刷，图标等。<br>建议通过调用 IDisposable.Dispose()方法来回收非托管资源。</p>
<h1 id="ref、out、in"><a href="#ref、out、in" class="headerlink" title="ref、out、in"></a>ref、out、in</h1><p>相同：都是按引用传递，形参成为实参的别名；<br>不同：ref 在方法外需初始化；out 需在方法内赋值；in 在方法内是只读的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  <span class="built_in">int</span> number = <span class="number">50</span>;</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;调用方法前 number 值：&quot;</span> + number);</span><br><span class="line">  RefFunction(<span class="keyword">ref</span> number);</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;调用方法后 number 值：&quot;</span> + number);</span><br><span class="line">  Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入的参数值是 50 ，方法中使用的 num 值也是 50</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RefFunction</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  num = num / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> number = <span class="number">50</span>;</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;调用方法前 number 值：&quot;</span> + number);</span><br><span class="line">  OutFunction(<span class="keyword">out</span> number);</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;调用方法后 number 值：&quot;</span> + number);</span><br><span class="line">  Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法将的参数值 50 传入 ，但是必须在方法中初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OutFunction</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  num = <span class="number">120</span>;</span><br><span class="line">  num = num / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="in-的意义"><a href="#in-的意义" class="headerlink" title="in 的意义"></a>in 的意义</h1><p>结构体实例数据分配在栈上，当需要将大数据量的结构体作为方法参数时，会复制一份该大结构体，成本有点高，使用 in 来按引用传递该大结构体，就能避免复制问题。</p>
<h1 id="ref、out、in-使用限制"><a href="#ref、out、in-使用限制" class="headerlink" title="ref、out、in 使用限制"></a>ref、out、in 使用限制</h1><p>async 修饰的异步方法中无法使用；<br>迭代器方法（含有 yield return 或 yield break 的方法）中无法使用；<br>扩展方法的第一个参数不能有 in 修饰符，除非该参数是结构体；<br>扩展方法的第一个参数，其中该参数是泛型类型（即使该类型被约束为结构体）；</p>
<h1 id="Equals-和-x3D-x3D"><a href="#Equals-和-x3D-x3D" class="headerlink" title="Equals 和 &#x3D;&#x3D;"></a>Equals 和 &#x3D;&#x3D;</h1><p>&#x3D;&#x3D; 值类型数据比较的是值，引用类型比较的是引用地址。<br>Equals 引用类型比较的是最终数据。</p>
<h1 id="as-和-is"><a href="#as-和-is" class="headerlink" title="as 和 is"></a>as 和 is</h1><p>is 判断对象是否兼容于某类型，返回 bool 值，永远不会抛出异常。<br>as 用于在兼容的引用类型之间执行转换。无法转换则为 null。<br>is 需要做两次对象的类型检查，而 as 需要做一次对象类型检查。</p>
<h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><p>public：共有的，访问不受限制；<br>private：私有的，只能在当前类中访问；<br>internal：内部的，只能在当前程序集中访问；<br>protected：受保护的，只能在当前类或其派生类中访问；<br>file：当前文件范围，C# 11 新增；<br>protected internal：受保护的内部成员，当前程序集或派生自包含类的类型可访问；<br>private protected：私有受保护的成员，当前程序集中的包含类或从包含类派生的类型可访问；<br>class 默认 internal，class member 默认 private。</p>
<h1 id="class-成员、interface-成员"><a href="#class-成员、interface-成员" class="headerlink" title="class 成员、interface 成员"></a>class 成员、interface 成员</h1><p>class 成员：字段、常量、属性、方法、事件、运算符、索引器、构造函数、终结器、嵌套类型。<br>interface 成员：方法、属性、索引器和事件</p>
<h1 id="类的执行顺序"><a href="#类的执行顺序" class="headerlink" title="类的执行顺序"></a>类的执行顺序</h1><p>父类，子类，静态块，静态字段，非静态块，非静态字段，构造器，方法</p>
<h1 id="数据类型和内存占用"><a href="#数据类型和内存占用" class="headerlink" title="数据类型和内存占用"></a>数据类型和内存占用</h1><p>1 byte bool、byte<br>2 byte char、short<br>4 byte int、float<br>8 byte long、double<br>16 byte decimal</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>编译时多态和运行时多态。</p>
<h2 id="编译时多态"><a href="#编译时多态" class="headerlink" title="编译时多态"></a>编译时多态</h2><p>重载编译时多态。根据签名不同分为不同的方法，编译后就成两个不同名函数。</p>
<h2 id="运行时多态"><a href="#运行时多态" class="headerlink" title="运行时多态"></a>运行时多态</h2><p>虚方法是运行时多态，父类中有虚方法，子类覆盖实现虚方法。</p>
<h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><p>在浅拷贝中，仅对顶级对象进行了复制，对低级别对象进行了引用。<br>在深拷贝中，会复制所有对象。</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>继承 ICloneable，实现 Clone()方法，方法中调用 MemberwiseClone()；<br>如果字段是值类型，则执行字段的按位复制；如果字段是引用类型，引用将复制，但被引用的对象不会被复制。</p>
<h1 id="协变和逆变"><a href="#协变和逆变" class="headerlink" title="协变和逆变"></a>协变和逆变</h1><p>in 逆变，out 协变。<br>赋值的兼容性，用在委托或者接口上。<br>需要<code>返回数据</code>，这种结构化的委托有效性之间的关系叫做协变，用 out 标记泛型类型。<br>需要<code>接受数据</code>，期望传入基类时允许传入派生对象的特性叫逆变，用 in 标记泛型类型。<br>协变：</p>
<ul>
<li>IEnumerable<out T></li>
<li>IEnumerator<out T></li>
<li>IQueryable<out T></li>
<li>IGrouping&lt;out TKey, out TElement&gt;</li>
</ul>
<p>逆变：</p>
<ul>
<li>IComparer<in T></li>
<li>IEqualityComparer<in T></li>
<li>IComparable<in T></li>
<li>Action<in T></li>
<li>Predicate<in T></li>
<li>Comparison<in T></li>
</ul>
<p>协变 + 逆变：</p>
<ul>
<li>TOutput Converter&lt;in TInput, out TOutput&gt;</li>
</ul>
<h1 id="object-和-dynamic"><a href="#object-和-dynamic" class="headerlink" title="object 和 dynamic"></a>object 和 dynamic</h1><p>object 是一种引用类型，表示 .NET 框架中的任何类型。它是所有引用类型的基类，允许将任何类型的对象存储在这个变量中。<br>dynamic 是 C# 中的一个关键字，在编译时将变量的类型指定为 dynamic ，对象的实际类型将在运行时确定，这在使用没有特定类型定义的 API 或库时非常有用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>object 是<code>基类</code>，可以存储任何引用类型；<br>dynamic 是<code>关键字</code>，在编译时跳过类型检查，在运行时确定类型。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>object 在我们不知道数据类型时很有用。<br>dynamic 更多是用在反射，支持动态语言，COM 对象调用以及获取 LINQ 的查询结果。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> a = <span class="string">&quot;Rohatash Kumar&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> a1 = a.ToString();</span><br><span class="line"></span><br><span class="line"><span class="built_in">dynamic</span> a = <span class="string">&quot;Rohatash Kumar&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> a1 = a;</span><br></pre></td></tr></table></figure>

<h1 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h1><ul>
<li>都能有默认实现；</li>
<li>都不能直接实例化；</li>
<li>抽象类单继承，接口多继承；</li>
<li>抽象类中可以有字段、属性、方法，接口中可以有属性、方法、索引器、事件，没有字段；</li>
</ul>

    </div>

    

    <section class="post-nav">
      
      <a class="prev" rel="prev" href="/csharp/CSharp-dotnet-and-csharp">CSharp .NET 和 C#</a>
      
      
      <a class="next" rel="next" href="/web/HTML-src-and-href">HTML src 和 href</a>
      
    </section>
  </article>
</div>
    </div>
    <footer id="footer" class="footer">
  <div class="copyright">
    <span><a href="javascript:void(0)">SanHuo</a> & <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a> | <a href="/sitemap.xml">Sitemap</a></span>
  </div>
</footer>
  </div>
</body>

</html>